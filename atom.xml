<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客.的个人博客</title>
  
  <subtitle>记录我的学习过程</subtitle>
  <link href="http://princesaoke.github.io/atom.xml" rel="self"/>
  
  <link href="http://princesaoke.github.io/"/>
  <updated>2025-12-28T10:09:02.220Z</updated>
  <id>http://princesaoke.github.io/</id>
  
  <author>
    <name>骚客.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中的so文件</title>
    <link href="http://princesaoke.github.io/2025/11/27/Android%E4%B8%AD%E7%9A%84so%E6%96%87%E4%BB%B6/"/>
    <id>http://princesaoke.github.io/2025/11/27/Android%E4%B8%AD%E7%9A%84so%E6%96%87%E4%BB%B6/</id>
    <published>2025-11-27T08:21:09.000Z</published>
    <updated>2025-12-28T10:09:02.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="so文件是什么"><a href="#so文件是什么" class="headerlink" title="so文件是什么"></a>so文件是什么</h1><p>so文件，即<code>Shared Object</code>，是用<code>C/C++（JNI）</code>编译出来的Android平台上的动态链接库，类比<code>.dll</code>。本质上就是一段用C&#x2F;C++写的、编译成机器码的本地代码库。</p><p>Android Java 层无法直接调用C&#x2F;C++，必须通过<code>JNI</code>。</p><h1 id="为什么Android要用so文件"><a href="#为什么Android要用so文件" class="headerlink" title="为什么Android要用so文件"></a>为什么Android要用so文件</h1><p>Android App 平时写的是Java或Kotlin代码，但有些场景下：</p><ul><li>对性能要求特别高（如图像处理、音视频解码、AI 推理等）</li><li>需要复用已有的C&#x2F;C++代码（如 OpenCV、FFmpeg、TensorFlow Lite）</li><li>需要调用底层系统接口（JNI 层）</li></ul><p>这时就会用到Native层代码（C&#x2F;C++），然后编译生成so文件，供Java层调用。</p><h1 id="so文件存放路径"><a href="#so文件存放路径" class="headerlink" title="so文件存放路径"></a>so文件存放路径</h1><p>so文件必须放在特定路径，<code>AGP（Android Gradle Plugin）</code>才能识别到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app/src/main/jniLibs/</span><br><span class="line"></span><br><span class="line">├── armeabi/libopencv.so</span><br><span class="line"></span><br><span class="line">├── armeabi-v7a/libopencv.so</span><br><span class="line"></span><br><span class="line">├── arm64-v8a/libopencv.so</span><br><span class="line"></span><br><span class="line">└── x86/libopencv.so</span><br></pre></td></tr></table></figure><p>Android设备有多种ABI（CPU架构），so文件也须根据不同架构单独编译，每个CPU架构文件夹下都放对应的so文件。</p><p>可以在app模块的<code>build.gradle</code>中指定：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调用so方法"><a href="#调用so方法" class="headerlink" title="调用so方法"></a>调用so方法</h1><h2 id="定义JNI方法"><a href="#定义JNI方法" class="headerlink" title="定义JNI方法"></a>定义JNI方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeHelper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 加载libopencv.so，去掉lib前缀</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;opencv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native方法，由C/C++实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常由提供so文件的一方提供封装了Java native方法的<code>jar</code>&#x2F;<code>aar</code>。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> NativeHelper.getMessage();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;so文件是什么&quot;&gt;&lt;a href=&quot;#so文件是什么&quot; class=&quot;headerlink&quot; title=&quot;so文件是什么&quot;&gt;&lt;/a&gt;so文件是什么&lt;/h1&gt;&lt;p&gt;so文件，即&lt;code&gt;Shared Object&lt;/code&gt;，是用&lt;code&gt;C/C++（JNI</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>互通登录</title>
    <link href="http://princesaoke.github.io/2025/11/17/%E4%BA%92%E9%80%9A%E7%99%BB%E5%BD%95/"/>
    <id>http://princesaoke.github.io/2025/11/17/%E4%BA%92%E9%80%9A%E7%99%BB%E5%BD%95/</id>
    <published>2025-11-17T06:53:04.000Z</published>
    <updated>2026-02-28T13:54:40.426Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ddf171ae5e7c8f5d99c47a7d8083ecc6091f4cebe4e0b8cebdda0ea831f59f79">f4618cd75d7e547a378d5b31f962b2e95666e10dc9cc08f05c72cd2af5b1c38766db60dc1bc422fa748c6ada76773eabd7eda3045d0ccdc70587e50b96c1ea3b98c498e8f545658d04962796549965a03b3cc1a15fa6eb5dcfc5adff449b79773e56eeb71d682ef809d060e428fc2f35fe540bb2cdf691ef4a80c1c9cbddb91acb99434804c8b8dfa83a192775cbfcd9af16a73a82eaf31fbe18acffa10e515a7004cd33e600603bbf9a7fac945975677aa992b79c9a344685067f4eaf42d44d68ad82404c4b20e978da1c712880ff616dbc96aef8591ae078b8e0357385c3ec54909f1b85e15d43eaa85c5bf83f101bf59193980f824b71a2ad686b4c70ce5c63e94cadffc5230300a38f8bf651477edd9f5e8be5943065f201b14d9ff7beedb9b20af72f22a8ce341e45de3d7601c7622d6a4f833ca861c85a1caeaec343681bfb80934a94eded02141b6f123dfa5e872bd8de6d00a29232798b02cbef51ba6451abd7692a1518b09a68cd58e8da21c650eefd99e11609ad4c4b151607ac7181f44c8d4e853eae7c1d34570d4a456eccacf8eb978f2366756b033e7a57262a22621b0ce785f05a18e85a34dd65820d103e2de458adc8a18aff7c800b8790b85eacbc49e27ec5db57a0d144b0f8cca23cd3fcb8e420eb4d38e575da414aed38c42e855ea16f4d30987d410aed7c9eaa0130b771bc561549ddbeba39958515ffe19d586e245c3da3eef12aec2e27a4a78448ec1f40e700b81fabb7d38488b2b39a5e5fd59c8336c8f8d28dcc31c68b0b0925dfdbb9a4c0319a4838a329faf13e8fdca249715bf54023ff6d365a279286b5f1ad68558917ec6b730db0a5c87eb2b6ee6b577ec993e786ce68da3e9ac158c36775df8adc2a525fe2cb978e53bd71f2c18ab6150f001d9c8c273982ec8ec914c6265c40d5b1341e6ad351a49d8776feadfe5b942d7d0a22f5baf7e60b92be559bd286eb0d5090918b9485ba20411fa055f8eeae02db0a8f72bc93312287363dcaf2d6ec5df8face8aef9966c20792b9eae3483f3a07fd050f4bcb58e4cd57f1190143c38331996cba6731039dd2e3b5e1d62478eea3295de28fa25b95cd36f6ad54c0105675a83bf96e86349dbc5c007964a2cc5bc7ea72e1a35b7c96a016b107533dd45df4c1b84075b415e7e881184fef4f2d0cbc50bf250df9bb7af7bdb364dd3693e1fb62fe00be34906df38ee7d6b4db19c60a175cb9047c7b11a5f5459095b6e3c55bea0a19e11d49dcbe5e9db23d57cc3010f76064c46296f86db43996c125e322c57e5ff10eba87afe4f3f858205a25ea450addc05fd471bbcb60e2454e717366ee8f5e223bb4eb9e4b5255946aa318cbe6731414e6827b9d58ddacd83dd6c3b5053f6d74b534cf068f43926e6729fe3b12e9b3f76c856c38e4815ed4ac5398a9310b0f6ba8d3150bd220abec7463f4e5790d12436633f975ea11c63cc374b0ca297b1441a6e2dc94b6e8471fe6225e3fb30f40524e363c14d932bb316e95215d7696335872c0180b921ac1ca10493910345b28c97d6931896bf2cebfcba51ca37924373645ca2a41472737785911fa2782a03f7781062521df83e0dad05788d10b3b36d9bdcf1b99e06e361d4cacd7547fe6679d1417ec705a9ff1825aea7a39e1c9cfd1a622a94de2e14efe554012aca5810b5121025761a50f5a70efcc96ab3d544ed59005839d3fdfc07641694fd18d989029fb0caacd9b8bccba5e62cc4e25a1624386a17b6ffe72c0c5fc6a607f4b359dc033d5c43bcf6e5b1e54f5dc539bfd16de6f7d12a070f8165449c884b67e2af4ae1266d4c74a71ef42517b9107f15cc1a9bcc1c71e0ac26d9aca23bb5328557806dc4052a327d5d1d34e52d38f92bbebffcf60b76b6df2ea358e2e21e9e4f606a696c1fec247e02852da00c97b24d71c761e7930458f7fcd439524c3d428ce4f2c631efb7f5d456964cdf8919a00676abbdf49c426ad2438097351976ad47226aafb2a61ebe5f57f6a17f9555492ec69860c241514e9fe7788d1b722d336e8c7633f0fe1bd768582d1bf5b47445bffd2078c4df31613613467a70633648290eb9a8b8e483f180af0246a0c19063f612191bc03f3a36520d59d6b02c1470dbbc0fa446f8cef83fa1dbe9cc42761a7cbeddeee6742577876dfb14590a6d8f48496922fe85f5f66d9058ef5705f6c8e4af591cc42711f1de25efd41630807c88e81b3c1515df3442f124d3f3352a4ee663787b2a3891fcc12fb88bcc5351517dc94d69e4da0802967395e9161c2b51969997fb96e0f14cde9bf74e39e4c6a0652ff9f8b684d60b38527c4a36aebcde5523711c5baafec5ffc68caa6043b12e9e43bee439880fc5860c179b1142db80f946ecb86c02a700b7dbd6cc569dadef93005c1a31b458e42fdc04cadf3c038e3cdfeaa07c8d34f1308724be4442258f78ec183ee7db643899f41bdd2a1afdac4e02703905e7475f30b04416fb833c7bbcc6b87ef04be1194db18ef6d9e7f41a647503577ea071e9e1fdcef479ef31eadd802f8ca75f78239262f3b122247e9088ee97c91bf173b2f792be4ddf3b9d75afa530e4d6b752d1a532648795edacdc47a653f87b6162e67045aebb26b5b625597f7ebd50afdd224220a715467210fc660d3698f801f8efed498cd5a6c68cbdf2e77a25d7ffabb1edbe0f83bd22dee48fad3bcc321732bfab20d4536705d4c20c2cf39d7401c4ed5669f8d7253228ef4deec9b22a593af19898739d82198b3828f8fe846329c4e28a9fc3142bd3e88b021cd05201e12aca6352ca5baab0343d91a36b8f490eaa5469f6b723cf8733aadf84d90225a8392b0a47f494850307b3a36a0377a182451c67970ad591835d9d042cdf265c617a5554716a4d19b81cae2365d2cf00d79b8f10a2a6cf9cbe904d323cbf8967da9f8cc1bd67e99007655f7c7c4b74f8d9ead9af96ff2762503d54091f81bfb36531911a02a9e5aa18a54994f13576c8713f70b7784371020925ded379e78e50fcc54eaa5c6ae288d7deaa1ebbd03d29735139d55170aca5b51d18aae8fe4c867602b034ea3f7845f1331592a19b1ed9d6ae78c7e1ef0121042a4cc97a96610fe2ae33832755920ac49fff3029949083644f82919ee0d2d9ecb5f6ff7c32125ab80227cdcdf4e29c22d7be84713de60f0215b358054614dd3133e4f5492252cc8c7464b51fa35a9db197321e87989da3ccb6a03c8c6277ac7e552a0a5c4fb9b5e0ed8f768f4bc527668be1d4ff4db071cc049d675b0569ce1e66f68d298d8be3dbfa6c2e3b080fdfe5be8ddd2a9fd1416959996e4183c0832b26cc4425a14838eb341fd3d1063bce9715a8d28a8dff1c646d53b21e4ae507a40e731d5fd77e9dfec495d9902d4a361c13597d6a0b3e2b14fcb824fd5fb796c3dcc261fb95daf28c307530beb42ba71f415e3d40dfe55020556c0df5fb8cbff3f302651f98e0387ce763c85072310715be96638a06b575c5dfe2f4b13847f042ea5815ea2df9b21d3ff401833e65a48247ce948708cfc669e0f9b4f266dd056197e7e4660f946c824df0c05bcea67795b7c498b830264e91354baa8338e84799881fe05e5d8d05dc0e8ba9b17b2ac598db8f562cb4404e04febd026957e585ec4a7a248166d0381721fc03148bfb7de97a6a5ec93510d7257f5e316437b9f43e6c68a322c33e096ad04b5c2e5a7a8c328c9959f9c330cb4047e696371ccadc83549a2fe0bfec3f54fb4d77062eda33f788869411b308a62ff007f87ce326d15c5237950207619141f89cfefa0c0b3d212bbf4f35d3279c006950f60c2675577670d26eb67abb20ae972608f6faf3baa9056eee4559dfd95f070cbdd41d8c2c3e2a996efffaed27b62b281e52a2e47fef911181b31f35b189f69303b4fdd96041eb10aa94f050a0c2cd8f06bb722b3260e68212ad7780ab56a337419cfb799284d377eaf35dcf849b4b91de229a8ae7e90ad1ac9e8ad0b3ec34ad9e53025dc4b285dd15d5e8f8e37cdf362c3a62eb189931af58f2a90c15cc8346802ec40146ca63b3ccddc577c1f6dc6dd85eee372d787c6602d4bc06eebc7b9e40defbf13128b0483c040eca6cffafb186e26d65eb53a74b66cd36e642dc287b5c37505527b2ede3e73d5668c47045e03c7b8c72c6892fb70306ad6aeadb3fa6a233c1d19bb1cfbed8926a93c37cc945234e27e059716d28b4d0a712b3d3ad2cd0da033f61aeb4260e29952a8c5c6845f9170432913798cf29d930c5c69107665a64885aa924533754e9ccdcbcdbc07a9f0647c06cd7711258cd1821f267020730feeb81c57538e09b4feac0bc03da58c2a29c95b9971b019341d1901ce6f632a21c669799414cb8ec6e6a5e7b39aff8c58f41edbab45bbba1b1cb7e289cf927069080c2e07097f4a5231e2f8871a4d790525c4a51ad8ecf14782d36fb01ca32c7cfcfa8f0bcc61d117027ec1df9854bb5c0b899b4ebfc7f8c22edec9ca05d0dea29e48d4c48b3469264165f2793186fadbec66b51c8414b9c4dda402cadc3515fc399eb05bc41513fa19d2f6d082fc675505285b4c3bee39bf43e22e8169cbfae0dd946ba309ef5774a8764b84d99589648397d3fd95585c45fd18a972a93f8d951fa3a5000583e27d0404d61a2f051127013cbfe13d5726b7c61d6d707cb1b982ccf6344c18a57fcc8250a972fb950f92f14db60c7ed9d8987a26539c2f22c86216b25d1e12d637942d0c8c9c84ac61e97883bc39ebfc12a91b3d1cf2f9565ba782dbbe5c63f9c9b1a26ab4569a8e819cf50afba6296ae11e50180cdaca75c934eff1fb2448b801f9577399fca44dee672bbf44040dda008029d2709928348a37f325dcaa469b9256cce3f51be8c57b098a683954966e446db334bc85106173d3d46aa63930ff58613e16fe45321bd6bb7ac1b1121ed1bb65199b3e4dd8ace61e20fda7e6543db817cf0b57eacd7b3bf5d52675d91c85200bf1fa15328191a923bfc8b862661033b9b27d7b5e3f55eb2cd81efa0128c14fa38613381b6f2e2d5b62ba2b3f31df74fdd7e32a7dfae064cc75dd8d1dbb0be9ffd3afb27de7bed9f60d9f26e522758d658c1f8b130d5fced3ebc0b1789b7bbc4d87dfff6b0fe0999745e840e9b89fead5408e7756ec519712bbd930a16d81ccc9738fd4b48b8a0c170a373fb27b7f7760a7d73ea53e790b46686b1d4fd9702f31502053c03c4fe83fe6e6e6cc490b209161c35712fbc79a7701d11ab1eb487832a59c304096715040e4d2c2783cd9206d84d8142733ad91bb1b9b75c359a59c6d3c3efa2892ed558739d71e977f32050f4179c8f40f3de6d5e88f1f92bf27a57685f164ba92c7461cf377d4338d45bb8210523f6f07156785dc14e89d993fadee708d4d6186405164a8e4e2a3c4b7e9956af49fe4dccc7a26e39989e571a60dcdd806fc296b0747028b075af6aaaadafff30409f58259285dd2877cab23386159c11a4c4bf86436440f3b563a51ed7af006ffe917ee7d6e0de3f73f03b81fdd53ef1ba8c05fca10c7c1f71c07f2e710bd0692cb297185f51bd8eac1e38f3be3c28d81016348d6ece69f2ec48716b45c5aa279f8433d8a8be474c40c5b53316cd6f0b27821afdea93591f8ff10aba7d4b7c5242d15c7755e7eb26d165bf4d47c23010cdc121910802b44ddaa3019b493b14360b989a1d460e8dc7df2ecd38190e7b6aa2437be5a30bb5cf37ef632929c81e49d8d7e5570cf0119a8ba86459ad0fb413096774d2b519455edf36b96f71908f1a626076b7c72d67e54cb59310795c5737c33efc443bade4fde4785d791b48b5809ed171b6adfcfb3f11b2b54d297bd60b37c9683b2c50d96c4ea3968da205f91bf8de897f52b0c892164d180433329f10618582c90dcacfd714a46f0bbebc4dcdaa577310f1cd37d9f43476c0d5b913c8f49dc3002af466dfa8514365f5268011aaee51a0cdd15befe5692cdd47e1070ec9406ccdbb3af3485649e5c703ac5277b36322b78e3e13346ce9751c87d99d5887421eb892fe0fc69470e7447a9ea51745553cf9590f2c618b3b2c105b53e67398c9e811ddc4f99c50a791e6e193b4e046dfa2355ea442e94ce17da16a8ccfaf0307cfabeae9ab7ca05433b102ec74b7087953fb882175c5f764023117cd15c9424a088ece2b3f6b7837f8cabed0946a27bf6309bfd4d225745ccfbe4cfd82bc863ec5a82a654827d34a30759093b9426df4cd0012833f7fa48b3ec1f3177574cae96a4533433526075bd39012572980d4282204f0c71286dc60b3239732bb1e60c33550eceb29f4d894e1b7d5659b2f409a2381bce278b66e9e81f1308fcb71a6bf07c7564f6a65940c622bb7190106bb623736c98497b92bbcc8ae5fdd0bddbb8a670406834963ea016c84bb636c60fbaa9d6708c683104270ef8db0facc4cd4bdab0d48cb9016f4de533690580b87a48c28489b6fd5609bd1a4daa68a4830f19b7055267b7be0e60480ddb942f100b0850e8630f2751b106ee64a19c82b9753292d52fa47e63498229399e5915856222455753ed530fe3ad8d83a5f6d03dc8e6f089aa9e4939c726678783a71a36c1760a113bc6638054a6c630605ee9f1e8cf7f42284b60b69ad628ad1efaddf9a6ce7fbe6b161eb170a6733b8ac4d8931fe943fe560621d89bb11020ddd827387c4cc45c1a1bc9e4030a6fa5b1cfadc619bc85b2a22d62b001a8799483ce603e823e4afd8d04e287260f74f51bc16520fe116c7994bcdf759ecf7d3b765805ad81e85c0d03e9a45e4d0533a88ec39a25ccb03efa3133ae9264b7e8f77bff59fc73cfebf8a39e1d1526862e3eb7d264696458f7080ebd95c82b6a8ab4fa167b0cd16f6f4812091b41faa7ea8092e65e7a4e10ec959c8b43ce927230dbd2aec3ebda5b2e3d7179357a43fb5aa8039ac07c95efa7bc02cfd32182d134cbe5b1b7eafb1a94db90577a878baecf044465157ef2c9424df93a2d3658eaebc2054ec0b7535f8125f64a8c6709255956a51668ce2eed04d9b8ab95dfc568812cf4534103af30f2a0943c2bfa6352b0443e1783e7bfdcf19b9f9d2498eacdf49253c127e712449cd18585adbfdc50326ba8de8a20bca0cc4594126e5b7ce34bbd2250724f59c1e8591f4813950dc635c160e7418cb660f49bb16c4a6ada62eafde280c68f4f3f5a99d7aebfb2ab6976a5c36b6d0a2b4cca05d4a0874ecd266a224ad50327e7d08bd7e61e1b9d9ac0e95c1d141f95eb7872037430d7705d56360e88c9b88a9f5ae78712d94d2548b9eb4bf44037f0a64c66f3cc29a5333f17b4bc180fa5ff3784b80154493b61e4b908d0b6c95f149e6ef6545ee818300368b464b4bd726ce0f28cc57f35edfde54d2f9e0a74517fe318f2c2b8b158165a726d11cc6f1d8c8d80da631460532ccfc610744c5b09398046eddf30ad47f1858508494bb2f6e619a90abd83030c5af571e43896536e2a388e083b80450fbb27ea0f8f8a0de1af8ac96f09259a4810a408f9fba0099944580176315537d59606848c07d67dfdc3b763560534114f269e55cc24c3977af2ca27ab5e330e7f80de7fc71ed0d721fdc7ac7c509a081ddc71d12775b4ebd5f01b29dc1dcc9db78a3ea320b5c2f0cd14218ce67b2f0e2a334e83c4b55deac6018842ec62d1312adfd841372a451e15af7ed8b6c8cfba18f4c5e2d45a233446bcc45912c62e00df1fe9ca5aa5f3bbebbc6fb144c5d95a1383e01cab87fe6102257158f1f0e7841083adf06b847167c5f6b6bee38a56ab939304253b8ef5af1c74c7dabde19d72dd70da83e89598504f69a12ed271d5eed8f7208bdf35ba26423e2ca05f3dca387c039bb81380c29c6e4e5a3b7588bab9abe81ee725da370b0bdaaf92572f1dffa976a1bf5ac7927c1b6f3d2875f33cef49703d922a6460ce7f3263c9a0a069683bb410e44708f6c2377549f3d0298639b6ab332d27f882f9ab30e727bd07f00475fc43231b029514183a588316ec63cd296846cc8492976e5797c69e8e3b12b6e3202bcea02a3f4ffbeaf9f947df0b8306b8710065c5d7cfe66b3f9799b52a01eb57e0f2c96cd71c906b4a985bcaf601c0cdc262ec0f62c9e66062f861d62c3bfcb57287f2db9d53961bf607a7e652c3d0f8016e473cfb73fa8f0c7bbb114163126fe2f332c2e4a78e992165bfd2226991d620c46b352028e23c6bede088ccee669b2e7a745c022f3f82ac3c78e393378051443bed9178aa97f0eeaca4a719082f24b0b3954596524684998ef32efd5a7f71fc809ae95c0cbe009a31a1bd5eb068c7a5da24c7cc1fbdac3d90a8d757439587d0020b9df6f2c1c2b48762d8132b7960b6df765fdc80d7764bd7daecfa122e53aab0f460340beb6cac35d323539bbe956156e64541383e9fa857b2ada2c0fa4886ae8b4df1b6de83408ebc2fc4f2cfb4d4f39ae775a00f8bfcacbe37f7cc246db052ae0a05a6d1874a54b55121717e1b95797ae753527b36a4472c13e1eba16040fa63bf5c3e3551b28dbad746494f31bbe1c967f90a0862b20a3bb50e84068c34188d15533eb0cafc8d625fb598f46ee0722635594578746d4ec5137025a1ded791fe51d489ab66a2180dea26e14f7d3057a4f0ec5f3978f789aeb7736a04095bfa5421f93cfd57e295cef6076313edf9e9944248b7ec1f996cfd0daa7ee7ddd81c112582397a57725a4847226fa7a5491499f354e60f8b958947201c7fcb78a97edd8443c708fd69b47ad512809b2f9854c74c5f84e26810a178a108354e134aabd1e8855582224f76fc8a54849365191a0ec868dfd1bbb8eddd772be83a714eb9ae33f5ca0c179a9d6cf18414bf9565b993692be7e32db79a8d04adbb7ace2e9e7c7e09f349909b7b7b85c65a330c41821a75cedfe2189a62f7c77b5c877b5dee95c9be666882617bac277d7656ef426de42b9d6cb8e60423cc6e5564493207067cc44721b25284a28376b082b23f45f745dd4c212b75da632c991c5db743de30653b030d16fe8bdf8c6d8ab4462f17fb527753e8bc720af29fb98ae12d1593e4abaaa7da72741351c311084e3e70f70fd90e9ddd0ab7da146fc8994dcb1c535112b757f89b45addf9d903fa7ff83ac63dbdffdf91ff1c72c6b869e794851e756280d6b730b5e1d3751774605b22de9ff25ba15fbdf82064e73344f0452f6a3878e580c1692aded33c5b24c06e277fa9b049700cb9faa6d28874ae8c0b05db72668d8992519121e1602fc7f1814a8b947e7c396d4de329c785a8931d7e2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="解决方案" scheme="http://princesaoke.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Hybrid开发</title>
    <link href="http://princesaoke.github.io/2025/08/22/Hybrid%E5%BC%80%E5%8F%91/"/>
    <id>http://princesaoke.github.io/2025/08/22/Hybrid%E5%BC%80%E5%8F%91/</id>
    <published>2025-08-22T09:01:30.000Z</published>
    <updated>2026-02-28T13:42:03.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h1><p>webview初始化时setWebChromeClient，重写onJsPrompt</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebView&quot;&gt;&lt;a href=&quot;#WebView&quot; class=&quot;headerlink&quot; title=&quot;WebView&quot;&gt;&lt;/a&gt;WebView&lt;/h1&gt;&lt;p&gt;webview初始化时setWebChromeClient，重写onJsPrompt&lt;/p&gt;
</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>isLogin接口优化</title>
    <link href="http://princesaoke.github.io/2025/08/15/isLogin%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    <id>http://princesaoke.github.io/2025/08/15/isLogin%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</id>
    <published>2025-08-15T02:50:28.000Z</published>
    <updated>2026-02-28T09:22:54.577Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ae98a1457b6a9a2508a59e7f53e30eb2762052ce319e05bd9170740fe4afcac0">f4618cd75d7e547a378d5b31f962b2e95666e10dc9cc08f05c72cd2af5b1c38707ebd0e2f7f2ac7bee4cc79a8660c56e0108067078380381bb7700df19a900e060967dcc2ff83893254b1926a8dba3b7acbdfbf269c7082408488504cd5300d1123d98fec8029ef5352b5091f596928bc6e69e7d7ef3b3121e7d1d797d4326dd043792b01c19b46f1b730aa0c053b762dc23b2dd19620656d1287a157f6c3144d77eff7849306399e8b6adb44c172d92e7416d45018e5e589dfc13856cdb792c556246fef7713cce0af759b1a8cd8fba726f523b370c9b09411e7da873ce4a54995131db205217afbc1861ced09ba92f79b85e56f4d37b6173bef0ee1e555c3bd9c48c970a78e65a9e4e454e2bf1df900a00d118c8a8a403639e960b593f3626fe8a93bcfdc6dc7eabaa397f1a9df37a7836e392487104311d6c217b5b997fd942a380564045135a531c342f048ce811cb34e51566f1332b08c33e0d7a7af6e95193ee0b7e4894da43f6fb900c1c759be9b568e01dae3d5070d23d128733e855bc713162a0dedfe3ee6040508cadc9c9bc51f45af281b50ee6bee874f4c23f950a1925c9d38aa1ed773724718847534d0989557ae0dfde53e50ab9049f560282464997479fb1870eddb6387c638148aa734f1f28a2627ea375297cc46b8ecc8e3c69ca7583acdeaae58021fad6293b04da7428927c80b6e2a8f5dd2e0fc2bca8db2f37ec04b09a043bf70a0bcd150d5a7ca67767a8a30a3e06819ce3589751df3c1cdf91a8c16b6b27aec35a3b9020cc84e6351b627a9e8155408d3f6fbd03b7a2916234a728a25ff7c93df64315f19b0077cabcba71f566f591093b0fdcc5dcec7c43da016d263a8168d1c429877247bbbdd7e711b83e16e4f2fcfc4a7c7b5d3397a91427dfd0e3ecc1d95ca420fb417e86edf74cee62f4696bf89a015b6b790f6316d07e16e8ebf4c4dee2606818b137cb854cc3d498233a5d8f10e49ec8884843fdbf9d1e75f87cbdc56e0b9d8c9f4742a343acf34598c0a1f2f7047b2eee1c38bbcf16ac35bc47c514965c8c288dee9f009811b5ab063aac411d98777b88151cf8d12953af05e829f92197aafcdb27d89c1f489f70bf8847e0e882519773a82f8452229e4c4dd10b2401ff9dccbd8627837c46e0724ad60082ff2ca3b1f64e110f1550df278fb9e46510cbceeb41d0cad3445e0d08701cf15bf1d68a2ca2b073f4fe401644b01782a7e848e7c2d693e6ec4712ba96ef2644d635e1ceb7d7223a09683324bed9e44174001308357d1c077e3a7d82bf8e69d6cad00314bf721175886f79c7012c2a7d1107110f87bd395097a5fa0b03715804700367e5ff7be9d04de3d6fd23d38d4fdfce985fc6c0aa3f83d319a806659841d912e1823ceb11694c9ae274628859407d420eb0511afe78fdc5b9d65e272b0ad91d7fd0467e70e2201b04b0efd7f5e2658291959726c98089b49f61907486dfa607d331c91ce07ce301d5e8524fd822141206228a40afa25670d3279313fb001498820e851941ffb13e9ac5a66e92254cae90b5b41b2a369b58a4192fe79449c7017b12f2e8af91f614b7428342424862d3ef549ea68993b9ab92e9a5633a92cf6689a28ddec995b303feda77a4d011d00a2d14d16d2fe92bf068efba6f242e4409a318066c644016b9bf3ed60c2e84eba562d798817b261aa5e866d612f4042867b71b14fd834375fedc8c0be15ead6a8b138a5ec57fa8e9e01b3ba843e2a61342a31434e12529b85849bd1d35d9bcefa27069d8ba4bad6822c10770adc554598362b317f44e9ec1b8597dc004f2565bc047892fe629b7d98eeaefe0e7bf4005293bc4093f16124ee712e4600759156372f306dd0aa15be008f2b4954ca8ffd7cd0f51ca0c469fdb11088d07244df144af9b9e20874701bde2c1b349936c5b94e1f5cd0794f27faf31b0e46a1cf045bf2aa55f7d67bcf1394b6030591290d87b5c7852bd62785c2357fe73cb5b1d67bad015772540a66ad115301b084f7857b2a2b6acff507cbe2a6457934c33082669027cf0c45a5baaf3f2f3a1f9531048f6dcb390dbb66316e5222758486f63c98b14a50293639c79c5c1af7c9e8058750b9e33f91b67f02b7d15978d54869f76f713157e63b23b3a093bd2733951f6ba88d4016d2f34ce3860940d7747964de9e0b7b9961df2221d6b706f13f4016cf888694fbe86ad281a167e99e6c504d4fd72fac2d53e324ea6c7587a4ff6eee65990409bc6db6ffe96155ed0444206c29993eec1f1dfc1b99f1123610be468a9bb754a8684ffa52fd3825ffe6dc68ebef5822bf069f49463e7068785638d22c60cf9afa71429d9c7a8a17ba056456c4c74b4a05f54ef39bb4b45cdd4033e3464b55f3ba753f747bd606d2d92b3132b8d3315f5c0fbc1b19206bac0dd4536836422329ee52b0995ef9ed8364bdf0cb3f4653ae3294a9d69339a364fbaa132c40932f9356d183fdc5eda3b10cb3599b2942ff089b161148436f5f3c6bd388c1032203e4b749b25986524b6388e6ade022c5dbfecf385fb9c9302ce5288329561fe4b6418bec5c24b0f47f1ec2c5c5143284bd58043698a3a6937df8ebf128f406eb5752f602d3cdbb5843be179e0def87636e09999ecfde9924351c0f300b160e3b0fdb5afffe7048d7345500c9406461db9742d5b93d49e9ba4052f2d0aa9b321038f19c1058163236dbed15ad5b3ce32b859681873c4114282cdb386d76be95513cd33659f0cbb90becc0a4046eb8b8c6da75b7083d4734bf5006c5c71fabb9a4684d118b9867c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="http://princesaoke.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>build.gradle详解</title>
    <link href="http://princesaoke.github.io/2025/07/22/build.gradle%E8%AF%A6%E8%A7%A3/"/>
    <id>http://princesaoke.github.io/2025/07/22/build.gradle%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-07-22T08:36:05.000Z</published>
    <updated>2025-12-28T10:02:35.802Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903933584883720">史上最全Android build.gradle配置详解，你懂的！</a></p><p><a href="https://stackoverflow.com/questions/16654951/what-is-the-difference-between-sourcecompatibility-and-targetcompatibility">What is the difference between “sourceCompatibility” and “targetCompatibility”?</a></p><p><a href="https://blog.csdn.net/Fine1938768839/article/details/75529260">Android Studio系列之代码混淆proguardFiles</a></p><h1 id="项目全局-build-gradle"><a href="#项目全局-build-gradle" class="headerlink" title="项目全局 build.gradle"></a>项目全局 build.gradle</h1><p>TODO</p><h1 id="模块中的-build-gradle"><a href="#模块中的-build-gradle" class="headerlink" title="模块中的 build.gradle"></a>模块中的 build.gradle</h1><h2 id="apply-部分"><a href="#apply-部分" class="headerlink" title="apply 部分"></a>apply 部分</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.android.application&#x27;</span> <span class="comment">// 表示这是一个应用程序模块</span></span><br><span class="line">apply plugin: <span class="string">&#x27;com.android.library&#x27;</span>     <span class="comment">// 表示这是一个库模块</span></span><br></pre></td></tr></table></figure><ul><li>应用程序模块：可以直接运行，打包得到<code>.apk</code>文件。</li><li>库模块：只能作为代码库依附别的应用程序模块运行，打包得到<code>.aar</code>文件。</li></ul><h2 id="android"><a href="#android" class="headerlink" title="android { }"></a>android { }</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// 编译使用的 Android 版本</span></span><br><span class="line">    compileSdkVersion <span class="number">34</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用项目全局 build.gradle 指定的版本</span></span><br><span class="line">    compileSdkVersion rootProject.ext.COMPILE_SDK_VERSION</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译使用的构建工具的版本</span></span><br><span class="line">    buildToolsVersion XX</span><br><span class="line">    </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.saoke.demo&quot;</span> <span class="comment">// 项目包名</span></span><br><span class="line">        minSdkVersion <span class="number">16</span></span><br><span class="line">        targetSdkVersion <span class="number">27</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 AndroidJUnitRunner 进行单元测试</span></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="comment">// 此处的 sourceCompatibility 和 targetCompatibility 对应 javac 中的 -target release 和 -source release</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定用于编译 Java 文件的 Java 版本</span></span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 编译后文件最低兼容的 Java 版本</span></span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="comment">// 生产环境配置</span></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 开启混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 指定混淆的规则文件</span></span><br><span class="line">            <span class="comment">// proguard-android.txt 是 SDK 自带的，我们可以在同目录下的 proguard-rules.pro 中自定义</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在代码中可通过`int versionCode = BuildConfig.VERSION_CODE`访问</span></span><br><span class="line">            <span class="comment">// 三个参数分别代表数据类型、键、值</span></span><br><span class="line">            buildConfigField <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;VERSION_CODE&#x27;</span>, <span class="string">&quot;$&#123;rootProject.ext.VERSION_CODE&#125;&quot;</span></span><br><span class="line">            buildConfigField <span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;VERSION_NAME&#x27;</span>, <span class="string">&quot;\&quot;$&#123;rootProject.ext.VERSION_NAME&#125;\&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// 同上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies { }"></a>Dependencies { }</h2><p>定义依赖关系。</p><ul><li>本地依赖：对本地的 jar 包或目录添加依赖关系</li><li>库依赖：对项目中的库模块添加依赖关系</li><li>远程依赖：对 Maven、jCener 上的项目添加依赖关系</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地依赖，将 libs 目录下所有 .jar 和 .aar 后缀的文件都添加到项目的构建路径当中</span></span><br><span class="line">implementation <span class="keyword">fileTree</span>(dir: <span class="string">&#x27;libs&#x27;</span>, <span class="keyword">include</span>: [<span class="string">&#x27;*.jar&#x27;</span>, <span class="string">&#x27;*.aar&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地依赖或库依赖</span></span><br><span class="line">implementation <span class="keyword">project</span>(<span class="string">&#x27;:moduleName&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程依赖</span></span><br><span class="line">implementation <span class="string">&#x27;com.google.android.material:1.0.0&#x27;</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.android.material:material:$DEV_VERSION.ANDROIDX_MATERIAL_VERSION&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h2><p>用<code>implementation</code>引入的依赖参与编译和打包，且是不可传递的，只能在模块内部使用。如A模块依赖了<code>Gson</code>，则B模块无法访问<code>Gson</code>。<br>未使用的依赖不会被打包，因此可以减少编译时间和减少最终APK的大小。</p><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>与<code>compile</code>相同。<br>参与编译和打包。该依赖方式会传递所依赖的库，当其他模块依赖了该模块时，可以使用该模块下用 api 依赖的库。</p><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>在 gradle 3.0 中已弃用，被<code>implementation</code>和<code>api</code>替代。<br>使用该方式依赖的库会参与编译和打包。</p><h2 id="compileOnly"><a href="#compileOnly" class="headerlink" title="compileOnly"></a>compileOnly</h2><p>只在编译时有效，不会参与打包。通常用于开发阶段需要但最终打包时不需要的库，如在开发测试工具时，可能需要使用的一些测试相关的库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903933584883720&quot;&gt;史上最全Android build.gradle配置详解，你懂的！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/ques</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android组件化开发</title>
    <link href="http://princesaoke.github.io/2025/07/21/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://princesaoke.github.io/2025/07/21/Android%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2025-07-21T09:19:13.000Z</published>
    <updated>2026-02-28T09:32:22.531Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d21be6ad116d081e08e809430288208d5041d1c6356b4a54007bd109323659b8">f4618cd75d7e547a378d5b31f962b2e9838bc1e5554abbee2148813ce62d5a578d6b244a267a00d01f9e28d65cfc137b7ad81dd7121cc00286ee129a94129f2207512e716a306ab5abaf711ac3b9c09852c953cc33ea6b1bc33bc4d69cbbc00dc12723ba85729e30509ea744e2b20ae46d320a691cf9b5978dd5c723f06f2339f27e936ca1ebc38b362cf46e4abca6593ffc743c585b3c00de71d969b7490461bcb2eb0f337a779f25d53e8b9e3b9ae54d65a4d9642d6009e37b0b783e4d030074201ca69f2afa4adec510fe000031d103f66ef7336d29f0837e2c26f0d82b2a87ec594a5aeec985df0b1bd33c1112170f90431e6330a0f8a9570ea9b61c53543452a7a16828a8ca9fa24042567da8ad0fb35662564884d056654fb5c3bd1ec8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="http://princesaoke.github.io/2025/02/14/Docker%E7%AC%94%E8%AE%B0/"/>
    <id>http://princesaoke.github.io/2025/02/14/Docker%E7%AC%94%E8%AE%B0/</id>
    <published>2025-02-14T08:48:08.000Z</published>
    <updated>2025-12-21T07:10:50.039Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hub.docker.com/">Docker 官方镜像仓库</a></p><p><a href="https://blog.csdn.net/u011278722/article/details/137673353">Ubuntu 22.04 下 Docker 安装（最全指引）</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以<code>Ubuntu 20.04</code>为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装前先卸载操作系统默认安装的 docker</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装必要支持</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用阿里源</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">阿里 apt 源</span></span><br><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新源</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新版本的 Docker</span></span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 版本</span></span><br><span class="line">sudo docker version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker 镜像</span></span><br><span class="line">sudo docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 运行状态</span></span><br><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><p>要实现远程访问，修改<code>/lib/systemd/system/docker.service</code>文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 找到 ExecStart 配置，注释并复制一行，在末尾加上 -H tcp://0.0.0.0:2375</span><br><span class="line"># ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375</span><br><span class="line"></span><br><span class="line"># 保存退出</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name mysql \</span><br><span class="line">    -p 3307:3306 \</span><br><span class="line">    -e TZ=Asia/Shanghai \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">    mysql</span><br></pre></td></tr></table></figure><p>反斜杠代表未换行，所以上面实际是一行命令。每一个Docker命令都以<code>docker</code>开头，<code>run</code>表示创建一个容器并运行，<code>-d</code>是后台运行。<code>--name</code>给容器起名字，名字必须唯一。<code>-p</code>是端口映射，外部无法直接访问到容器的端口，所以需要先访问宿主机的3307端口，再映射到镜像的3306端口。<code>-e</code>是设置容器的环境变量，可以查看文档，时区一般都要改，否则容器内的时间是默认时区。最后的<code>mysql</code>是指定运行的镜像的名字，完整写法是<code>mysql:5.7</code>，后面是版本号，省略默认最新版。</p><p><img src="/images/Docker%E7%AC%94%E8%AE%B0/command.png" alt="Docker常用命令"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有本地镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的本地镜像</span></span><br><span class="line">docker rmi &#123;镜像名&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器并运行，见上面的例子</span></span><br><span class="line">docker run -d &#123;镜像名&#125;</span><br><span class="line">docker run -dit &#123;镜像名&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器</span></span><br><span class="line">docker start &#123;容器名&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop &#123;容器名&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">销毁容器，需要停止容器才能销毁，或 -f 强制销毁</span></span><br><span class="line">docker rm &#123;容器名&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有容器状态</span></span><br><span class="line">docker ps</span><br><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部操作，-it 代表使用可交互终端的方式，bash 代表使用 bash 命令进行交互。也可以直接跟命令</span></span><br><span class="line">docker exec -it &#123;容器名&#125; bash</span><br><span class="line">docker exec -it &#123;容器名&#125; mysql -u root -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs &#123;容器名&#125;</span><br><span class="line">docker logs -f &#123;容器名&#125;  # 持续输出日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将指定镜像保存为 saved-image.tar 压缩包</span></span><br><span class="line">docker save -o saved-image.tar &#123;镜像名&#125;:latest</span><br></pre></td></tr></table></figure><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>由于镜像中只有必要的环境，多数情况下没有vim，要修改容器中的文件，需要用到数据卷挂载，将容器内的目录和宿主机的目录形成映射关系。</p><p>数据卷挂载只能在容器创建时设置。</p><p>宿主机的<code>/var/lib/docker/volumes</code>目录下存放所有的数据卷映射，其中<code>/var/lib/docker/volumes/&#123;数据卷名称&#125;/_data</code>中的文件与映射的容器内目录的文件一致，且保持同步。</p><p><img src="/images/Docker%E7%AC%94%E8%AE%B0/volume.png" alt="Docker常用命令"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据卷</span></span><br><span class="line">docker volume create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定数据卷</span></span><br><span class="line">docker volume rm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某数据卷详情</span></span><br><span class="line">docker volume inspect</span><br></pre></td></tr></table></figure><p>在创建容器时添加<code>-v &#123;数据卷名&#125;:&#123;要映射的容器内目录&#125;</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name nginx \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -v nginx:/usr/share/nginx/html</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure><p>创建容器时，若挂载了数据卷且数据卷不存在，会自动创建数据卷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker 官方镜像仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u011278722/article/details/137673353&quot;&gt;Ubuntu 22</summary>
      
    
    
    
    <category term="后端" scheme="http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Docker" scheme="http://princesaoke.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot笔记</title>
    <link href="http://princesaoke.github.io/2025/02/10/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    <id>http://princesaoke.github.io/2025/02/10/SpringBoot%E7%AC%94%E8%AE%B0/</id>
    <published>2025-02-09T17:00:40.000Z</published>
    <updated>2025-12-22T07:10:35.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在SpringBoot中可以使用<code>@Transactional</code>注解使用事务，它可以加在service层的方法上、类上、接口上。 </p><p>方法前加上<code>@Transactional</code>，则这整个方法是一个事物，方法执行前开启事务，执行成功则提交事务，出现异常执行失败则回滚事务。</p><p>在类上用<code>@Transactional</code>则相当于该类的所有方法都加了该注解。</p><p>在接口上用<code>@Transactional</code>则相当于该接口的所有实现类都加了该注解。</p><p>默认只有出现<code>RuntimeException</code>运行时异常才会触发回滚，我们可以使用该注解中的<code>rollbackFor</code>属性来指定何种异常会触发回滚。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>当一个事务中嵌套另一个事务时，可以用<code>@Transactional</code>注解的<code>propagation</code>属性指定是开启一个新事务还是加入当前的事务。具体属性值如下：</p><table><thead><tr><th align="center">属性值</th><th align="left"><center>含义</center></th></tr></thead><tbody><tr><td align="center">REQUIRED</td><td align="left">（默认）需要事务，有则加入，无则创建新事务</td></tr><tr><td align="center">REQUIRES_NEW</td><td align="left">需要新事务，无论有无，总是创建新事务</td></tr><tr><td align="center">SUPPORTS</td><td align="left">支持事务，有则加入，无则在无事务状态中运行</td></tr><tr><td align="center">NOT_SUPPORTED</td><td align="left">不支持事务，在无事务状态下运行，如果当前存在已有事务，则挂起当前的事务</td></tr><tr><td align="center">MANDATORY</td><td align="left">必须有事务，否则抛异常</td></tr><tr><td align="center">NEVER</td><td align="left">必须无事务，否则抛异常</td></tr></tbody></table><p>一般只需要关注前面两种情况就可以了。</p><p>例举个实际场景，删除用户，同时删除该用户发布的所有帖子，且不论删除成功与否都要记录操作日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUserById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deleteUser(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        deleteAllBlogsById(userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;删除了id为&quot;</span> + userId + <span class="string">&quot;的用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不加<code>propagation = Propagation.REQUIRES_NEW</code>，则默认两个方法共用一个事务，当出现异常时，事务回滚，把写入日志的操作也回滚了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;在SpringBoot中可以使用&lt;code&gt;@Transactional&lt;/code&gt;注解使用事务，它可以加在service层的方法上、类上</summary>
      
    
    
    
    <category term="后端" scheme="http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SpringBoot" scheme="http://princesaoke.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session和JWT</title>
    <link href="http://princesaoke.github.io/2025/02/02/Cookie%E3%80%81Session%E5%92%8CJWT/"/>
    <id>http://princesaoke.github.io/2025/02/02/Cookie%E3%80%81Session%E5%92%8CJWT/</id>
    <published>2025-02-01T17:16:02.000Z</published>
    <updated>2025-12-21T07:10:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>从客户端与服务器建立HTTP连接到断开连接的过程，称为一个会话。一个会话可以包含多次请求与响应。</p><p>由于HTTP协议是无状态的，服务器无法区分前后两个请求是否来自同一设备，因此有了三种会话跟踪方案：<code>Cookie</code>、<code>Session</code>和<code>JWT</code>。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>存储在浏览器中，发起请求时浏览器会自动带上Cookie，收到响应时浏览器会自动存储Cookie，是HTTP协议自带的功能。</p><p>Cookie的缺点：</p><ol><li>只有浏览器支持Cookie，APP不支持</li><li>不安全，存在CSRF攻击，且用户可以禁用Cookie</li><li>不能跨域</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cookie1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/cookie2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cookie.getName().equals(<span class="string">&quot;key&quot;</span>)) &#123;</span><br><span class="line">                log.debug(cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session是服务器在每个HTTP连接中对应的会话对象。Session存储在服务器中，其底层是基于Cookie实现的。</p><p>在建立连接第一次请求时，服务器会创建一个Session，每一次请求服务器都可以获取到其Session。每个Session有一个id，服务器响应数据时，会将Session的id放在Cookie中响应给浏览器。浏览器每次请求时会在Cookie中带上Session的id，服务器再根据id找到对应的Session，从而分辨前后两次请求是否是同一会话。</p><p>Session的优点：</p><ol><li>存储在服务端，安全</li></ol><p>缺点：</p><ol><li>在服务器集群环境下无法直接使用，不同服务器Session不一致</li><li>Cookie的缺点它也有</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/session1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/session2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(session.getAttribute(<span class="string">&quot;key&quot;</span>).toString());</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从客户端与服务器建立HTTP连接到断开连接的过程，称为一个会话。一个会话可以包含多次请求与响应。&lt;/p&gt;
&lt;p&gt;由于HTTP协议是无状态的，服务器无法区分前后两个请求是否来自同一设备，因此有了三种会话跟踪方案：&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;Sessio</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis笔记</title>
    <link href="http://princesaoke.github.io/2025/01/22/Redis%E7%AC%94%E8%AE%B0/"/>
    <id>http://princesaoke.github.io/2025/01/22/Redis%E7%AC%94%E8%AE%B0/</id>
    <published>2025-01-22T15:46:18.000Z</published>
    <updated>2025-12-22T07:10:21.503Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://redis.io/commands">Redis官方文档</a></p><p><a href="https://blog.csdn.net/weixin_50569789/article/details/126218139">Redis速成（小白也可掌握）</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Linux终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install redis-server   # 安装Redis</span><br><span class="line"></span><br><span class="line">redis-cli --version             # 安装后查看Redis版本</span><br><span class="line"></span><br><span class="line">sudo nano /etc/redis/redis.conf # 修改Redis配置</span><br></pre></td></tr></table></figure><p>在<code>redis.conf</code>文件中进行如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将绑定地址改为 0.0.0.0，让Redis可远程访问</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">#取消注释 requirepass 启动密码认证，后面跟Redis密码</span><br><span class="line">requirepass 自定义密码</span><br><span class="line"></span><br><span class="line"># 以守护进程运行Redis</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>修改保存后重新启动Redis并登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart redis-server  # 启动Redis</span><br><span class="line"></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a 密码  # 登录</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis有5种最常用的数据类型：</p><table><thead><tr><th align="center">数据类型</th><th align="center">样例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">Hello World</td><td align="left">字符串</td></tr><tr><td align="center">Hash</td><td align="center">{name: “saoke”, age: 18}</td><td align="left">JSON形式的字符串</td></tr><tr><td align="center">List</td><td align="center">[A → B → B]</td><td align="left">有序列表，元素可重复</td></tr><tr><td align="center">Set</td><td align="center">{A, B, C}</td><td align="left">无序集合，元素不可重复</td></tr><tr><td align="center">SortedSet</td><td align="center">{A: 1, B: 2, C: 3}</td><td align="left">有序集合，元素不可重复</td></tr></tbody></table><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><p>可以在<a href="https://redis.io/commands">Redis官方文档</a>查询。</p><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>存储：<code>set key value</code></p><p>获取</p><h1 id="SpringBoot-操作-Redis"><a href="#SpringBoot-操作-Redis" class="headerlink" title="SpringBoot 操作 Redis"></a>SpringBoot 操作 Redis</h1><p>可使用<code>SpringDataRedis</code>。 引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringDataRedis为了能使用对象作为键和值，实现了自动的序列化与反序列化。如果不经过自主配置，默认会对字符串键进行繁琐的序列化操作。</p><p>配置序列化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Template</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 和 value 使用 string 序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value 和 hashValue 使用 json 序列化</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        template.setValueSerializer(jsonSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于使用JSON序列化器需要Redis中额外记录包名用于反序列化，占用了太多空间，实际开发中一般直接使用<code>StringRedisTemplate</code>，程序员自己利用fastJson等工具转换JSON。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; jsonRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringRedisTemplateTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// String 类型操作</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;骚客&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash 类型操作</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;telephone&quot;</span>, <span class="string">&quot;13888888888&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(<span class="string">&quot;admin&quot;</span>, map);</span><br><span class="line">        Map&lt;Object, Object&gt; mapResult = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldResult</span> <span class="operator">=</span> (String) stringRedisTemplate.opsForHash().get(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jsonSerializerTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jsonRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;骚客&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) jsonRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><p>可分为三类主动更新Redis的方案。</p><h2 id="Write-Through（写穿）"><a href="#Write-Through（写穿）" class="headerlink" title="Write Through（写穿）"></a>Write Through（写穿）</h2><h2 id="Write-Back（写回）"><a href="#Write-Back（写回）" class="headerlink" title="Write Back（写回）"></a>Write Back（写回）</h2><p>只操作缓存，由其他线程异步地将缓存更新到数据库，保证最终一致。</p><h2 id="Cache-Aside（旁路缓存）"><a href="#Cache-Aside（旁路缓存）" class="headerlink" title="Cache Aside（旁路缓存）"></a>Cache Aside（旁路缓存）</h2><p>由程序员在代码中更新数据的同时操作缓存。</p><p>需要注意线程安全。操作数据库和缓存的先后顺序的两种情况都会导致数据不一致。</p><p><img src="/images/Redis%E7%AC%94%E8%AE%B0/cache_db.png" alt="先删除缓存再操作数据库"></p><p><img src="/images/Redis%E7%AC%94%E8%AE%B0/db_cache.png" alt="先操作数据库再删除缓存"></p><p>由于第二种方法只有当Redis中无该缓存数据时才会导致不一致，且Redis操作比数据库快，不容易被中断，因此先操作数据库再删除缓存更好。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远都不会生效，这些请求都会到达数据库。</p><p>解决方法包括以下几种：</p><ol><li>缓存空对象。当数据库查询不到时在Redis中缓存一个对应的null，并设置较短的过期时间。该方法的优点是简单方便，缺点是需要额外的缓存空间，如果有攻击者一直请求不存在的数据，缓存就会被占满。</li><li>布隆过滤器</li><li>增强查询id数据的复杂度，避免被猜测id规律</li><li>对请求数据进行合法性校验，可以直接排除一些无效请求</li><li>热点参数限流</li></ol><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指在同一时间大量的缓存key失效，或Redis服务器宕机，导致大量请求到达数据库。</p><p>例如，为了给缓存预热，提前把数据批量导入缓存，导致这批缓存的过期时间是一样的，就可能出现缓存雪崩。这种问题比较好解决，给过期时间加个随机数就好了。</p><p>对于Redis服务器宕机，可以搭建Redis集群，利用Redis的哨兵机制可以避免缓存雪崩。此外还可以给缓存业务添加降级限流策略，或给业务添加多级缓存，如Nginx、JVM和Redis的多级缓存。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是指某个被高并发访问的key失效了，且重建该缓存比较耗时，则在重建缓存的过程中的大量请求都会到达数据库。</p><p>可以加上互斥锁重建缓存，当其他请求到来时获取不到锁说明已经在重建缓存了，则休眠一段时间再尝试查询缓存直到命中。</p><p><img src="/images/Redis%E7%AC%94%E8%AE%B0/hcjc_hcs.png" alt="互斥锁"></p><p>但该方法所有其他线程都只能等待缓存重建，性能较差，且如果重建缓存需要得到其他服务的锁，就容易造成死锁。</p><p>另一种方法逻辑过期，不为该热点缓存直接设置过期时间，而是把过期的时间作为数据的一部分存在value中，然后把重建缓存的任务开启一个专门的线程去做，这样线程通过value中的过期时间判断是否过期，若过期则尝试获取锁去开启重建缓存的线程，若获取锁失败说明已经在重建缓存了，则直接返回过期的数据。</p><p><img src="/images/Redis%E7%AC%94%E8%AE%B0/hcjc_ljgq.png" alt="逻辑过期"></p><p>这里的互斥锁可以用Redis中的<code>setnx</code>指令实现（SpringDataRedis中是<code>setIfAbsent</code>），只有在该键不存在时才能写入。<code>setnx</code>相当于获取锁，<code>del</code>删除相当于释放锁。</p><p>这种方法的优点是线程无需等待性能较好，缺点是实现复杂，不能保证一致性。</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p><a href="https://blog.csdn.net/qq_41125219/article/details/119982158">布隆(Bloom Filter)过滤器——全面讲解，建议收藏</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://redis.io/commands&quot;&gt;Redis官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_50569789/article/details/126218139&quot;&gt;Redis速</summary>
      
    
    
    
    <category term="后端" scheme="http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Redis" scheme="http://princesaoke.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>百度秋招面经</title>
    <link href="http://princesaoke.github.io/2024/10/20/%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/10/20/%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-10-20T15:43:16.000Z</published>
    <updated>2026-02-25T08:59:58.735Z</updated>
    
    <content type="html"><![CDATA[<p>这一天是部门群面，要等通过后再决定部门和岗位。是移动生态相关的部门，包括百度文库、百度贴吧、百度APP等。</p><p>一个下午连面三场，都通过了。</p><p>更新：拿到百度Offer啦！</p><h1 id="一面-10-20-16-00"><a href="#一面-10-20-16-00" class="headerlink" title="一面 10.20 16:00"></a>一面 10.20 16:00</h1><p>30分钟左右。女面试官。</p><ul><li><span style="color: green">✔</span> 实习做了什么</li><li><span style="color: red">❌</span> Flutter和Android交互</li><li><span style="color: green">✔</span> HTTPS加密过程，可以被抓包破解吗？</li><li><span style="color: green">✔</span> DNS的解析过程</li><li><span style="color: green">✔</span> String、StringBuilder、StringBuffer的区别</li><li><span style="color: red">❌</span> StringBuffer是如何实现线程安全的？</li><li><span style="color: green">✔</span> 抽象类和接口的区别</li><li><span style="color: red">❌</span> 泛型的优点</li><li><span style="color: red">❌</span> Java反射</li><li><span style="color: green">✔</span> 线程和进程的区别</li><li><span style="color: green">✔</span> Java中如何保证线程的有序性和原子性？volatile的原理</li><li><span style="color: red">❌</span> Java线程池的优点？有几种常用线程池？</li><li><span style="color: green">✔</span> 线程池的工作流程</li><li><span style="color: green">✔</span> synchronized的使用场景</li><li><span style="color: red">❌</span> synchronized和lock的区别</li><li><span style="color: green">✔</span> Android四大组件</li><li><span style="color: green">✔</span> Activity生命周期</li><li><span style="color: green">✔</span> Activity启动模式</li><li><span style="color: green">✔</span> Android中的几种本地存储方式</li><li><span style="color: red">❌</span> MVP、MVC和MVVM的区别</li><li><span style="color: green">✔</span> 编程题：长度为n+1的无序数组，元素值为1~n，只有一个元素重复，找出该数，要求时间复杂度小于O(n^2)，空间复杂度为O(1)</li></ul><p>反问哪块比较薄弱，面试官说我安卓方面掌握的在候选人中算比较好，Java一些更底层的原理可以再学习，基本上都ok。当场就让我过了，马上紧接着二面。</p><h1 id="二面-10-20-16-30"><a href="#二面-10-20-16-30" class="headerlink" title="二面 10.20 16:30"></a>二面 10.20 16:30</h1><p>30分钟左右。男面试官，未开摄像头。</p><ul><li><span style="color: green">✔</span> Flutter的渲染机制</li><li><span style="color: green">✔</span> Flutter用自己的绘制方案，和其他跨端框架使用原生控件相比，有哪些优缺点？</li><li><span style="color: red">❌</span> 鸿蒙了解过吗</li><li><span style="color: green">✔</span> 使用Flutter时，有对网络请求进行封装吗？</li><li><span style="color: green">✔</span> 本地数据持久化有哪些方式？</li><li><span style="color: red">❌</span> 路由机制的底层实现，底层是什么数据结构</li><li><span style="color: red">❌</span> OCR接口的凭证如何存储？有做加密吗？</li><li><span style="color: green">✔</span> 柱状图是如何实现的？</li><li><span style="color: green">✔</span> Android为什么要改为动态授权？</li><li><span style="color: red">❌</span> Vue3和Vue2的区别</li><li><span style="color: red">❌</span> 响应拦截器中处理了拦截的数据，后续的拦截器还能否收到数据？</li><li><span style="color: green">✔</span> MMKV为什么比SharedPreferences更快</li><li><span style="color: green">✔</span> 编程题：翻转链表</li></ul><p>反问哪块比较薄弱，面试官说我有Android和Flutter的经验比较好，实践方面可以更深入，总的来说也挺好的。当场就让我过了，马上紧接着三面。</p><h1 id="三面-10-20-17-10"><a href="#三面-10-20-17-10" class="headerlink" title="三面 10.20 17:10"></a>三面 10.20 17:10</h1><p>30分钟左右。女面试官。</p><ul><li><span style="color: green">✔</span> 有哪些跨平台框架，Flutter和Android相比有哪些优劣</li><li><span style="color: red">❌</span> 既然Flutter有诸多优势，为什么还是有很多项目不使用Flutter？</li><li><span style="color: red">❌</span> Flutter性能上和原生差在哪？</li><li><span style="color: green">✔</span> 为什么选择移动端方向？</li><li><span style="color: green">✔</span> 有哪些本地持久化方案</li><li><span style="color: green">✔</span> 为什么放弃转正</li><li><span style="color: green">❌</span> 了解过鸿蒙吗？有实践吗？</li><li><span style="color: green">✔</span> 说一下实践中比较有挑战性的部分</li><li><span style="color: green">✔</span> Vue学习了多久，掌握了多少</li><li><span style="color: green">✔</span> 市面上的AI用过吗？你觉得国内的大语言模型存在哪些问题</li><li><span style="color: green">✔</span> 开放题：你觉得AI在未来可能在哪些领域</li><li><span style="color: green">✔</span> 有哪些企业的Offer</li></ul><p>面试官负责的部门是百度APP的技术中台，包括账号相关、SDK、前端、消息中台、交易保障等基础服务</p><p>反问哪块比较薄弱，面试官说我移动端的技术栈比较match，实践方面和二面面试官一样，觉得企业级的深度不够。</p><p>当场就让我过了，过几天hr会联系。最后面试官说如果她能优选的话，希望我可以去她那个部门。激动</p><h1 id="Offer-11-26"><a href="#Offer-11-26" class="headerlink" title="Offer 11.26"></a>Offer 11.26</h1><p>面完煎熬地等了半个月官网状态才变offer评估，然后就开始在牛客和小红书上搜集各种资讯，offer还没影就已经打开地图软件看在哪上班了 _(:3 ⌒ﾞ)_</p><p>好在又等了一周，hr加了微信，等谈薪电话又等了三天，最后拿顺丰的offer催了一下才谈薪。</p><p>其实也没什么能谈的，当时手上也没别的理想offer能a，顺丰开价差太多了，得物要是早点给offer就好了。我运气比较好，走完面试的基本都开出来了。</p><p>签完百度，得物又发了offer，在上海，也是纠结了几天，最后还是拒了得物，觉得对应届生来说大厂平台背书好点，自己也有点大厂情结。</p><p>应该就是三面面试官的部门，base地北京，好远。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一天是部门群面，要等通过后再决定部门和岗位。是移动生态相关的部门，包括百度文库、百度贴吧、百度APP等。&lt;/p&gt;
&lt;p&gt;一个下午连面三场，都通过了。&lt;/p&gt;
&lt;p&gt;更新：拿到百度Offer啦！&lt;/p&gt;
&lt;h1 id=&quot;一面-10-20-16-00&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Android中的View</title>
    <link href="http://princesaoke.github.io/2024/10/17/Android%E4%B8%AD%E7%9A%84View/"/>
    <id>http://princesaoke.github.io/2024/10/17/Android%E4%B8%AD%E7%9A%84View/</id>
    <published>2024-10-16T16:37:03.000Z</published>
    <updated>2025-12-21T07:09:35.205Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/7f635283067e">Android自定义View的基石——View工作原理总结</a></p><p><a href="https://www.jianshu.com/p/b6437e4b81ac">Android中View的更新方法：invalidate()和requestLayout()</a></p><h1 id="Activity创建View"><a href="#Activity创建View" class="headerlink" title="Activity创建View"></a>Activity创建View</h1><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/view_level.png" alt="视图层级"></p><p>DecorView下是一个竖直方向的LinearLayout，包含一个id为<code>android.R.id.content</code>的子View，在Activity的<code>onCreate()</code>中调用<code>setContentView()</code>就是设置这个contentView。</p><p>Activity的<code>onCreate()</code>方法调用之前，创建Window（PhoneWindow）<br>Activity的onCreate方法中调用<code>setContentView()</code>方法，创建<code>DecorView</code>和<code>contentView</code>，将指定的布局文件加载到contentView中<br>Activity的onResume方法调用之后，将DecorView添加到Window中，之后依次开始View的measure、layout和draw流程</p><h1 id="三大流程"><a href="#三大流程" class="headerlink" title="三大流程"></a>三大流程</h1><p><code>performTraversals()</code>方法内会依次调用<code>measureHierarchy()</code>、<code>performLayout()</code>、<code>performDraw()</code>，进而开始View的三大流程：测量measure、布局layout、绘制draw</p><h2 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h2><p>measure流程的作用是对View的大小进行测量。</p><p><code>MeasureSpec</code>类，由一个32位int值表示，高2位表示SpecMode（测量模式），低30位表示SpecSize（测量尺寸大小），通过位运算实现。</p><p>三种测量模式：</p><ul><li>UNSPECIFIED：父View不会限制子View的大小，一般用于系统内部，开发中使用很少</li><li>EXACTLY：父View能够确定子View的大小，如<code>match_parent</code>或给定精确尺寸（dp或px）</li><li>AT_MOST：子View的大小不能超过父View尺寸，具体尺寸需要由子View自身来确定，对应<code>wrap_content</code></li></ul><p>确定View尺寸的方法：</p><ul><li>当子View的LayoutParams指定为精确数值时，不管父View的测量模式是什么，子View的测量模式均为EXACTLY，测量尺寸为LayoutParams指定的值</li><li>当子View的LayoutParams指定为match_parent时，子View的测量模式取决于父View，即如果父View的测量模式为EXACTLY，那么子View的测量模式为EXACTLY；如果父View的测量模式为AT_MOST，那么子View的测量模式为AT_MOST，子View的测量尺寸均为父View可用空间大小</li><li>当子View的LayoutParams指定为wrap_content时，不管父View的测量模式是什么，子View的测量模式均为AT_MOST，测量尺寸为父View可用空间大小</li></ul><p>对于最顶层的DecorView：</p><ul><li>DecorView的LayoutParams指定为MATCH_PARENT时，它的测量模式为EXACTLY，测量尺寸为屏幕尺寸</li><li>DecorView的LayoutParams指定为WRAP_CONTENT时，它的测量模式为WRAP_CONTENT，测量尺寸为屏幕尺寸</li></ul><p>View的measure流程：</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/measure_view.png" alt="View的measure流程"></p><p>ViewGroup的measure流程：</p><p>ViewGroup中并没有重写onMeasure()方法，因为每个ViewGroup的布局方式都不一样，无法得出一个统一的实现方式，需要不同ViewGroup自己去实现。</p><p>遍历子View，获取每个子View的MeasureSpec，然后调用每个子View的measure()方法进行测量。再根据子View的测量结果对ViewGroup自身进行测量。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/measure_view_group.png" alt="ViewGroup的measure流程"></p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>layout的作用是根据测量大小确定View的最终位置。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/layout.png" alt="layout坐标系"></p><p><code>layout()</code>方法中比较left、right、top、bottom是否改变，若改变则执行<code>onLayout()</code>。对于单一的View，onLayout()中不做任何事。对于ViewGroup，调用抽象的onLayout()方法（同样需要子类自己去实现），遍历子View并调用其layout()方法确定位置，不断递归。</p><h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><p>draw的作用是将View绘制到屏幕上。</p><ul><li>调用drawBackground()方法绘制背景</li><li>调用onDraw()方法绘制自身内容</li><li>调用dispatchDraw()方法绘制子View</li><li>调用onDrawForeground()方法绘制装饰，包括滚动条和前景</li></ul><p>其中onDraw()是抽象方法，需要不同的View自己去实现绘制方式。</p><p>在单一的View中dispatchDraw()是空方法，ViewGroup则实现了其逻辑，遍历所有的子View并调用其draw()方法。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/draw.png" alt="draw流程"></p><h1 id="invalidate、postInvalidate-与-requestLayout"><a href="#invalidate、postInvalidate-与-requestLayout" class="headerlink" title="invalidate、postInvalidate 与 requestLayout"></a>invalidate、postInvalidate 与 requestLayout</h1><p>三者都是View中的方法，用于刷新视图，最终都会调用<code>ViewRootImpl</code>的<code>performTraversals()</code>方法。</p><ul><li>invalidate不会执行<code>measure</code>和<code>layout</code>流程，只执行<code>draw</code>流程。</li><li>invalidate与requestLayout都必须在主线程调用，要在子线程中刷新视图用<code>postInvalidate</code>方法</li></ul><p>调用<code>View</code>的<code>invalidate()</code>方法后会逐级调用父View的方法，最终导致<code>ViewRootImpl</code>的<code>scheduleTraversals()</code>方法被调用，进而调用<code>performTraversals()</code>方法。由于<code>mLayoutRequested</code>的值为<code>false</code>，因此不会执行<code>measure</code>和<code>layout</code>流程，只执行<code>draw</code>流程。</p><p>draw流程的执行过程和是否开启硬件加速有关。如果关闭了硬件加速，从<code>DecorView</code>开始的所有View都会重新完成绘制。如果开启了硬件加速，只有调用<code>invalidate()</code>方法的View（包括它的子View）会完成重新绘制。由此也可以看出，开启硬件加速确实可以提高重绘的效率。</p><p><code>postInvalidate</code>其实就是通过Handler完成了线程的切换，使得invalidate()方法在主线程中被调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7f635283067e&quot;&gt;Android自定义View的基石——View工作原理总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b6437e4b81ac</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://princesaoke.github.io/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://princesaoke.github.io/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2024-09-27T01:23:39.000Z</published>
    <updated>2025-12-21T07:02:26.401Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/512400553025003520">一文吃透TCP面试八股文</a></p><p><a href="https://cloud.tencent.com/developer/article/1662002">TCP&#x2F;IP协议之传输层：TCP&#x2F;UDP协议详解（一）</a></p><p><a href="https://blog.csdn.net/qq_38289815/article/details/80969419">HTTP 和 HTTPS 的区别（面试常考题）</a></p><p><a href="https://zhuanlan.zhihu.com/p/275695831">http请求中get和post方法的区别</a></p><h1 id="OSI七层网络模型、TCP-IP四层模型、TCP-IP五层模型"><a href="#OSI七层网络模型、TCP-IP四层模型、TCP-IP五层模型" class="headerlink" title="OSI七层网络模型、TCP&#x2F;IP四层模型、TCP&#x2F;IP五层模型"></a>OSI七层网络模型、TCP&#x2F;IP四层模型、TCP&#x2F;IP五层模型</h1><p><strong>OSI七层网络模型</strong>：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p><strong>TCP&#x2F;IP四层模型</strong>：应用层、传输层、网络层、网络接口层</p><p><strong>TCP&#x2F;IP五层模型</strong>：应用层、传输层、网络层、数据链路层、物理层</p><h1 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h1><p><strong>TCP</strong>，全称<code>Transport Controll Protocol</code>，传输控制协议。</p><p><strong>UDP</strong>，全称<code>User Data Protocol</code>，用户数据报协议。</p><h2 id="TCP、UDP位于哪一层"><a href="#TCP、UDP位于哪一层" class="headerlink" title="TCP、UDP位于哪一层"></a>TCP、UDP位于哪一层</h2><p>二者都是传输层协议。</p><h2 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h2><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP是可靠的，UDP是不可靠的</li><li>TCP有拥塞控制机制，UDP没有</li><li>TCP是面向字节流的，UDP是面向数据报文的</li><li>TCP只支持点对点通信，UDP支持一对一，一对多，多对多</li><li>TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区</li><li>TCP报文首部不同，TCP首部20个字节，UDP首部8个字节</li></ul><h2 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h2><ul><li>数据包校验防止发送过来的数据是错误数据</li><li>确认序列号，对失序报文进行重排</li><li>丢弃重复数据包，防止数据冗余重复</li><li>确认应答机制，接收方接受数据之后会发送一个确认</li><li>超时重传机制，发送方发出数据后会启动一个定时器，超过该定时器时间依旧未收到对方确认，便会重新发送该数据</li><li>流量控制确保接收方收到的数据在自身缓冲区中不会溢出</li><li>拥塞控制，保证数据在网络中传播的可靠性，降低丢包的概率，提高TCP的可靠性</li></ul><h2 id="TCP-和-UDP-各自的适用场景"><a href="#TCP-和-UDP-各自的适用场景" class="headerlink" title="TCP 和 UDP 各自的适用场景"></a>TCP 和 UDP 各自的适用场景</h2><p>对实时性要求比较高，且允许数据丢失的情况，选择UDP，比如实时视频通话、游戏。</p><p>不允许数据丢失，及大多数情况适用TCP。</p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>UDP报文：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/udp.png" alt="UDP报文"></p><p>TCP报文：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp.png" alt="TCP报文"></p><h2 id="TCP-和-UDP-分别对应的常见应用层协议"><a href="#TCP-和-UDP-分别对应的常见应用层协议" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议"></a>TCP 和 UDP 分别对应的常见应用层协议</h2><p>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</p><p>基于UDP的应用层协议：DNS、TFTP、SNMP</p><h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><p>二者的区别在于：</p><ul><li>HTTP是明文传输，HTTPS使用SSL加密传输</li><li>HTTP在三次握手后即可传输报文，而HTTPS三次握手后还要进行SSL握手</li><li>HTTP端口是80，HTTPS端口是443</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http.png" alt="HTTP报文"></p><p>SSL通过先<strong>非对称加密</strong>的方式传输密钥，再用密钥对传输数据进行<strong>对称加密</strong>，来解决窃听风险。之所以要两种加密方式混用，是因为对称加密比非对称加密要快，因此数据传输使用对称加密，而非对称加密可以实现交换密钥。</p><h2 id="客户端如何校验证书合法性"><a href="#客户端如何校验证书合法性" class="headerlink" title="客户端如何校验证书合法性"></a>客户端如何校验证书合法性</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CA_check.png" alt="证书校验流程"></p><p>发送端数字证书分为两部分，一部分是公钥等信息，另一部分是数字签名。将第一部分的信息通过哈希算法计算出哈希值，再用私钥加密，即是数字签名。</p><p>客户端收到证书后，根据公钥解密数字签名得到哈希值，再与自己计算的哈希值比较，相同则说明合法。</p><p>由于中间人无法得知私钥，即便篡改了证书也无法修改正确的哈希值，因此无法伪造。</p><h2 id="HTTPS抓包"><a href="#HTTPS抓包" class="headerlink" title="HTTPS抓包"></a>HTTPS抓包</h2><p>其实就是中间人攻击的原理。需要将抓包用的证书添加到浏览器，作为中间人。</p><h1 id="HTTP1-0-和-HTTP2-0-的区别"><a href="#HTTP1-0-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.0 和 HTTP2.0 的区别"></a>HTTP1.0 和 HTTP2.0 的区别</h1><ul><li>长连接，<code>Connection: Keep-Alive</code>，以便其他请求复用，只要任意一端没有明确提出断开连接，则保持TCP连接状态</li><li>多路复用</li><li>HTTP1.0 基于文本格式，而 HTTP2.0 基于二进制格式</li><li>头部压缩</li></ul><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ul><li>GET用于获取资源、读取数据；POST用于修改和写入数据</li><li>GET把参数包含在URL中，POST通过request body传递参数，因此POST能发送的数据更大，GET有URL长度限制</li><li>POST多几个首部字段，如content-type，POST能发送更多数据类型，GET只能发送ASCII字符</li><li>GET会将静态资源缓存起来，POST不会，因此POST更安全</li><li>POST在真正接收数据之前会先将请求头发送给服务器进行确认，服务器返回100 Continue响应，然后才真正发送数据，因此GET比POST快</li></ul><h2 id="常见请求头和响应头"><a href="#常见请求头和响应头" class="headerlink" title="常见请求头和响应头"></a>常见请求头和响应头</h2><table><thead><tr><th align="center">请求头</th><th align="left"><center>说明</center></th><th align="left"><center>示例</center></th></tr></thead><tbody><tr><td align="center">Accept</td><td align="left">指示客户端可以接受的内容类型，例如text&#x2F;html，application&#x2F;json等</td><td align="left"></td></tr><tr><td align="center">Accept-Charset</td><td align="left">可接受的字符编码类型</td><td align="left">Accept-Charset: utf-8</td></tr><tr><td align="center">Connection</td><td align="left">客户端（浏览器）想要优先使用的连接类型</td><td align="left">Connection: keep-alive</td></tr><tr><td align="center">Cookie</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">Content-Length</td><td align="left">以8进制表示的请求体的长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="center">Content-Type</td><td align="left"></td><td align="left">Content-Type: application&#x2F;x-www-form-urlencoded</td></tr><tr><td align="center">Host</td><td align="left">服务器的域名以及服务器所监听的端口号</td><td align="left">Host: <a href="http://www.baidu.com/">www.baidu.com:80</a></td></tr><tr><td align="center">User-Agent</td><td align="left">浏览器的身份标识字符串</td><td align="left">User-Agent: Mozilla</td></tr></tbody></table><table><thead><tr><th align="center">响应头</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="center">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以跨域源资源共享</td><td align="left">Access-Control-Allow-Origin: *</td></tr><tr><td align="center">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left">Content-Length: 348</td></tr><tr><td align="center">Date</td><td align="left">此条消息被发送时的日期和时间</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td align="center">Last-Modified</td><td align="left">所请求的对象的最后修改日期</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td align="center">Set-Cookie</td><td align="left">用于在客户端设置 Cookie，通常用于会话管理或跟踪用户状态</td><td align="left"></td></tr></tbody></table><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>……</p><h2 id="mDNS"><a href="#mDNS" class="headerlink" title="mDNS"></a>mDNS</h2><p>……</p><h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h1><p><code>MQTT</code>和<code>HTTP</code>的区别：</p><ul><li>MQTT以数据为中心，而HTTP是以文档为中心的</li><li>MQTT生成的消息大小较小，因为它使用二进制格式。HTTP生成的消息大小更大，因为它使用ASCII格式</li><li>MQTT是轻量级和发布&#x2F;订阅模型，HTTP是基于请求&#x2F;响应模型</li></ul><h1 id="FTP-和-SFTP-的区别"><a href="#FTP-和-SFTP-的区别" class="headerlink" title="FTP 和 SFTP 的区别"></a>FTP 和 SFTP 的区别</h1><p><strong>FTP</strong>，File Transfer Protocol，文件传输协议</p><p><strong>SFTP</strong>，Secure File Transfer Protocol，安全文件传输协议</p><ul><li>SFTP通过提供加密的连接和安全的数据传输来提高安全性，而FTP的安全性较低</li><li>FTP使用TCP&#x2F;IP协议，而SFTP是SSH协议的一部分</li><li>FTP使用21端口，而SFTP通过SSH协议的22端口</li></ul><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码用于确定IP地址的网络部分和主机部分。<code>主机地址 &amp; 子网掩码 = 网络地址</code>。</p><p>如<code>192.168.1.0/24</code>，说明IP地址的前24位是网络地址，整个网络的地址为<code>192.168.1.0</code>，最后8位是主机地址，即<code>192.168.1.1</code>~&#96;192.168.1.254<code>分配给各个主机，其中</code>192.168.1.255&#96;一般为广播地址，指定该网络下的所有主机。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/subnet_mask.png" alt="子网掩码"></p><p>还可以进行子网划分，如<code>192.168.1.0/26</code>，则借用了主机地址的两位，分成4个子网。如下图。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/subnetting.png" alt="子网掩码"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/512400553025003520&quot;&gt;一文吃透TCP面试八股文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/articl</summary>
      
    
    
    
    <category term="计网" scheme="http://princesaoke.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>秋招面经</title>
    <link href="http://princesaoke.github.io/2024/09/22/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/09/22/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-09-22T09:02:16.000Z</published>
    <updated>2026-02-25T08:50:00.193Z</updated>
    
    <content type="html"><![CDATA[<p>部分面经记录，有的录音懒了没写下来。</p><p><a href="https://my.feishu.cn/base/R2Q7b0wRFaEeKssxUnIchDndnhc?from=from_copylink">秋招记录</a></p><h1 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h1><p>无笔试，直接约面。</p><h2 id="飞书LOE"><a href="#飞书LOE" class="headerlink" title="飞书LOE"></a>飞书LOE</h2><h3 id="一面-9-24"><a href="#一面-9-24" class="headerlink" title="一面 9.24"></a>一面 9.24</h3><p>一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍</li><li><span style="color: green">✔</span> 谈实习，说一下难点和解决方法</li><li><span style="color: red">❌</span> flutter或Android中的手势消费原理</li><li><span style="color: red">❌</span> flutter是如何生成一个安卓应用的</li><li><span style="color: green">✔</span> flutter渲染原理，三棵树</li><li><span style="color: red">❌</span> flutter的桥，调用native能力，如调用相机</li><li><span style="color: green">✔</span> 线程和进程的区别</li><li><span style="color: red">❌</span> 多线程相关，线程间哪些是共享的？进程间哪些是共享的？</li><li><span style="color: red">❌</span> 什么是线程安全，如何保证线程安全</li><li><span style="color: green">✔</span> Java的基本数据类型与包装类型有哪些？二者有什么区别？</li><li><span style="color: red">❌</span> 深拷贝和浅拷贝的区别？具体是如何copy的？</li><li><span style="color: green">✔</span> 链表和哈希表的区别，适用场景</li><li><span style="color: green">✔</span> HashMap实现原理，若用对象作为键，修改对象的属性，获取到的值会改变吗</li><li><span style="color: red">❌</span> requestlayout 和 invalidate 的区别</li><li><span style="color: red">❌</span> RecyclerView是如何展示列表数据的？notifyItemChanged局部刷新列表数据，其他局部刷新的方法</li><li><span style="color: green">✔</span> MMKV的使用，相对 SharedPreferences 的优点</li><li><span style="color: red">❌</span> TCP和UDP的区别，TCP的可靠传输是怎么实现的？</li><li><span style="color: red">❌</span> 2G的单词，给100M空间，如何知道出现频率top10的单词？</li><li><span style="color: green">✔</span> flutter对比原生安卓的优劣势</li><li><span style="color: red">❌</span> flutter用的布局模型是什么</li><li><span style="color: red">❌</span> 编程题：输出二叉树的后序遍历（不用递归）</li></ul><p>计网基础还是不熟悉。问了一些安卓相关的也没答上来。</p><p>java在虚拟机中除了线程计数器、jvm栈和方法栈是线程私有的，其余的java堆、方法区、和运行时常量池都是线程共享的内存区域。</p><p>9.25已挂 T^T</p><h1 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h1><h2 id="笔试-9-21"><a href="#笔试-9-21" class="headerlink" title="笔试 9.21"></a>笔试 9.21</h2><p>两个小时。30道选择题，共60分；2道编程题，共40分。</p><p>编程题第一题AC，第二题做的时候已经有思路了，但是时间来不及细细斟酌代码了。</p><p>前端岗位和客户端岗位考的是同一场，选择题考了挺多JavaScript，还有一些CSS。</p><h2 id="核心本地商业-美团平台"><a href="#核心本地商业-美团平台" class="headerlink" title="核心本地商业-美团平台"></a>核心本地商业-美团平台</h2><h3 id="一面-9-27"><a href="#一面-9-27" class="headerlink" title="一面 9.27"></a>一面 9.27</h3><p>一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍？学习过哪些编程语言？通过什么方式？打算从事哪些技术栈？</li><li><span style="color: red">❌</span> 批量下载用Android怎么实现？线程池有了解吗？</li><li><span style="color: green">✔</span> 简单介绍MQTT</li><li><span style="color: red">❌</span> MQTT和HTTP底层有什么区别？如何用Android写一个推送？</li><li><span style="color: green">✔</span> 如何解决Flutter组件多层嵌套的问题？</li><li><span style="color: green">✔</span> 如何防止XSS攻击？</li><li><span style="color: green">✔</span> 数据库如何存储密码？MD5如何校验密码？哈希算法如何保证密码不被知晓？彩虹表破解？</li><li><span style="color: green">✔</span> JSON数据的value可以有哪些数据类型？</li><li><span style="color: green">✔</span> 链表和数组的区别？</li><li><span style="color: green">✔</span> 面向对象三大特性，分别讲一下</li><li><span style="color: green">✔</span> 静态变量和非静态变量的区别？静态变量什么时候分配内存的？</li><li><span style="color: red">❌</span> 什么是内存泄漏？如何排查？例举Android中常见的内存泄漏？</li><li><span style="color: green">✔</span> 发送HTTP请求时要填哪些参数？请求头、请求方法、响应字段</li><li><span style="color: green">✔</span> HTTP、TCP分别是哪一层的协议</li><li><span style="color: green">✔</span> HTTPS为什么安全？SSL的过程</li><li><span style="color: red">❌</span> 客户端如何判断服务端的证书是合法的？客户端如何知道证书被中间人篡改了？</li><li><span style="color: green">✔</span> TCP三次握手过程，为什么要三次？</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: red">❌</span> 两个线程如何通信？Android子线程与主线程的通信，子线程如何通知主线程刷新UI</li><li><span style="color: red">❌</span> 进程间如何通信？用代码如何实现？</li><li><span style="color: green">✔</span> 编程题：合并两个有序链表</li><li><span style="color: red">❌</span> 编程题：代码实现死锁</li><li><span style="color: green">✔</span> 同步和异步的区别</li></ul><p>问的还算简单，结尾直接约了二面在当天。不过二面面试官没空，推到第三天了。激动</p><h3 id="二面-9-29"><a href="#二面-9-29" class="headerlink" title="二面 9.29"></a>二面 9.29</h3><p>40分钟左右。</p><ul><li><span style="color: green">✔</span> 有什么想补充的？打算做哪方面技术栈？</li><li><span style="color: green">✔</span> Flutter的优点</li><li><span style="color: red">❌</span> 结合底层机制、编译原理、程序运行，Flutter是如何从Dart源码到应用程序并运行的？</li><li><span style="color: red">❌</span> 结合Flutter和前端在布局渲染方面的共同点，界面是如何渲染显示的？canvas相关</li><li><span style="color: red">❌</span> 结合编译原理，非页面的代码，业务逻辑代码是怎么运行的？如发一个网络请求。源码如何在设备上运行起来？Dart语言的编译流程？</li><li><span style="color: green">✔</span> Java的编译流程？JVM起到什么作用？</li><li><span style="color: green">✔</span> 为了让程序运行，JVM需要做什么事？</li><li><span style="color: green">✔</span> 用C语言和Java的区别？</li><li><span style="color: green">✔</span> 面向过程和面向对象各自的特点</li><li><span style="color: green">✔</span> 学习了哪些专业课程？在实际开发中用到了哪些？</li><li><span style="color: green">✔</span> 在业务开发中不同的网络协议如何做选择？</li><li><span style="color: green">✔</span> 数据结构与算法在实际开发中的应用？有哪些常用的数据结构</li><li><span style="color: red">❌</span> 数据超出数组长度如何处理？如何扩容？</li></ul><p>感觉面试官很想问我dart和Flutter底层的运行原理，可惜确实不了解。</p><p>9.30已挂。差点以为好运来了，呜呜呜</p><h2 id="软硬件服务-骑行事业部"><a href="#软硬件服务-骑行事业部" class="headerlink" title="软硬件服务-骑行事业部"></a>软硬件服务-骑行事业部</h2><h3 id="一面-10-11"><a href="#一面-10-11" class="headerlink" title="一面 10.11"></a>一面 10.11</h3><p>被捞了。一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍，介绍项目、实习</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: green">✔</span> Java中的几种锁</li><li><span style="color: green">✔</span> 进程通信的几种方式</li><li><span style="color: green">✔</span> 对象锁和类锁的区别</li><li><span style="color: green">✔</span> OSI七层网络模型，传输层的协议</li><li><span style="color: green">✔</span> TCP和UDP的区别</li><li><span style="color: green">✔</span> HTTP基于哪个传输层协议，有哪些版本，3.0基于TCP还是UDP，各版本的区别</li><li><span style="color: green">✔</span> HTTPS加密过程，为什么要混合加密？</li><li><span style="color: green">✔</span> 四种引用方式与区别</li><li><span style="color: red">❌</span> 软弱虚引用的使用场景</li><li><span style="color: green">✔</span> 浅拷贝和深拷贝</li><li><span style="color: green">✔</span> HashMap原理，链表和红黑树转换的阈值，ConcurrentHashMap如何保证线程安全</li><li><span style="color: red">❌</span> Java8前后的ConcurrentHashMap实现方式的区别</li><li><span style="color: green">✔</span> volatile关键字的作用</li><li><span style="color: green">✔</span> Java中类的加载机制</li><li><span style="color: red">❌</span> 类加载器有哪几种</li><li><span style="color: red">❌</span> Android中的handler消息机制</li><li><span style="color: red">❌</span> 四大组件的作用</li><li><span style="color: red">❌</span> Activity、Service、BroadcastReceiver什么情况下会出现ANR</li><li><span style="color: green">✔</span> Activity的启动模式</li><li><span style="color: red">❌</span> ListView和RecyclerView的区别</li><li><span style="color: green">✔</span> RecyclerView四级缓存机制</li><li><span style="color: red">❌</span> 如何计算和屏幕一样大小的图片的占用内存</li><li><span style="color: red">❌</span> Android的事件分发机制</li><li><span style="color: green">✔</span> 编程题：分层输出二叉树的层序遍历</li></ul><p>开头问了一下实习，可能是觉得没什么好聊的，转而问八股了。之前面美团基本只问了八股没怎么问Android，这次一问，好多都没答上来。</p><p>最后手撕环节，层序遍历用队列一气呵成写完，面试官要求分层输出，和刚刚的小黑盒一面的代码题一模一样，但是没有去看。看的出来面试官很想让我过，一直在提示我，但是始终没有get到点，好在最后用自己的方法也是做出来了，被自己蠢哭。</p><p>反问的时候问了面试官自己有哪些薄弱点，面试官说我Android相关的需要再更深入了解，手撕代码有待加强。</p><h1 id="阿里淘天"><a href="#阿里淘天" class="headerlink" title="阿里淘天"></a>阿里淘天</h1><h2 id="1688部门"><a href="#1688部门" class="headerlink" title="1688部门"></a>1688部门</h2><h3 id="一面-10-17"><a href="#一面-10-17" class="headerlink" title="一面 10.17"></a>一面 10.17</h3><p>45分钟左右。</p><ul><li><span style="color: green">✔</span> Android和Flutter的区别</li><li><span style="color: green">✔</span> 编程题：用数组实现栈</li><li><span style="color: green">✔</span> 编程题：两个线程交替打印</li><li><span style="color: green">✔</span> Java中锁的类型</li><li><span style="color: red">❌</span> AtomaticInteger是如何实现的？</li><li><span style="color: green">✔</span> 如何自定义View</li><li><span style="color: green">✔</span> 如何用RecyclerView实现一个数据列表？有哪些关键方法？</li><li><span style="color: red">❌</span> 如何用RecyclerView实现每个列表项不一样的布局？RecyclerView的源码看过吗</li><li><span style="color: green">✔</span> 如何用RecyclerView实现一个数据列表？有哪些关键方法？</li><li><span style="color: red">❌</span> 下载器断点续传、并发下载如何实现？</li></ul><p>最后反问觉得哪块比较薄弱，面试官说都还好，许愿过。</p><h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><p><a href="https://princesaoke.github.io/2024/10/20/%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/">百度秋招面经</a></p><h1 id="虾皮Shopee"><a href="#虾皮Shopee" class="headerlink" title="虾皮Shopee"></a>虾皮Shopee</h1><h2 id="Android开发工程师-深圳"><a href="#Android开发工程师-深圳" class="headerlink" title="Android开发工程师-深圳"></a>Android开发工程师-深圳</h2><h3 id="笔试-10-8"><a href="#笔试-10-8" class="headerlink" title="笔试 10.8"></a>笔试 10.8</h3><h3 id="一面-10-19"><a href="#一面-10-19" class="headerlink" title="一面 10.19"></a>一面 10.19</h3><ul><li><span style="color: green">✔</span> 编程题：删除单向链表倒数第n个节点</li><li><span style="color: green">✔</span> Flutter和其他跨平台框架有什么区别？</li><li><span style="color: red">❌</span> AtomaticInteger是如何实现的？</li><li><span style="color: red">❌</span> getStorage持久化存储在本地的文件格式是什么样的？怎么从磁盘中读取的？</li><li><span style="color: green">✔</span> 在主线程中进行IO操作可能出现什么问题（ANR）？在子线程中操作会有吗？</li><li><span style="color: green">✔</span> MMKV和SharedPreferences的区别</li><li><span style="color: red">❌</span> 用protobuf数据协议和SharedPreference的区别</li><li><span style="color: green">✔</span> HTTP协议的常见响应码</li><li><span style="color: green">✔</span> HTTP三个版本之间的区别</li><li><span style="color: red">❌</span> Android中跨进程通信的几种方法，几种方法之间的区别（binder和消息队列）</li><li><span style="color: green">✔</span> MQTT基于TCP还是UDP，MQTT的优势</li><li><span style="color: red">❌</span> 用TCP可以做推送吗？还有哪些协议可以推送？</li><li><span style="color: red">❌</span> 图片加载器用过哪些？Image.network源码看过吗？</li><li><span style="color: green">✔</span> Android中的数据库如何使用？</li><li><span style="color: green">✔</span> HashMap和ConcurrentHashMap的区别</li><li><span style="color: red">❌</span> HashMap和LinkedHashMap的区别</li><li><span style="color: green">✔</span> 多线程同时访问HashMap可能会发生什么问题？</li><li><span style="color: green">✔</span> Java中sleep()和wait()的区别</li><li><span style="color: green">✔</span> 悲观锁和乐观锁</li><li><span style="color: green">✔</span> 项目中用拦截器做了什么</li><li><span style="color: red">❌</span> 自己的项目中token有几级，多久过期</li><li><span style="color: green">✔</span> 项目中的基于拓展方法做屏幕适配</li><li><span style="color: green">✔</span> HTTPS加密过程，为什么要混合加密</li><li><span style="color: red">❌</span> 如何知道服务器发来的证书是合法的？</li></ul><p>反问，可以再加强算法数据结构、网络、操作系统，一些常问的问题。</p><h3 id="二面-10-26"><a href="#二面-10-26" class="headerlink" title="二面 10.26"></a>二面 10.26</h3><p>场景拷打穿插八股，逮着简历上写的一个下载器问，问的很细。</p><p>面试官没开摄像头，上来就问我实习公司的规模，是不是去的外包公司，我直接？？？</p><p>而且很多时候感觉她没理解我说的东西，问的一些问题也奇奇怪怪的，我之前的回答都说了，结果又问一遍。面试体验不太好。</p><ul><li><span style="color: green">✔</span> 为什么放弃转正？</li><li><span style="color: red">❌</span> 下载器的设计架构？用了什么设计模式</li><li><span style="color: green">✔</span> 单例如何保证对象只被创建一次</li><li><span style="color: green">✔</span> volatile的功能</li><li><span style="color: green">✔</span> 什么是线程和进程</li><li><span style="color: red">❌</span> Flutter下载没有用到多线程，是如何让主线程不卡死的？</li><li><span style="color: green">✔</span> 实现一个安卓的下载管理器怎么做</li><li><span style="color: green">✔</span> 下载完成是如何通知主线程的？</li><li><span style="color: red">❌</span> CPU是如何调度线程和进程的？调度算法？</li><li><span style="color: red">❌</span> 进程切换开销比线程切换开销大的原因</li><li><span style="color: red">❌</span> 死锁条件</li><li><span style="color: green">✔</span> 有哪些锁</li><li><span style="color: green">✔</span> 使用自旋锁的场景，有什么优点和缺点？如何避免缺点</li><li><span style="color: red">❌</span> 用过哪些设计模式？工厂模式的应用场景和设计理念？</li><li><span style="color: green">✔</span> HTTPS相关？如何确认证书的合法性？</li><li><span style="color: red">❌</span> HTTPS一定安全吗？是否有漏洞？</li><li><span style="color: red">❌</span> 抓包原理？如何抓HTTPS</li><li><span style="color: green">✔</span> 网络请求涉及的整个流程</li><li><span style="color: red">❌</span> DNS会带来哪些问题？DNS劫持是怎么做到的？如何解决？</li><li><span style="color: red">❌</span> 如何提升HTTPS请求速度</li><li><span style="color: red">❌</span> 多路复用的原理</li><li><span style="color: green">✔</span> HTTP2.0 和 HTTP3.0 的区别</li><li><span style="color: red">❌</span> HTTP3.0 QUIC为什么更快？如何实现可靠性的</li><li><span style="color: green">✔</span> 下载器缓存策略，如何做本地持久化</li><li><span style="color: red">❌</span> 图片加载缓存原理，LRU，如何实现图片缓存，用什么数据结构？</li><li><span style="color: green">✔</span> 哈希表原理</li><li><span style="color: red">❌</span> Android中解决哈希冲突的方法</li></ul><p>难度挺大，出现了好多之前没问过的，像线程调度、HTTPS抓包、DNS劫持、LRU。</p><p>已挂。</p><h2 id="iOS开发工程师-深圳"><a href="#iOS开发工程师-深圳" class="headerlink" title="iOS开发工程师-深圳"></a>iOS开发工程师-深圳</h2><h3 id="笔试-11-5"><a href="#笔试-11-5" class="headerlink" title="笔试 11.5"></a>笔试 11.5</h3><h3 id="一面-11-9"><a href="#一面-11-9" class="headerlink" title="一面 11.9"></a>一面 11.9</h3><p>之前随手投的iOS开发，居然发笔试了，做完又给面试了。</p><ul><li><span style="color: green">✔</span> 对iOS方向怎么想</li><li><span style="color: green">✔</span> 为什么选Flutter而不是其他跨端框架</li><li><span style="color: red">❌</span> Flutter的劣势？RN的优势？</li><li><span style="color: red">❌</span> MQTT订阅发布步骤？为什么MQTT比HTTP更稳定</li><li><span style="color: red">❌</span> TCP和UDP的区别</li><li><span style="color: red">❌</span> 多路复用是什么</li><li><span style="color: green">✔</span> 基于流和基于报文的区别</li><li><span style="color: red">❌</span> 接收方如何知道发送方流数据的总大小？如何知道从哪一位字节开始？</li><li><span style="color: green">✔</span> 有直接用TCP实现过连接吗</li><li><span style="color: green">✔</span> 端口是什么？服务器和客户端的端口分别有什么用？</li><li><span style="color: green">✔</span> 除HTTP、MQTT外其他的建立连接的方式</li><li><span style="color: red">❌</span> 服务器如何主动给客户端推送消息？</li><li><span style="color: green">✔</span> MMKV的优势</li><li><span style="color: red">❌</span> 了解过mmap吗？</li><li><span style="color: green">✔</span> DNS</li><li><span style="color: red">❌</span> HTTPS抓包</li><li><span style="color: green">✔</span> HTTPS加密过程</li><li><span style="color: red">❌</span> 如何判断证书是否合法</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: green">✔</span> 哪些部分是线程私有的？哪些是线程共享的？</li><li><span style="color: red">❌</span> 线程间通信的方法</li><li><span style="color: green">✔</span> 消息队列如何实现进程间通信</li><li><span style="color: green">✔</span> 什么是管道，常见的管道，Linux中的管道符<code>|</code></li><li><span style="color: green">✔</span> 线程安全，有哪些锁</li><li><span style="color: green">✔</span> 编程题：手写快排</li></ul><p>反问：无iOS经验影响大吗？</p><p>答：没什么影响，受限于设备原因大部分校招生都没啥iOS的经验。</p><p>反问：哪部分比较薄弱？</p><p>答：计网的一些细节，某些特性是属于TCP还是HTTP有些记混了，MMKV原理和mmap可以去了解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;部分面经记录，有的录音懒了没写下来。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.feishu.cn/base/R2Q7b0wRFaEeKssxUnIchDndnhc?from=from_copylink&quot;&gt;秋招记录&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;字节跳动&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的HashMap</title>
    <link href="http://princesaoke.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84HashMap/"/>
    <id>http://princesaoke.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84HashMap/</id>
    <published>2024-07-26T15:30:21.000Z</published>
    <updated>2025-12-22T07:07:16.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/hollischuang/p/12009172.html">为啥HashMap的默认容量是16？</a></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><code>HashMap</code>用于存储键值对，内部为散列表，每个数组槽位是一个链表或红黑树，即类似<strong>桶排序</strong>的结构。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/hash_map.png" alt="HashMap"></p><p>当调用HashMap的<code>put</code>方法新增键值对时，会根据HashMap类的静态方法<code>hash</code>，用键值对的键来计算出哈希值，并用<code>(散列表大小n - 1) &amp; hash</code>的值作为散列表数组下标，将新增的键值对放入。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/put.png" alt="put"></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/put_val.png" alt="put"></p><p>为解决哈希碰撞，每个散列表数组槽位内是一个链表或红黑树。当链表长度大于8，且散列表数组长度大于等64时，链表转化为红黑树；当红黑树节点小于6时退化成链表。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/threshold.png" alt="阈值"></p><p>来说计算哈希值的<code>hashCode</code>方法。当键不为<code>null</code>时，将键的<code>hashCode</code>方法的值，和自身右移16位的值进行异或，结果作为计算后的哈希值返回。键为空则结果为0。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/hash.png" alt="hash"></p><p>再来说说<code>(n - 1) &amp; hash</code>这个式子。其实就等同于hash的值对散列表长度n求模：<code>hash % n</code>。这样能确保计算出的哈希值不会超出散列表下标范围。</p><p>这里使用与运算<code>&amp;</code>而不是模运算，是因为位运算是直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p><p>且：<br>$$ x &#x2F; 2^n &#x3D; x &gt;&gt;&gt; n $$<br>$$ x % 2^n &#x3D; x &amp; (2^n - 1) $$</p><p>当除数是2的n次方时，x除的结果就等于二进制直接右移n位，模的结果就等于x和除数减一的二进制进行与运算。</p><p>例：$ 21 &#x2F; 8 $ 和 $ 21 % 8 $</p><p>21的二进制：10101， 8的二进制：01000， 7的二进制：00111</p><p>$ 21 &#x2F; 8 &#x3D; 21右移三位 &#x3D; 00010 &#x3D; 2 $ ， $ 21 % 8 &#x3D; 21 &amp; 7 &#x3D; 00101 &#x3D; 5 $</p><h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>虽然解决了哈希碰撞的问题，但若散列表太小，键值对太多，频繁出现哈希碰撞，链表或红黑树就会变得很长，此时就需要对散列表扩容。</p><p>前面提到，键值对放在散列表中的哪个位置，是由<code>(散列表大小n - 1) &amp; hash</code>决定的，与散列表大小有关。现在散列表大小改变了，意味着键值对存放的位置可能发生改变，要计算出扩容后所有键值对的新位置。</p><p>JDK1.7 中的做法是每个键值对重新hash映射到新的散列表，在 JDK1.8 进行了改进：</p><p>根据之前的结论，散列表长度必须是 $ 2^n $ ，每次扩容为之前的两倍。这样的好处是，扩容后计算<code>(n - 1) &amp; hash</code>，有变化的只有扩容前的n那一位。</p><p>例：原本散列表长度为8，下标为2处有一键值对，现长度扩容为16</p><p>8-1的二进制为<code>00111</code>，16-1的二进制为<code>01111</code></p><p>则对于<code>(n - 1) &amp; hash</code>，原先的值就是下标2，即<code>00010</code>，说明hash为<code>??010</code>，扩容后的值应该为<code>0?010</code>。</p><p>若<code>?</code>为0，则扩容后位置也不变，无需迁移。若<code>?</code>为1，则扩容后的新位置就是原先的下标加上扩容前的散列表长度。</p><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ul><li>父类不同：HashMap继承抽象类<code>AbstractMap</code>；而Hashtable实现<code>Dictionary</code>类。二者都实现<code>Map</code>接口</li><li>线程安全不同：Hashtable是线程安全的，而HashMap不是</li><li>能否有null：Hashtable中key和value都不允许出现null；而HashMap允许有一个为null的key，value可以有多个null，因此不能用<code>get()</code>返回null来判断HashMap中是否有某个键</li><li>哈希值的使用不同：Hashtable直接使用对象的<code>hashCode</code>；而HashMap重新计算哈希值</li><li>扩容方式不同：HashMap内散列表默认大小为16，扩容后一定为2<sup>n</sup>；Hashtable初始大小为11，扩容方式为<code>old * 2 + 1</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hollischuang/p/12009172.html&quot;&gt;为啥HashMap的默认容量是16？&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的类加载机制</title>
    <link href="http://princesaoke.github.io/2024/07/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://princesaoke.github.io/2024/07/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2024-07-20T16:11:09.000Z</published>
    <updated>2025-12-22T07:07:06.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><p>分为五步：加载、验证、准备、解析、初始化。</p><ol><li>加载：通过类全名获取类的二进制流，装入方法区，生成Class对象</li><li>验证：验证二进制流是否符合格式</li><li>准备：为类的静态变量划分空间</li><li>解析：将常量池内的符号引用转化为直接引用</li><li>初始化：执行静态代码块，为静态变量赋初值</li></ol><p>几种类加载器：</p><ol><li>启动类加载器</li><li>拓展类加载器</li><li>应用类加载器</li><li>自定义类加载器</li></ol><p><img src="/images/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/class_loader.png" alt="类加载器继承关系"></p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>核心思想是，当类加载器要加载一个类时，会先将加载任务委托给父类加载器，这个过程会一直递归直到最顶层的启动类加载器。只有当父类加载器无法完成加载任务时，才由子类加载器执行。</p><p>优点：</p><ul><li>避免类的重复加载</li><li>防止核心API被注入篡改，已经被加载过的类不会重复加载，避免了被篡改注入恶意代码的类被加载</li></ul><h1 id="Java中的static"><a href="#Java中的static" class="headerlink" title="Java中的static"></a>Java中的static</h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">Java中的static关键字解析</a></p><p>静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有<code>this</code>的，因为它不依附于任何对象。既然没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。</p><p>我们最常见的static方法就是main方法，而main方法必须是static的，是因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><p>Java规定static不能用来修饰局部变量。</p><p>与C&#x2F;C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        Person.age = <span class="number">18</span>;    <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q：Java中可以通过<code>this</code>访问静态成员变量吗？下面的代码输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 该value只是函数内部的局部变量，与this无关</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.value); <span class="comment">// 访问的是静态成员变量value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：可以，输出为<code>0</code>。</p><p>Q：以下代码输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的main函数&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Other</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的静态代码块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的静态代码块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">Other</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son中的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son中的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Other</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的构造函数，调用者：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Father中的静态代码块1</span><br><span class="line">Father中的静态代码块2</span><br><span class="line">Father中的main函数</span><br><span class="line">Son中的静态代码块</span><br><span class="line">Other中的静态代码块</span><br><span class="line">Other中的非静态代码块</span><br><span class="line">Other中的构造函数，调用者：Father</span><br><span class="line">Father中的非静态代码块</span><br><span class="line">Father中的构造函数</span><br><span class="line">Other中的非静态代码块</span><br><span class="line">Other中的构造函数，调用者：Son</span><br><span class="line">Son中的构造函数</span><br></pre></td></tr></table></figure><p>要运行静态函数main，首先要加载<code>Father</code>类。加载Father类时按顺序执行<code>static</code>块，输出前两行。</p><p>随后执行<code>main</code>函数，输出第三行。</p><p>再实例化<code>Son</code>。实例化前要先加载Son类，又因Son继承Father，则要先加载Father和Son，而Father已经加载了，于是加载Son，执行Son中的static块，输出第四行。</p><p>接着要实例化Son，在构造函数前要先初始化成员变量。因为继承Father所以要先初始化Father，Father有个<code>Other</code>类型的成员变量和一个非static块，按照先后顺序执行，又需要先加载并实例化Other。</p><p>于是加载Other，static块输出第五行。Other的非static块输出第六行，构造函数输出第七行。</p><p>接着Father初始化完成员变量继续按顺序执行非static块，输出第八行。</p><p>现在Son的父类Father成员变量已经初始化，于是Father的构造函数输出第九行。</p><p>Son的父类结束，轮到Son初始化成员变量，非static块每次实例化一个对象都会执行一次，因此Other的非static块再次执行输出第十行。其构造函数再输出第十一行。</p><p>最后Son的构造函数输出最后一行。Son实例化结束，main函数结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java类加载机制&quot;&gt;&lt;a href=&quot;#Java类加载机制&quot; class=&quot;headerlink&quot; title=&quot;Java类加载机制&quot;&gt;&lt;/a&gt;Java类加载机制&lt;/h1&gt;&lt;p&gt;分为五步：加载、验证、准备、解析、初始化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载：通过类全</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记</title>
    <link href="http://princesaoke.github.io/2024/07/10/Flutter%E7%AC%94%E8%AE%B0/"/>
    <id>http://princesaoke.github.io/2024/07/10/Flutter%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-10T01:17:26.000Z</published>
    <updated>2025-12-21T07:10:59.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter与其他跨平台方案的区别"><a href="#Flutter与其他跨平台方案的区别" class="headerlink" title="Flutter与其他跨平台方案的区别"></a>Flutter与其他跨平台方案的区别</h1><p><code>ReactNative</code>之类的框架，只是通过<code>JavaScript</code>虚拟机扩展调用系统组件，由<code>Android</code>和<code>iOS</code>系统进行组件的渲染；<code>Flutter</code>则是自己实现了一套组件渲染的逻辑。</p><p>Flutter的底层图像渲染引擎是<code>Skia</code>（它同时也是Android官方的图像渲染引擎）。Skia 是一款用 C++ 开发的、性能彪悍的 2D 图像绘制引擎，因为其出色的绘制表现被广泛应用在 Chrome 和 Android 等核心产品上。Skia 在图形转换、文字渲染、位图渲染方面都表现卓越，并提供了开发者友好的 API。Skia 已经是 Android 官方的图像渲染引擎了，因此 Flutter Android SDK 无需内嵌 Skia 引擎就可以获得天然的 Skia 支持；而对于 iOS 平台来说，由于 Skia 是跨平台的，因此它作为 Flutter iOS 渲染引擎被嵌入到 Flutter 的 iOS SDK 中，替代了 iOS 闭源的 Core Graphics&#x2F;Core Animation&#x2F;Core Text，这也正是 Flutter iOS SDK 打包的 App 包体积比 Android 要大一些的原因。Skia 保证了同一套代码调用在 Android 和 iOS 平台上的渲染效果是完全一致的。</p><p><img src="/images/Flutter%E7%AC%94%E8%AE%B0/flutter_framework.png" alt="flutter架构"></p><h1 id="StatefulWidget生命周期"><a href="#StatefulWidget生命周期" class="headerlink" title="StatefulWidget生命周期"></a>StatefulWidget生命周期</h1><p><a href="https://zhuanlan.zhihu.com/p/340491495">Stateful 组件的生命周期​</a></p><p><img src="/images/Flutter%E7%AC%94%E8%AE%B0/stateful_widget_lifecycle.png" alt="StatefulWidget生命周期"></p><ul><li><strong>createState</strong>：执行完毕后表示当前组件已经在组件树中</li><li><strong>initState</strong>：只会被调用一次，在其中进行初始化操作，如加载网络数据、添加监听器等</li><li><strong>didChangeDependencies</strong>：在initState后或其所依赖的<code>InheritedWidget</code>发生变化时调用</li><li><strong>build</strong>：在标脏后的下一帧被调用</li><li><strong>didUpdateWidget</strong>：当组件的configuration发生变化时调用此函数</li><li><strong>deactivate</strong>：当框架从树中移除此State对象时将会调用此方法，deactivate后还可以重新插入到树中</li><li><strong>dispose</strong>：当框架从树中永久移除此State对象时将会调用此方法，在其中释放相关资源</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flutter与其他跨平台方案的区别&quot;&gt;&lt;a href=&quot;#Flutter与其他跨平台方案的区别&quot; class=&quot;headerlink&quot; title=&quot;Flutter与其他跨平台方案的区别&quot;&gt;&lt;/a&gt;Flutter与其他跨平台方案的区别&lt;/h1&gt;&lt;p&gt;&lt;code&gt;</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Flutter" scheme="http://princesaoke.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Java中的String</title>
    <link href="http://princesaoke.github.io/2024/06/25/Java%E4%B8%AD%E7%9A%84String/"/>
    <id>http://princesaoke.github.io/2024/06/25/Java%E4%B8%AD%E7%9A%84String/</id>
    <published>2024-06-25T15:01:34.000Z</published>
    <updated>2025-12-22T07:07:27.030Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7235628080219488293">从零开始学Java之StringBuilder与StringBuffer使用及源码解读</a></p><h1 id="String为什么设计为不可变？如何保证String不可变？"><a href="#String为什么设计为不可变？如何保证String不可变？" class="headerlink" title="String为什么设计为不可变？如何保证String不可变？"></a>String为什么设计为不可变？如何保证String不可变？</h1><p>一旦一个<code>String</code>对象被创建，其存储的文本内容就不能被改变。这是因为：</p><ul><li>让并发编程变得更简单。引起线程安全问题的根本原因在于：多个线程需要同时访问同一个共享资源，修改资源，容易出现问题。如果共享资源在创建之后就完全不再变更，如同一个常量，有修改则返回一个新对象，则可以保证线程安全</li><li>不可变的对象因为状态不会改变，所以更容易进行缓存和重用。字符串常量池的出现正是基于这个原因。当代码中出现相同的字符串字面量时，JVM会确保所有的引用都指向常量池中的同一个对象，从而节约内存。</li><li>因为String的内容不会改变，所以它的哈希值也就固定不变。这使得String对象特别适合作为<code>HashMap</code>或<code>HashSet</code>等集合的键，因为计算哈希值只需要进行一次，提高了哈希表操作的效率。</li></ul><p>保证String不可变的措施：</p><ul><li>String类内部使用一个私有的字符数组来存储字符串数据。这个字符数组在创建字符串时被初始化，之后不允许被改变。</li><li>String类也不提供任何可以修改其内容的公共方法，像<code>concat</code>这些看似修改字符串的操作，实际上都是返回一个新创建的字符串对象，而原始字符串对象保持不变。</li><li>String类本身被声明为<code>final</code>，这意味着它不能被继承，防止通过子类添加修改方法来改变字符串内容的可能。</li></ul><h1 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a>StringBuilder 和 StringBuffer</h1><p><code>StringBuilder</code>和<code>StringBuffer</code>定义的字符串内容可变。</p><p>当遇到大量字符串连接时，由于String的不变性，每次都是返回一个新的String对象，因此用<code>StringBuilder</code>更合适，它不会生成很多新的对象，<code>StringBuffer</code>和<code>StringBuilder</code>类似，但每个方法上都加了<code>synchronized</code>关键字，所以是线程安全的。</p><ul><li>String：适用于字符串内容不会改变的场景，比如说作为<code>HashMap</code>的key</li><li>StringBuilder：适用于单线程环境下需要频繁修改字符串内容的场景，比如在循环中拼接或修改字符串，是String的完美替代品</li><li>StringBuffer：现在已经不怎么用了，因为一般不会在多线程场景下去频繁的修改字符串内容</li></ul><p><code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，其<code>append</code>方法最终是调用父类的<code>append</code>：</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/append1.png" alt="append"></p><p><em>以StringBuilder为例</em></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/append2.png" alt="append"></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/abstract_string_builder.png" alt="append"></p><p>而父类的append将字符串放入其字符数组中，同时记录字符数量的<code>count</code>也同步增加。其中<code>ensureCapacityInternal</code>方法是用来确保字符数组能放得下新加的字符串，当数组大小不够时会扩容。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/ensure_capacity_internal.png" alt="append"></p><p>若原有容量<code>oldCapacity</code>小于需要的容量<code>minimumCapacity</code>，就会利用<code>Arrays.copyOf()</code>方法，将当前数组的值拷贝给<code>newCapacity()</code>个长度的新数组，最后再重新赋值给value字节数组。<strong>因此是利用数组复制的方法来实现扩容</strong>。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/new_capacity.png" alt="append"></p><p><code>newCapacity</code>方法作用是计算出扩容后新数组的长度，若大于整型的最大值则抛出<code>OutOfMemoryError</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7235628080219488293&quot;&gt;从零开始学Java之StringBuilder与StringBuffer使用及源码解读&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;String为什么设计为不可变？如何保证Stri</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android中的Service</title>
    <link href="http://princesaoke.github.io/2024/06/09/Android%E4%B8%AD%E7%9A%84Service/"/>
    <id>http://princesaoke.github.io/2024/06/09/Android%E4%B8%AD%E7%9A%84Service/</id>
    <published>2024-06-09T09:21:24.000Z</published>
    <updated>2024-06-11T01:00:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio 中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android Studio 中&lt;/p&gt;
</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和协程</title>
    <link href="http://princesaoke.github.io/2024/06/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <id>http://princesaoke.github.io/2024/06/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</id>
    <published>2024-06-07T09:34:04.000Z</published>
    <updated>2025-12-21T07:02:51.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>并发就是同一时刻只有一条指令在执行，但由于CPU时间片很小，多个指令间能快速切换，宏观上形成同时执行的效果。</p><p>并行则是真正意义上的同时进行。</p><h1 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h1><ul><li>原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行</li><li>可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</li><li>有序性：程序执行的顺序按照代码的先后顺序执行</li></ul><h1 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h1><ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li>一个进程可以有多个线程，至少有一个主线程</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响；但一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ul><p>Q：为什么进程切换的消耗比线程切换大？</p><p>A：</p><blockquote><p>进程拥有独立的内存空间和资源管理机制，每次切换时需要保存和恢复更多的上下文信息；<br>而线程共享同一进程的内存和大部分资源，切换时涉及的上下文信息较少。<br>且进程切换更多发生在内核态，而同一进程内的线程切换更多发生在用户态，因此开销相对较小。</p></blockquote><h1 id="多进程和多线程分别有何优势？"><a href="#多进程和多线程分别有何优势？" class="headerlink" title="多进程和多线程分别有何优势？"></a>多进程和多线程分别有何优势？</h1><ul><li>线程之间可以更轻松的共享数据</li><li>系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小</li><li>线程崩溃可能导致整个进程崩溃，而进程崩溃不会影响到另一个进程</li></ul><h1 id="哪些是线程共享的？"><a href="#哪些是线程共享的？" class="headerlink" title="哪些是线程共享的？"></a>哪些是线程共享的？</h1><p>线程共享：</p><ul><li>全局变量和堆</li><li>文件描述符，包括打开的文件、网络连接、输入输出流等，这些都是进程级别的资源</li></ul><p>Q：Java三种创建线程的方法有什么区别？</p><p>A：</p><blockquote><p>……</p></blockquote><h1 id="Java中锁的类型"><a href="#Java中锁的类型" class="headerlink" title="Java中锁的类型"></a>Java中锁的类型</h1><ul><li><strong>悲观锁</strong>、<strong>乐观锁</strong>：悲观锁总是认为其他线程会修改数据，因此每次操作都上锁，如<code>synchronized</code>；乐观锁则假设其他线程不会修改数据，不上锁，如<code>CAS</code></li><li><strong>公平锁</strong>、<strong>非公平锁</strong>：公平锁按申请锁的顺序获取，如<code>ReentrantLock</code>；非公平锁不保证顺序</li><li><strong>自旋锁</strong>：线程循环等待直到获取锁</li><li><strong>可重入锁</strong>、<strong>不可重入锁</strong>：可重入锁允许内层使用锁，不会产生死锁；不可重入锁不允许</li><li><strong>共享锁&#x2F;读锁</strong>、<strong>独享锁&#x2F;写锁</strong>：共享锁允许多个执行单元同时获取锁，独享锁只允许一个</li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><a href="https://blog.csdn.net/u013541140/article/details/95225769">Java 多线程：彻底搞懂线程池</a></p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/diagram.png" alt="继承关系"></p><p><code>ThreadPoolExecutor</code>的参数：</p><table><thead><tr><th align="center">参数名</th><th align="center">是否必需</th><th align="center">数据类型</th><th><center>说明</center></th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">必需</td><td align="center">int</td><td>线程池的核心线程数</td></tr><tr><td align="center">maximumPoolSize</td><td align="center">必需</td><td align="center">int</td><td>线程池的最大线程数</td></tr><tr><td align="center">keepAliveTime</td><td align="center">必需</td><td align="center">long</td><td>当线程数大于核心线程数时，多余的空闲线程存活的最长时间</td></tr><tr><td align="center">unit</td><td align="center">必需</td><td align="center">TimeUnit</td><td>keepAliveTime的时间单位</td></tr><tr><td align="center">workQueue</td><td align="center">必需</td><td align="center">BlockingQueue&lt;Runnable&gt;</td><td>决定线程池的任务队列的类型</td></tr><tr><td align="center">threadFactory</td><td align="center">可选</td><td align="center">ThreadFactory</td><td>用于指定为线程池创建新线程的方式</td></tr><tr><td align="center">handler</td><td align="center">可选</td><td align="center">RejectedExecutionHandler</td><td>拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</td></tr></tbody></table><p><img src="/images/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/step.png" alt="线程池工作流程图"></p><p>几种常见的内置线程池</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和并行&quot;&gt;&lt;/a&gt;并发和并行&lt;/h1&gt;&lt;p&gt;并发就是同一时刻只有一条指令在执行，但由于CPU时间片很小，多个指令间能快速切换，宏观上形成同时执行的效果。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
