<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骚客.的个人博客</title>
  
  <subtitle>记录我的学习过程</subtitle>
  <link href="http://princesaoke.github.io/atom.xml" rel="self"/>
  
  <link href="http://princesaoke.github.io/"/>
  <updated>2024-10-20T07:17:57.325Z</updated>
  <id>http://princesaoke.github.io/</id>
  
  <author>
    <name>骚客.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虾皮秋招面经</title>
    <link href="http://princesaoke.github.io/2024/10/20/%E8%99%BE%E7%9A%AE%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/10/20/%E8%99%BE%E7%9A%AE%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-10-20T06:49:45.000Z</published>
    <updated>2024-10-20T07:17:57.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面-10-19-ShopeePay"><a href="#一面-10-19-ShopeePay" class="headerlink" title="一面 10.19 ShopeePay"></a>一面 10.19 ShopeePay</h2><ul><li><span style="color: green">✔</span> 编程题：删除单向链表倒数第n个节点</li><li><span style="color: green">✔</span> Flutter和其他跨平台框架有什么区别？</li><li><span style="color: red">❌</span> AtomaticInteger是如何实现的？</li><li><span style="color: red">❌</span> getStorage持久化存储在本地的文件格式是什么样的？怎么从磁盘中读取的？</li><li><span style="color: green">✔</span> 在主线程中进行IO操作可能出现什么问题（ANR）？在子线程中操作会有吗？</li><li><span style="color: green">✔</span> MMKV和SharedPreferences的区别</li><li><span style="color: red">❌</span> 用protobuf数据协议和SharedPreference的区别</li><li><span style="color: green">✔</span> HTTP协议的常见响应码</li><li><span style="color: green">✔</span> HTTP三个版本之间的区别</li><li><span style="color: red">❌</span> Android中跨进程通信的几种方法，几种方法之间的区别（binder和消息队列）</li><li><span style="color: green">✔</span> MQTT基于TCP还是UDP，MQTT的优势</li><li><span style="color: red">❌</span> 用TCP可以做推送吗？还有哪些协议可以推送？</li><li><span style="color: red">❌</span> 图片加载器用过哪些？Image.network源码看过吗？</li><li><span style="color: green">✔</span> Android中的数据库如何使用？</li><li><span style="color: green">✔</span> HashMap和ConcurrentHashMap的区别</li><li><span style="color: red">❌</span> HashMap和LinkedHashMap的区别</li><li><span style="color: green">✔</span> 多线程同时访问HashMap可能会发生什么问题？</li><li><span style="color: green">✔</span> Java中sleep()和wait()的区别</li><li><span style="color: green">✔</span> 悲观锁和乐观锁</li><li><span style="color: green">✔</span> 项目中用拦截器做了什么</li><li><span style="color: red">❌</span> 自己的项目中token有几级，多久过期</li><li><span style="color: green">✔</span> 项目中的基于拓展方法做屏幕适配</li><li><span style="color: green">✔</span> HTTPS加密过程，为什么要混合加密</li><li><span style="color: red">❌</span> 如何知道服务器发来的证书是合法的？</li></ul><p>反问，可以再加强算法数据结构、网络、操作系统，一些常问的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面-10-19-ShopeePay&quot;&gt;&lt;a href=&quot;#一面-10-19-ShopeePay&quot; class=&quot;headerlink&quot; title=&quot;一面 10.19 ShopeePay&quot;&gt;&lt;/a&gt;一面 10.19 ShopeePay&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里淘天秋招面经</title>
    <link href="http://princesaoke.github.io/2024/10/20/%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/10/20/%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-10-20T06:20:16.000Z</published>
    <updated>2024-10-20T06:39:28.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面-10-17-1688部门"><a href="#一面-10-17-1688部门" class="headerlink" title="一面 10.17 1688部门"></a>一面 10.17 1688部门</h2><p>45分钟左右。</p><ul><li><span style="color: green">✔</span> Android和Flutter的区别</li><li><span style="color: green">✔</span> 编程题：用数组实现栈</li><li><span style="color: green">✔</span> 编程题：两个线程交替打印</li><li><span style="color: green">✔</span> Java中锁的类型</li><li><span style="color: red">❌</span> AtomaticInteger是如何实现的？</li><li><span style="color: green">✔</span> 如何自定义View</li><li><span style="color: green">✔</span> 如何用RecyclerView实现一个数据列表？有哪些关键方法？</li><li><span style="color: red">❌</span> 如何用RecyclerView实现每个列表项不一样的布局？RecyclerView的源码看过吗</li><li><span style="color: green">✔</span> 如何用RecyclerView实现一个数据列表？有哪些关键方法？</li><li><span style="color: red">❌</span> 下载器断点续传、并发下载如何实现？</li></ul><p>最后反问觉得哪块比较薄弱，面试官说都还好，许愿过。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面-10-17-1688部门&quot;&gt;&lt;a href=&quot;#一面-10-17-1688部门&quot; class=&quot;headerlink&quot; title=&quot;一面 10.17 1688部门&quot;&gt;&lt;/a&gt;一面 10.17 1688部门&lt;/h2&gt;&lt;p&gt;45分钟左右。&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Android中的View</title>
    <link href="http://princesaoke.github.io/2024/10/17/Android%E4%B8%AD%E7%9A%84View/"/>
    <id>http://princesaoke.github.io/2024/10/17/Android%E4%B8%AD%E7%9A%84View/</id>
    <published>2024-10-16T16:37:03.000Z</published>
    <updated>2024-10-16T19:23:22.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/7f635283067e">Android自定义View的基石——View工作原理总结</a></p><p><a href="https://www.jianshu.com/p/b6437e4b81ac">Android中View的更新方法：invalidate()和requestLayout()</a></p><h2 id="Activity创建View"><a href="#Activity创建View" class="headerlink" title="Activity创建View"></a>Activity创建View</h2><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/view_level.png" alt="视图层级"></p><p>DecorView下是一个竖直方向的LinearLayout，包含一个id为<code>android.R.id.content</code>的子View，在Activity的<code>onCreate()</code>中调用<code>setContentView()</code>就是设置这个contentView。</p><p>Activity的<code>onCreate()</code>方法调用之前，创建Window（PhoneWindow）<br>Activity的onCreate方法中调用<code>setContentView()</code>方法，创建<code>DecorView</code>和<code>contentView</code>，将指定的布局文件加载到contentView中<br>Activity的onResume方法调用之后，将DecorView添加到Window中，之后依次开始View的measure、layout和draw流程</p><h2 id="三大流程"><a href="#三大流程" class="headerlink" title="三大流程"></a>三大流程</h2><p><code>performTraversals()</code>方法内会依次调用<code>measureHierarchy()</code>、<code>performLayout()</code>、<code>performDraw()</code>，进而开始View的三大流程：测量measure、布局layout、绘制draw</p><h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>measure流程的作用是对View的大小进行测量。</p><p><code>MeasureSpec</code>类，由一个32位int值表示，高2位表示SpecMode（测量模式），低30位表示SpecSize（测量尺寸大小），通过位运算实现。</p><p>三种测量模式：</p><ul><li>UNSPECIFIED：父View不会限制子View的大小，一般用于系统内部，开发中使用很少</li><li>EXACTLY：父View能够确定子View的大小，如<code>match_parent</code>或给定精确尺寸（dp或px）</li><li>AT_MOST：子View的大小不能超过父View尺寸，具体尺寸需要由子View自身来确定，对应<code>wrap_content</code></li></ul><p>确定View尺寸的方法：</p><ul><li>当子View的LayoutParams指定为精确数值时，不管父View的测量模式是什么，子View的测量模式均为EXACTLY，测量尺寸为LayoutParams指定的值</li><li>当子View的LayoutParams指定为match_parent时，子View的测量模式取决于父View，即如果父View的测量模式为EXACTLY，那么子View的测量模式为EXACTLY；如果父View的测量模式为AT_MOST，那么子View的测量模式为AT_MOST，子View的测量尺寸均为父View可用空间大小</li><li>当子View的LayoutParams指定为wrap_content时，不管父View的测量模式是什么，子View的测量模式均为AT_MOST，测量尺寸为父View可用空间大小</li></ul><p>对于最顶层的DecorView：</p><ul><li>DecorView的LayoutParams指定为MATCH_PARENT时，它的测量模式为EXACTLY，测量尺寸为屏幕尺寸</li><li>DecorView的LayoutParams指定为WRAP_CONTENT时，它的测量模式为WRAP_CONTENT，测量尺寸为屏幕尺寸</li></ul><p>View的measure流程：</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/measure_view.png" alt="View的measure流程"></p><p>ViewGroup的measure流程：</p><p>ViewGroup中并没有重写onMeasure()方法，因为每个ViewGroup的布局方式都不一样，无法得出一个统一的实现方式，需要不同ViewGroup自己去实现。</p><p>遍历子View，获取每个子View的MeasureSpec，然后调用每个子View的measure()方法进行测量。再根据子View的测量结果对ViewGroup自身进行测量。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/measure_view_group.png" alt="ViewGroup的measure流程"></p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>layout的作用是根据测量大小确定View的最终位置。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/layout.png" alt="layout坐标系"></p><p><code>layout()</code>方法中比较left、right、top、bottom是否改变，若改变则执行<code>onLayout()</code>。对于单一的View，onLayout()中不做任何事。对于ViewGroup，调用抽象的onLayout()方法（同样需要子类自己去实现），遍历子View并调用其layout()方法确定位置，不断递归。</p><h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><p>draw的作用是将View绘制到屏幕上。</p><ul><li>调用drawBackground()方法绘制背景</li><li>调用onDraw()方法绘制自身内容</li><li>调用dispatchDraw()方法绘制子View</li><li>调用onDrawForeground()方法绘制装饰，包括滚动条和前景</li></ul><p>其中onDraw()是抽象方法，需要不同的View自己去实现绘制方式。</p><p>在单一的View中dispatchDraw()是空方法，ViewGroup则实现了其逻辑，遍历所有的子View并调用其draw()方法。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84View/draw.png" alt="draw流程"></p><h2 id="invalidate、postInvalidate-与-requestLayout"><a href="#invalidate、postInvalidate-与-requestLayout" class="headerlink" title="invalidate、postInvalidate 与 requestLayout"></a>invalidate、postInvalidate 与 requestLayout</h2><p>三者都是View中的方法，用于刷新视图，最终都会调用<code>ViewRootImpl</code>的<code>performTraversals()</code>方法。</p><ul><li>invalidate不会执行<code>measure</code>和<code>layout</code>流程，只执行<code>draw</code>流程。</li><li>invalidate与requestLayout都必须在主线程调用，要在子线程中刷新视图用<code>postInvalidate</code>方法</li></ul><p>调用<code>View</code>的<code>invalidate()</code>方法后会逐级调用父View的方法，最终导致<code>ViewRootImpl</code>的<code>scheduleTraversals()</code>方法被调用，进而调用<code>performTraversals()</code>方法。由于<code>mLayoutRequested</code>的值为<code>false</code>，因此不会执行<code>measure</code>和<code>layout</code>流程，只执行<code>draw</code>流程。</p><p>draw流程的执行过程和是否开启硬件加速有关。如果关闭了硬件加速，从<code>DecorView</code>开始的所有View都会重新完成绘制。如果开启了硬件加速，只有调用<code>invalidate()</code>方法的View（包括它的子View）会完成重新绘制。由此也可以看出，开启硬件加速确实可以提高重绘的效率。</p><p><code>postInvalidate</code>其实就是通过Handler完成了线程的切换，使得invalidate()方法在主线程中被调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7f635283067e&quot;&gt;Android自定义View的基石——View工作原理总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b6437e4b81ac</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>美团客户端秋招面经</title>
    <link href="http://princesaoke.github.io/2024/09/29/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/09/29/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-09-29T04:03:22.000Z</published>
    <updated>2024-10-16T15:28:48.250Z</updated>
    
    <content type="html"><![CDATA[<p>和暑期实习一样的岗位。</p><p><a href="https://princesaoke.github.io/2024/04/28/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/">美团客户端实习面经</a></p><h2 id="笔试-9-21"><a href="#笔试-9-21" class="headerlink" title="笔试 9.21"></a>笔试 9.21</h2><p>和暑期实习一样，两个小时。30道选择题，共60分；2道编程题，共40分。</p><p>前端岗位和客户端岗位考的是同一场，选择题考了挺多JavaScript，还有一些CSS</p><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ul><li>JS的Promise，then的执行顺序，事件循环相关</li><li>CSS属性，计算元素宽度</li><li>死锁的必要条件</li><li>面向对象特性</li><li>TCP传输相关</li><li>const let var</li><li>创建型设计模式</li><li>单例</li><li>编译原理相关，文法推导</li><li>数据结构相关，完全二叉树的节点个数范围，堆最多和最少的节点数</li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><p>第一题比较简单，AC，题目大致是：</p><p>每次在数组中的任意下标那一格涂色，若某个范围内涂色数量大于未涂色数量，则下一次可以把该范围全部涂色。问：给出数组的长度，至少要多少次才能全部涂色？</p><p>最快的情况当然是迅速按范围涂色，由于是要大于才能把范围全部涂色，因此前三次涂色都是每次涂一格。第四次涂色，最多能涂小于3的最大值即2个，第五次能涂小于5的最大值即4个，数列就是：<code>1，2，3，5，9，17……</code>。从2开始，<code>n + 1 = 2 * n - 1</code>。</p><p>第二题：</p><p><img src="/images/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/q2.png" alt="编程题第二题"></p><p><img src="/images/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/test_data.png" alt="测试数据"></p><p>做的时候已经有思路了，但是时间来不及细细斟酌代码了。</p><p>一个长度为m的数组，每个格子中是一个链表，所有标签相同的物品都放在同一格中。这里需要遍历一次物品标签。</p><p>一个长度为m的数组match用于保存该位置的标签应该贴在哪个物品上。记标签匹配为good，不匹配为bad。对于一个链表中标签相同的物品，计算最高美观值的步骤：先把所有bad的美观值累加，要得出不同标签匹配的情况的美观值，只要把<code>bad累加 - 自己的bad值 + 自己的good值</code>，再用打擂台的方法得到美观值最高的贴法，对应贴的序号填入数组match。</p><p>知道每个出现的标签应该贴在哪，剩下就简单了。遍历物品，只要判断match中贴的不是自己，如果是，在合计中加上good值，不是就加上bad值。</p><h2 id="一面-9-27-核心本地商业-美团平台"><a href="#一面-9-27-核心本地商业-美团平台" class="headerlink" title="一面 9.27 核心本地商业-美团平台"></a>一面 9.27 核心本地商业-美团平台</h2><p>一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍？学习过哪些编程语言？通过什么方式？打算从事哪些技术栈？</li><li><span style="color: red">❌</span> 批量下载用Android怎么实现？线程池有了解吗？</li><li><span style="color: green">✔</span> 简单介绍MQTT</li><li><span style="color: red">❌</span> MQTT和HTTP底层有什么区别？如何用Android写一个推送？</li><li><span style="color: green">✔</span> 如何解决Flutter组件多层嵌套的问题？</li><li><span style="color: green">✔</span> 如何防止XSS攻击？</li><li><span style="color: green">✔</span> 数据库如何存储密码？MD5如何校验密码？哈希算法如何保证密码不被知晓？彩虹表破解？</li><li><span style="color: green">✔</span> JSON数据的value可以有哪些数据类型？</li><li><span style="color: green">✔</span> 链表和数组的区别？</li><li><span style="color: green">✔</span> 面向对象三大特性，分别讲一下</li><li><span style="color: green">✔</span> 静态变量和非静态变量的区别？静态变量什么时候分配内存的？</li><li><span style="color: red">❌</span> 什么是内存泄漏？如何排查？例举Android中常见的内存泄漏？</li><li><span style="color: green">✔</span> 发送HTTP请求时要填哪些参数？请求头、请求方法、响应字段</li><li><span style="color: green">✔</span> HTTP、TCP分别是哪一层的协议</li><li><span style="color: green">✔</span> HTTPS为什么安全？SSL的过程</li><li><span style="color: red">❌</span> 客户端如何判断服务端的证书是合法的？客户端如何知道证书被中间人篡改了？</li><li><span style="color: green">✔</span> TCP三次握手过程，为什么要三次？</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: red">❌</span> 两个线程如何通信？Android子线程与主线程的通信，子线程如何通知主线程刷新UI</li><li><span style="color: red">❌</span> 进程间如何通信？用代码如何实现？</li><li><span style="color: green">✔</span> 编程题：合并两个有序链表</li><li><span style="color: red">❌</span> 编程题：代码实现死锁</li><li><span style="color: green">✔</span> 同步和异步的区别</li></ul><p>问的还算简单，结尾直接约了二面在当天。不过二面面试官没空，推到第三天了。激动</p><h2 id="二面-9-29-核心本地商业-美团平台"><a href="#二面-9-29-核心本地商业-美团平台" class="headerlink" title="二面 9.29 核心本地商业-美团平台"></a>二面 9.29 核心本地商业-美团平台</h2><p>40分钟左右。</p><ul><li><span style="color: green">✔</span> 有什么想补充的？打算做哪方面技术栈？</li><li><span style="color: green">✔</span> Flutter的优点</li><li><span style="color: red">❌</span> 结合底层机制、编译原理、程序运行，Flutter是如何从Dart源码到应用程序并运行的？</li><li><span style="color: red">❌</span> 结合Flutter和前端在布局渲染方面的共同点，界面是如何渲染显示的？canvas相关</li><li><span style="color: red">❌</span> 结合编译原理，非页面的代码，业务逻辑代码是怎么运行的？如发一个网络请求。源码如何在设备上运行起来？Dart语言的编译流程？</li><li><span style="color: green">✔</span> Java的编译流程？JVM起到什么作用？</li><li><span style="color: green">✔</span> 为了让程序运行，JVM需要做什么事？</li><li><span style="color: green">✔</span> 用C语言和Java的区别？</li><li><span style="color: green">✔</span> 面向过程和面向对象各自的特点</li><li><span style="color: green">✔</span> 学习了哪些专业课程？在实际开发中用到了哪些？</li><li><span style="color: green">✔</span> 在业务开发中不同的网络协议如何做选择？</li><li><span style="color: green">✔</span> 数据结构与算法在实际开发中的应用？有哪些常用的数据结构</li><li><span style="color: green">✔</span> 数据超出数组长度如何处理？如何扩容？</li></ul><p>感觉面试官很想问我dart和Flutter底层的运行原理，可惜确实不了解。</p><p>9.30已挂。差点以为好运来了，呜呜呜</p><h2 id="一面-10-11-软硬件服务-骑行事业部"><a href="#一面-10-11-软硬件服务-骑行事业部" class="headerlink" title="一面 10.11 软硬件服务-骑行事业部"></a>一面 10.11 软硬件服务-骑行事业部</h2><p>被捞了。一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍，介绍项目、实习</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: green">✔</span> Java中的几种锁</li><li><span style="color: green">✔</span> 进程通信的几种方式</li><li><span style="color: green">✔</span> 对象锁和类锁的区别</li><li><span style="color: green">✔</span> OSI七层网络模型，传输层的协议</li><li><span style="color: green">✔</span> TCP和UDP的区别</li><li><span style="color: green">✔</span> HTTP基于哪个传输层协议，有哪些版本，3.0基于TCP还是UDP，各版本的区别</li><li><span style="color: green">✔</span> HTTPS加密过程，为什么要混合加密？</li><li><span style="color: green">✔</span> 四种引用方式与区别</li><li><span style="color: red">❌</span> 软弱虚引用的使用场景</li><li><span style="color: green">✔</span> 浅拷贝和深拷贝</li><li><span style="color: green">✔</span> HashMap原理，链表和红黑树转换的阈值，ConcurrentHashMap如何保证线程安全</li><li><span style="color: red">❌</span> Java8前后的ConcurrentHashMap实现方式的区别</li><li><span style="color: green">✔</span> volatile关键字的作用</li><li><span style="color: green">✔</span> Java中类的加载机制</li><li><span style="color: red">❌</span> 类加载器有哪几种</li><li><span style="color: red">❌</span> Android中的handler消息机制</li><li><span style="color: red">❌</span> 四大组件的作用</li><li><span style="color: red">❌</span> Activity、Service、BroadcastReceiver什么情况下会出现ANR</li><li><span style="color: green">✔</span> Activity的启动模式</li><li><span style="color: red">❌</span> ListView和RecyclerView的区别</li><li><span style="color: green">✔</span> RecyclerView四级缓存机制</li><li><span style="color: red">❌</span> 如何计算和屏幕一样大小的图片的占用内存</li><li><span style="color: red">❌</span> Android的事件分发机制</li><li><span style="color: green">✔</span> 编程题：分层输出二叉树的层序遍历</li></ul><p>开头问了一下实习，可能是觉得没什么好聊的，转而问八股了。之前面美团基本只问了八股没怎么问Android，这次一问，好多都没答上来。</p><p>最后手撕环节，层序遍历用队列一气呵成写完，面试官要求分层输出，和刚刚的小黑盒一面的代码题一模一样，但是没有去看。看的出来面试官很想让我过，一直在提示我，但是始终没有get到点，好在最后用自己的方法也是做出来了，被自己蠢哭。</p><p>反问的时候问了面试官自己有哪些薄弱点，面试官说我Android相关的需要再更深入了解，手撕代码有待加强。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和暑期实习一样的岗位。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://princesaoke.github.io/2024/04/28/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://princesaoke.github.io/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://princesaoke.github.io/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2024-09-27T01:23:39.000Z</published>
    <updated>2024-10-10T17:00:27.904Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/512400553025003520">一文吃透TCP面试八股文</a></p><p><a href="https://cloud.tencent.com/developer/article/1662002">TCP&#x2F;IP协议之传输层：TCP&#x2F;UDP协议详解（一）</a></p><p><a href="https://blog.csdn.net/qq_38289815/article/details/80969419">HTTP 和 HTTPS 的区别（面试常考题）</a></p><p><a href="https://zhuanlan.zhihu.com/p/275695831">http请求中get和post方法的区别</a></p><p><strong>TCP</strong>，全称<code>Transport Controll Protocol</code>，传输控制协议。</p><p><strong>UDP</strong>，全称<code>User Data Protocol</code>，用户数据报协议。</p><h2 id="OSI七层网络模型、TCP-IP四层模型、TCP-IP五层模型"><a href="#OSI七层网络模型、TCP-IP四层模型、TCP-IP五层模型" class="headerlink" title="OSI七层网络模型、TCP&#x2F;IP四层模型、TCP&#x2F;IP五层模型"></a>OSI七层网络模型、TCP&#x2F;IP四层模型、TCP&#x2F;IP五层模型</h2><p><strong>OSI七层网络模型</strong>：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><p><strong>TCP&#x2F;IP四层模型</strong>：应用层、传输层、网络层、网络接口层</p><p><strong>TCP&#x2F;IP五层模型</strong>：应用层、传输层、网络层、数据链路层、物理层</p><h2 id="TCP、UDP位于哪一层"><a href="#TCP、UDP位于哪一层" class="headerlink" title="TCP、UDP位于哪一层"></a>TCP、UDP位于哪一层</h2><p>二者都是传输层协议。</p><h2 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h2><ul><li>TCP是面向连接的，UDP是无连接的</li><li>TCP是可靠的，UDP是不可靠的</li><li>TCP有拥塞控制机制，UDP没有</li><li>TCP是面向字节流的，UDP是面向数据报文的</li><li>TCP只支持点对点通信，UDP支持一对一，一对多，多对多</li><li>TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区</li><li>TCP报文首部不同，TCP首部20个字节，UDP首部8个字节</li></ul><h2 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h2><ul><li>数据包校验防止发送过来的数据是错误数据</li><li>确认序列号，对失序报文进行重排</li><li>丢弃重复数据包，防止数据冗余重复</li><li>确认应答机制，接收方接受数据之后会发送一个确认</li><li>超时重传机制，发送方发出数据后会启动一个定时器，超过该定时器时间依旧未收到对方确认，便会重新发送该数据</li><li>流量控制确保接收方收到的数据在自身缓冲区中不会溢出</li><li>拥塞控制，保证数据在网络中传播的可靠性，降低丢包的概率，提高TCP的可靠性</li></ul><h2 id="TCP-和-UDP-各自的适用场景"><a href="#TCP-和-UDP-各自的适用场景" class="headerlink" title="TCP 和 UDP 各自的适用场景"></a>TCP 和 UDP 各自的适用场景</h2><p>对实时性要求比较高，且允许数据丢失的情况，选择UDP，比如实时视频通话、游戏。</p><p>不允许数据丢失，及大多数情况适用TCP。</p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>UDP报文：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/udp.png" alt="UDP报文"></p><p>TCP报文：</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp.png" alt="TCP报文"></p><h2 id="TCP-和-UDP-分别对应的常见应用层协议"><a href="#TCP-和-UDP-分别对应的常见应用层协议" class="headerlink" title="TCP 和 UDP 分别对应的常见应用层协议"></a>TCP 和 UDP 分别对应的常见应用层协议</h2><p>基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH</p><p>基于UDP的应用层协议：DNS、TFTP、SNMP</p><h2 id="HTTP1-0-和-HTTP2-0-的区别"><a href="#HTTP1-0-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.0 和 HTTP2.0 的区别"></a>HTTP1.0 和 HTTP2.0 的区别</h2><ul><li>长连接，<code>Connection: Keep-Alive</code>，以便其他请求复用，只要任意一端没有明确提出断开连接，则保持TCP连接状态</li><li>多路复用</li><li>HTTP1.0 基于文本格式，而 HTTP2.0 基于二进制格式</li><li>头部压缩</li></ul><h2 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h2><ul><li>HTTP是明文传输，HTTPS使用SSL加密传输</li><li>HTTP在三次握手后即可传输报文，而HTTPS三次握手后还要进行SSL握手</li><li>HTTP端口是80，HTTPS端口是443</li></ul><p>SSL通过先<strong>非对称加密</strong>的方式传输密钥，再用密钥对传输数据进行<strong>对称加密</strong>，来解决窃听风险。之所以要两种加密方式混用，是因为对称加密比非对称加密要快，因此数据传输使用对称加密，而非对称加密可以实现交换密钥。</p><p>发送端通过哈希算法为数据生成指纹，与数据一同发送。接收端计算出哈希值，与发送端的哈希值对比校验完整性，解决篡改的风险。</p><p>将服务器公钥放入数字证书中，解决冒充的风险。发送端用私钥对数字签名加密，由于中间人无法得知私钥，因此无法伪造数据，接收端能用公钥解密则说明消息合法。</p><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ul><li>GET用于获取资源、读取数据；POST用于修改和写入数据</li><li>GET把参数包含在URL中，POST通过request body传递参数，因此POST能发送的数据更大，GET有URL长度限制</li><li>POST多几个首部字段，如content-type，POST能发送更多数据类型，GET只能发送ASCII字符</li><li>GET会将静态资源缓存起来，POST不会，因此POST更安全</li><li>POST在真正接收数据之前会先将请求头发送给服务器进行确认，服务器返回100 Continue响应，然后才真正发送数据，因此GET比POST快</li></ul><h2 id="常见请求头和响应头"><a href="#常见请求头和响应头" class="headerlink" title="常见请求头和响应头"></a>常见请求头和响应头</h2><table><thead><tr><th align="center">请求头</th><th align="left"><center>说明</center></th><th align="left"><center>示例</center></th></tr></thead><tbody><tr><td align="center">Accept</td><td align="left">指示客户端可以接受的内容类型，例如text&#x2F;html，application&#x2F;json等</td><td align="left"></td></tr><tr><td align="center">Accept-Charset</td><td align="left">可接受的字符编码类型</td><td align="left">Accept-Charset: utf-8</td></tr><tr><td align="center">Connection</td><td align="left">客户端（浏览器）想要优先使用的连接类型</td><td align="left">Connection: keep-alive</td></tr><tr><td align="center">Cookie</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">Content-Length</td><td align="left">以8进制表示的请求体的长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="center">Content-Type</td><td align="left"></td><td align="left">Content-Type: application&#x2F;x-www-form-urlencoded</td></tr><tr><td align="center">Host</td><td align="left">服务器的域名以及服务器所监听的端口号</td><td align="left">Host: <a href="http://www.baidu.com/">www.baidu.com:80</a></td></tr><tr><td align="center">User-Agent</td><td align="left">浏览器的身份标识字符串</td><td align="left">User-Agent: Mozilla</td></tr></tbody></table><table><thead><tr><th align="center">响应头</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="center">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以跨域源资源共享</td><td align="left">Access-Control-Allow-Origin: *</td></tr><tr><td align="center">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left">Content-Length: 348</td></tr><tr><td align="center">Date</td><td align="left">此条消息被发送时的日期和时间</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td align="center">Last-Modified</td><td align="left">所请求的对象的最后修改日期</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td></tr><tr><td align="center">Set-Cookie</td><td align="left">用于在客户端设置 Cookie，通常用于会话管理或跟踪用户状态</td><td align="left"></td></tr></tbody></table><h2 id="FTP-和-SFTP-的区别"><a href="#FTP-和-SFTP-的区别" class="headerlink" title="FTP 和 SFTP 的区别"></a>FTP 和 SFTP 的区别</h2><p><strong>FTP</strong>，File Transfer Protocol，文件传输协议</p><p><strong>SFTP</strong>，Secure File Transfer Protocol，安全文件传输协议</p><ul><li>SFTP通过提供加密的连接和安全的数据传输来提高安全性，而FTP的安全性较低</li><li>FTP使用TCP&#x2F;IP协议，而SFTP是SSH协议的一部分</li><li>FTP使用21端口，而SFTP通过SSH协议的22端口</li></ul><h2 id="MQTT-和-HTTP-的区别"><a href="#MQTT-和-HTTP-的区别" class="headerlink" title="MQTT 和 HTTP 的区别"></a>MQTT 和 HTTP 的区别</h2><ul><li>MQTT以数据为中心，而HTTP是以文档为中心的</li><li>MQTT生成的消息大小较小，因为它使用二进制格式。HTTP生成的消息大小更大，因为它使用ASCII格式</li><li>MQTT是轻量级和发布&#x2F;订阅模型，HTTP是基于请求&#x2F;响应模型</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/512400553025003520&quot;&gt;一文吃透TCP面试八股文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/articl</summary>
      
    
    
    
    <category term="计网" scheme="http://princesaoke.github.io/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>字节跳动Android秋招面经</title>
    <link href="http://princesaoke.github.io/2024/09/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/09/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-09-24T14:59:43.000Z</published>
    <updated>2024-10-09T09:06:03.161Z</updated>
    
    <content type="html"><![CDATA[<p>无笔试，直接约一面。飞书部门。</p><h2 id="一面-9-24"><a href="#一面-9-24" class="headerlink" title="一面 9.24"></a>一面 9.24</h2><p>一小时左右。</p><ul><li><span style="color: green">✔</span> 自我介绍</li><li><span style="color: green">✔</span> 谈实习，说一下难点和解决方法</li><li><span style="color: red">❌</span> flutter或Android中的手势消费原理</li><li><span style="color: red">❌</span> flutter是如何生成一个安卓应用的</li><li><span style="color: green">✔</span> flutter渲染原理，三棵树</li><li><span style="color: red">❌</span> flutter的桥，调用native能力，如调用相机</li><li><span style="color: green">✔</span> 线程和进程的区别</li><li><span style="color: red">❌</span> 多线程相关，线程间哪些是共享的？进程间哪些是共享的？</li><li><span style="color: red">❌</span> 什么是线程安全，如何保证线程安全</li><li><span style="color: green">✔</span> Java的基本数据类型与包装类型有哪些？二者有什么区别？</li><li><span style="color: red">❌</span> 深拷贝和浅拷贝的区别？具体是如何copy的？</li><li><span style="color: green">✔</span> 链表和哈希表的区别，适用场景</li><li><span style="color: green">✔</span> HashMap实现原理，若用对象作为键，修改对象的属性，获取到的值会改变吗</li><li><span style="color: red">❌</span> requestlayout 和 invalidate 的区别</li><li><span style="color: red">❌</span> RecyclerView是如何展示列表数据的？notifyItemChanged局部刷新列表数据，其他局部刷新的方法</li><li><span style="color: green">✔</span> MMKV的使用，相对 SharedPreferences 的优点</li><li><span style="color: red">❌</span> TCP和UDP的区别，TCP的可靠传输是怎么实现的？</li><li><span style="color: red">❌</span> 2G的单词，给100M空间，如何知道出现频率top10的单词？</li><li><span style="color: green">✔</span> flutter对比原生安卓的优劣势</li><li><span style="color: red">❌</span> flutter用的布局模型是什么</li><li><span style="color: red">❌</span> 编程题：输出二叉树的后序遍历（不用递归）</li></ul><p>计网基础还是不熟悉。问了一些安卓相关的也没答上来。</p><p>java在虚拟机中除了线程计数器、jvm栈和方法栈是线程私有的，其余的java堆、方法区、和运行时常量池都是线程共享的内存区域。</p><p>9.25已挂 T^T</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;无笔试，直接约一面。飞书部门。&lt;/p&gt;
&lt;h2 id=&quot;一面-9-24&quot;&gt;&lt;a href=&quot;#一面-9-24&quot; class=&quot;headerlink&quot; title=&quot;一面 9.24&quot;&gt;&lt;/a&gt;一面 9.24&lt;/h2&gt;&lt;p&gt;一小时左右。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span s</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>小红书Android秋招面经</title>
    <link href="http://princesaoke.github.io/2024/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-09-22T09:02:16.000Z</published>
    <updated>2024-09-22T10:42:08.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试-9-22"><a href="#笔试-9-22" class="headerlink" title="笔试 9.22"></a>笔试 9.22</h2><p>20道选择题，共40分；3道编程题，共60分。</p><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ul><li>Android中给View添加点击事件的方法</li><li>URL为<a href="http://xxx.com/user/login.do%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%9F">http://xxx.com/user/login.do，是什么方法的请求？</a></li><li>哪些情况会造成ANR</li><li>不用四大组件中哪个不用Intent启动</li><li>SharedPreferences的文件存储路径，SharedPreferences数据读写方法过程</li><li>银行家算法，判断哪个顺序不会死锁</li><li>合法的出栈顺序</li><li>给出排序的中间状态，判断是哪种排序，归并</li><li>TCP、UDP的特点与区别</li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><p>偏难。</p><p>第一题：给定一个整数数组和一个整数x，将数组分成连续的任意份，要满足每份的乘积都不能是x的倍数，且数组中每个元素都不是x的倍数。问最少需要分多少份？</p><p>有思路，但不知为何只对了18%，小红书的判题器不会给出没通过的测试数据。</p><p>分的要尽可能少，则每一份要尽可能大。由于是连续的，可以从头开始看。当乘积变成x的倍数后，无论之后再乘上什么数都仍是x的倍数，因此当乘积变成倍数时就要分了。</p><p>定义一个curr记录乘积，初始值为数组第一个元素，从第二个元素开始遍历数组。若乘积对x求模不为0，则<code>curr = curr * a[i]</code>；否则，将结果count加一，同时<code>curr = a[i]</code>。遍历结束后，最后一组还要再count加一，输出count。</p><p>第二题：给定收藏夹数n和整数x，接下来n行给出每个收藏夹内所有文章的标签，每个收藏夹内标签的数量可能不同，标签可能重复。现在要找出两个收藏夹，满足二者标签种类刚好为x。有满足则输出YES和收藏夹编号，无满足则输出NO。</p><p>有思路，但只对了83%。</p><p>定义一个<code>vector&lt;vector&lt;string&gt;&gt;</code>用于存储所有收藏夹及其内部的标签。双重循环遍历<code>0 &lt;= i &lt; n - 1)</code>与<code>i + 1 &lt;= j &lt; n</code>，每次循环定义一个集合用于标签去重，将两收藏夹的标签全部加入集合，判断集合大小是否等于x。</p><p>第三题：给出n条直线，接下来n行，每行给出直线斜率k和截距b，k不为0。问x&gt;0的交点有几个？</p><p>没时间写了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔试-9-22&quot;&gt;&lt;a href=&quot;#笔试-9-22&quot; class=&quot;headerlink&quot; title=&quot;笔试 9.22&quot;&gt;&lt;/a&gt;笔试 9.22&lt;/h2&gt;&lt;p&gt;20道选择题，共40分；3道编程题，共60分。&lt;/p&gt;
&lt;h4 id=&quot;选择题&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的HashMap</title>
    <link href="http://princesaoke.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84HashMap/"/>
    <id>http://princesaoke.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84HashMap/</id>
    <published>2024-07-26T15:30:21.000Z</published>
    <updated>2024-08-19T08:52:46.934Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/hollischuang/p/12009172.html">为啥HashMap的默认容量是16？</a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>HashMap</code>用于存储键值对，内部为散列表，每个数组槽位是一个链表或红黑树，即类似<strong>桶排序</strong>的结构。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/hash_map.png" alt="HashMap"></p><p>当调用HashMap的<code>put</code>方法新增键值对时，会根据HashMap类的静态方法<code>hash</code>，用键值对的键来计算出哈希值，并用<code>(散列表大小n - 1) &amp; hash</code>的值作为散列表数组下标，将新增的键值对放入。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/put.png" alt="put"></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/put_val.png" alt="put"></p><p>为解决哈希碰撞，每个散列表数组槽位内是一个链表或红黑树。当链表长度大于8，且散列表数组长度大于等64时，链表转化为红黑树；当红黑树节点小于6时退化成链表。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/threshold.png" alt="阈值"></p><p>来说计算哈希值的<code>hashCode</code>方法。当键不为<code>null</code>时，将键的<code>hashCode</code>方法的值，和自身右移16位的值进行异或，结果作为计算后的哈希值返回。键为空则结果为0。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84HashMap/hash.png" alt="hash"></p><p>再来说说<code>(n - 1) &amp; hash</code>这个式子。其实就等同于hash的值对散列表长度n求模：<code>hash % n</code>。这样能确保计算出的哈希值不会超出散列表下标范围。</p><p>这里使用与运算<code>&amp;</code>而不是模运算，是因为位运算是直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p><p>且：<br>$$ x &#x2F; 2^n &#x3D; x &gt;&gt;&gt; n $$<br>$$ x % 2^n &#x3D; x &amp; (2^n - 1) $$</p><p>当除数是2的n次方时，x除的结果就等于二进制直接右移n位，模的结果就等于x和除数减一的二进制进行与运算。</p><p>例：$ 21 &#x2F; 8 $ 和 $ 21 % 8 $</p><p>21的二进制：10101， 8的二进制：01000， 7的二进制：00111</p><p>$ 21 &#x2F; 8 &#x3D; 21右移三位 &#x3D; 00010 &#x3D; 2 $ ， $ 21 % 8 &#x3D; 21 &amp; 7 &#x3D; 00101 &#x3D; 5 $</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>虽然解决了哈希碰撞的问题，但若散列表太小，键值对太多，频繁出现哈希碰撞，链表或红黑树就会变得很长，此时就需要对散列表扩容。</p><p>前面提到，键值对放在散列表中的哪个位置，是由<code>(散列表大小n - 1) &amp; hash</code>决定的，与散列表大小有关。现在散列表大小改变了，意味着键值对存放的位置可能发生改变，要计算出扩容后所有键值对的新位置。</p><p>JDK1.7 中的做法是每个键值对重新hash映射到新的散列表，在 JDK1.8 进行了改进：</p><p>根据之前的结论，散列表长度必须是 $ 2^n $ ，每次扩容为之前的两倍。这样的好处是，扩容后计算<code>(n - 1) &amp; hash</code>，有变化的只有扩容前的n那一位。</p><p>例：原本散列表长度为8，下标为2处有一键值对，现长度扩容为16</p><p>8-1的二进制为<code>00111</code>，16-1的二进制为<code>01111</code></p><p>则对于<code>(n - 1) &amp; hash</code>，原先的值就是下标2，即<code>00010</code>，说明hash为<code>??010</code>，扩容后的值应该为<code>0?010</code>。</p><p>若<code>?</code>为0，则扩容后位置也不变，无需迁移。若<code>?</code>为1，则扩容后的新位置就是原先的下标加上扩容前的散列表长度。</p><h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul><li>父类不同：HashMap继承抽象类<code>AbstractMap</code>；而Hashtable实现<code>Dictionary</code>类。二者都实现<code>Map</code>接口</li><li>线程安全不同：Hashtable是线程安全的，而HashMap不是</li><li>能否有null：Hashtable中key和value都不允许出现null；而HashMap允许有一个为null的key，value可以有多个null，因此不能用<code>get()</code>返回null来判断HashMap中是否有某个键</li><li>哈希值的使用不同：Hashtable直接使用对象的<code>hashCode</code>；而HashMap重新计算哈希值</li><li>扩容方式不同：HashMap内散列表默认大小为16，扩容后一定为2<sup>n</sup>；Hashtable初始大小为11，扩容方式为<code>old * 2 + 1</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hollischuang/p/12009172.html&quot;&gt;为啥HashMap的默认容量是16？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的static</title>
    <link href="http://princesaoke.github.io/2024/07/21/Java%E4%B8%AD%E7%9A%84static/"/>
    <id>http://princesaoke.github.io/2024/07/21/Java%E4%B8%AD%E7%9A%84static/</id>
    <published>2024-07-20T16:11:09.000Z</published>
    <updated>2024-09-21T08:39:03.034Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">Java中的static关键字解析</a></p><p>静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有<code>this</code>的，因为它不依附于任何对象。既然没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。</p><p>我们最常见的static方法就是main方法，而main方法必须是static的，是因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。</p><p>Java规定static不能用来修饰局部变量。</p><p>与C&#x2F;C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        Person.age = <span class="number">18</span>;    <span class="comment">// 报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q：Java中可以通过<code>this</code>访问静态成员变量吗？下面的代码输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.printValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 该value只是函数内部的局部变量，与this无关</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.value); <span class="comment">// 访问的是静态成员变量value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：可以，输出为<code>0</code>。</p><p>Q：以下代码输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的main函数&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Other</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的静态代码块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的静态代码块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father中的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">Other</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>(<span class="string">&quot;Son&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son中的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son中的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Other</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的构造函数，调用者：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other中的非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Father中的静态代码块1</span><br><span class="line">Father中的静态代码块2</span><br><span class="line">Father中的main函数</span><br><span class="line">Son中的静态代码块</span><br><span class="line">Other中的静态代码块</span><br><span class="line">Other中的非静态代码块</span><br><span class="line">Other中的构造函数，调用者：Father</span><br><span class="line">Father中的非静态代码块</span><br><span class="line">Father中的构造函数</span><br><span class="line">Other中的非静态代码块</span><br><span class="line">Other中的构造函数，调用者：Son</span><br><span class="line">Son中的构造函数</span><br></pre></td></tr></table></figure><p>要运行静态函数main，首先要加载<code>Father</code>类。加载Father类时按顺序执行<code>static</code>块，输出前两行。</p><p>随后执行<code>main</code>函数，输出第三行。</p><p>再实例化<code>Son</code>。实例化前要先加载Son类，又因Son继承Father，则要先加载Father和Son，而Father已经加载了，于是加载Son，执行Son中的static块，输出第四行。</p><p>接着要实例化Son，在构造函数前要先初始化成员变量。因为继承Father所以要先初始化Father，Father有个<code>Other</code>类型的成员变量和一个非static块，按照先后顺序执行，又需要先加载并实例化Other。</p><p>于是加载Other，static块输出第五行。Other的非static块输出第六行，构造函数输出第七行。</p><p>接着Father初始化完成员变量继续按顺序执行非static块，输出第八行。</p><p>现在Son的父类Father成员变量已经初始化，于是Father的构造函数输出第九行。</p><p>Son的父类结束，轮到Son初始化成员变量，非static块每次实例化一个对象都会执行一次，因此Other的非static块再次执行输出第十行。其构造函数再输出第十一行。</p><p>最后Son的构造函数输出最后一行。Son实例化结束，main函数结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3799052.html&quot;&gt;Java中的static关键字解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有&lt;code&gt;this&lt;/c</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记</title>
    <link href="http://princesaoke.github.io/2024/07/10/Flutter%E7%AC%94%E8%AE%B0/"/>
    <id>http://princesaoke.github.io/2024/07/10/Flutter%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-10T01:17:26.000Z</published>
    <updated>2024-07-10T01:29:42.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter与其他跨平台方案的区别"><a href="#Flutter与其他跨平台方案的区别" class="headerlink" title="Flutter与其他跨平台方案的区别"></a>Flutter与其他跨平台方案的区别</h2><p><code>ReactNative</code>之类的框架，只是通过<code>JavaScript</code>虚拟机扩展调用系统组件，由<code>Android</code>和<code>iOS</code>系统进行组件的渲染；<code>Flutter</code>则是自己实现了一套组件渲染的逻辑。</p><p>Flutter的底层图像渲染引擎是<code>Skia</code>（它同时也是Android官方的图像渲染引擎）。Skia 是一款用 C++ 开发的、性能彪悍的 2D 图像绘制引擎，因为其出色的绘制表现被广泛应用在 Chrome 和 Android 等核心产品上。Skia 在图形转换、文字渲染、位图渲染方面都表现卓越，并提供了开发者友好的 API。Skia 已经是 Android 官方的图像渲染引擎了，因此 Flutter Android SDK 无需内嵌 Skia 引擎就可以获得天然的 Skia 支持；而对于 iOS 平台来说，由于 Skia 是跨平台的，因此它作为 Flutter iOS 渲染引擎被嵌入到 Flutter 的 iOS SDK 中，替代了 iOS 闭源的 Core Graphics&#x2F;Core Animation&#x2F;Core Text，这也正是 Flutter iOS SDK 打包的 App 包体积比 Android 要大一些的原因。Skia 保证了同一套代码调用在 Android 和 iOS 平台上的渲染效果是完全一致的。</p><p><img src="/images/Flutter%E7%AC%94%E8%AE%B0/flutter_framework.png" alt="flutter架构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Flutter与其他跨平台方案的区别&quot;&gt;&lt;a href=&quot;#Flutter与其他跨平台方案的区别&quot; class=&quot;headerlink&quot; title=&quot;Flutter与其他跨平台方案的区别&quot;&gt;&lt;/a&gt;Flutter与其他跨平台方案的区别&lt;/h2&gt;&lt;p&gt;&lt;code&gt;</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Flutter" scheme="http://princesaoke.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Java中的String</title>
    <link href="http://princesaoke.github.io/2024/06/25/Java%E4%B8%AD%E7%9A%84String/"/>
    <id>http://princesaoke.github.io/2024/06/25/Java%E4%B8%AD%E7%9A%84String/</id>
    <published>2024-06-25T15:01:34.000Z</published>
    <updated>2024-07-25T08:38:51.570Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7235628080219488293">从零开始学Java之StringBuilder与StringBuffer使用及源码解读</a></p><h2 id="String为什么设计为不可变？如何保证String不可变？"><a href="#String为什么设计为不可变？如何保证String不可变？" class="headerlink" title="String为什么设计为不可变？如何保证String不可变？"></a>String为什么设计为不可变？如何保证String不可变？</h2><p>一旦一个<code>String</code>对象被创建，其存储的文本内容就不能被改变。这是因为：</p><ul><li>让并发编程变得更简单。引起线程安全问题的根本原因在于：多个线程需要同时访问同一个共享资源，修改资源，容易出现问题。如果共享资源在创建之后就完全不再变更，如同一个常量，有修改则返回一个新对象，则可以保证线程安全</li><li>不可变的对象因为状态不会改变，所以更容易进行缓存和重用。字符串常量池的出现正是基于这个原因。当代码中出现相同的字符串字面量时，JVM会确保所有的引用都指向常量池中的同一个对象，从而节约内存。</li><li>因为String的内容不会改变，所以它的哈希值也就固定不变。这使得String对象特别适合作为<code>HashMap</code>或<code>HashSet</code>等集合的键，因为计算哈希值只需要进行一次，提高了哈希表操作的效率。</li></ul><p>保证String不可变的措施：</p><ul><li>String类内部使用一个私有的字符数组来存储字符串数据。这个字符数组在创建字符串时被初始化，之后不允许被改变。</li><li>String类也不提供任何可以修改其内容的公共方法，像<code>concat</code>这些看似修改字符串的操作，实际上都是返回一个新创建的字符串对象，而原始字符串对象保持不变。</li><li>String类本身被声明为<code>final</code>，这意味着它不能被继承，防止通过子类添加修改方法来改变字符串内容的可能。</li></ul><h2 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a>StringBuilder 和 StringBuffer</h2><p><code>StringBuilder</code>和<code>StringBuffer</code>定义的字符串内容可变。</p><p>当遇到大量字符串连接时，由于String的不变性，每次都是返回一个新的String对象，因此用<code>StringBuilder</code>更合适，它不会生成很多新的对象，<code>StringBuffer</code>和<code>StringBuilder</code>类似，但每个方法上都加了<code>synchronized</code>关键字，所以是线程安全的。</p><ul><li>String：适用于字符串内容不会改变的场景，比如说作为<code>HashMap</code>的key</li><li>StringBuilder：适用于单线程环境下需要频繁修改字符串内容的场景，比如在循环中拼接或修改字符串，是String的完美替代品</li><li>StringBuffer：现在已经不怎么用了，因为一般不会在多线程场景下去频繁的修改字符串内容</li></ul><p><code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，其<code>append</code>方法最终是调用父类的<code>append</code>：</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/append1.png" alt="append"></p><p><em>以StringBuilder为例</em></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/append2.png" alt="append"></p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/abstract_string_builder.png" alt="append"></p><p>而父类的append将字符串放入其字符数组中，同时记录字符数量的<code>count</code>也同步增加。其中<code>ensureCapacityInternal</code>方法是用来确保字符数组能放得下新加的字符串，当数组大小不够时会扩容。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/ensure_capacity_internal.png" alt="append"></p><p>若原有容量<code>oldCapacity</code>小于需要的容量<code>minimumCapacity</code>，就会利用<code>Arrays.copyOf()</code>方法，将当前数组的值拷贝给<code>newCapacity()</code>个长度的新数组，最后再重新赋值给value字节数组。<strong>因此是利用数组复制的方法来实现扩容</strong>。</p><p><img src="/images/Java%E4%B8%AD%E7%9A%84String/new_capacity.png" alt="append"></p><p><code>newCapacity</code>方法作用是计算出扩容后新数组的长度，若大于整型的最大值则抛出<code>OutOfMemoryError</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7235628080219488293&quot;&gt;从零开始学Java之StringBuilder与StringBuffer使用及源码解读&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;String为什么设计为不可变？如何保证Stri</summary>
      
    
    
    
    
    <category term="Java" scheme="http://princesaoke.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android中的Service</title>
    <link href="http://princesaoke.github.io/2024/06/09/Android%E4%B8%AD%E7%9A%84Service/"/>
    <id>http://princesaoke.github.io/2024/06/09/Android%E4%B8%AD%E7%9A%84Service/</id>
    <published>2024-06-09T09:21:24.000Z</published>
    <updated>2024-06-11T01:00:03.369Z</updated>
    
    <content type="html"><![CDATA[<p>Android Studio 中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android Studio 中&lt;/p&gt;
</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和协程</title>
    <link href="http://princesaoke.github.io/2024/06/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"/>
    <id>http://princesaoke.github.io/2024/06/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</id>
    <published>2024-06-07T09:34:04.000Z</published>
    <updated>2024-10-19T04:07:24.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发就是同一时刻只有一条指令在执行，但由于CPU时间片很小，多个指令间能快速切换，宏观上形成同时执行的效果。</p><p>并行则是真正意义上的同时进行。</p><h2 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h2><ul><li>原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行</li><li>可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</li><li>有序性：程序执行的顺序按照代码的先后顺序执行</li></ul><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li><li>一个进程可以有多个线程，至少有一个主线程</li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响；但一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ul><h2 id="多进程和多线程分别有何优势？"><a href="#多进程和多线程分别有何优势？" class="headerlink" title="多进程和多线程分别有何优势？"></a>多进程和多线程分别有何优势？</h2><ul><li>线程之间可以更轻松的共享数据</li><li>系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小</li><li>线程崩溃可能导致整个进程崩溃，而进程崩溃不会影响到另一个进程</li></ul><h2 id="哪些是线程共享的，哪些是进程共享的？"><a href="#哪些是线程共享的，哪些是进程共享的？" class="headerlink" title="哪些是线程共享的，哪些是进程共享的？"></a>哪些是线程共享的，哪些是进程共享的？</h2><p>Q：Java三种创建线程的方法有什么区别？</p><p>A：</p><blockquote><p>……</p></blockquote><h2 id="Java中锁的类型"><a href="#Java中锁的类型" class="headerlink" title="Java中锁的类型"></a>Java中锁的类型</h2><ul><li><strong>悲观锁</strong>、<strong>乐观锁</strong>：悲观锁总是认为其他线程会修改数据，因此每次操作都上锁，如<code>synchronized</code>；乐观锁则假设其他线程不会修改数据，不上锁，如<code>CAS</code></li><li><strong>公平锁</strong>、<strong>非公平锁</strong>：公平锁按申请锁的顺序获取，如<code>ReentrantLock</code>；非公平锁不保证顺序</li><li><strong>自旋锁</strong>：线程循环等待直到获取锁</li><li><strong>可重入锁</strong>、<strong>不可重入锁</strong>：可重入锁允许内层使用锁，不会产生死锁；不可重入锁不允许</li><li><strong>共享锁&#x2F;读锁</strong>、<strong>独享锁&#x2F;写锁</strong>：共享锁允许多个执行单元同时获取锁，独享锁只允许一个</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><a href="https://blog.csdn.net/u013541140/article/details/95225769">Java 多线程：彻底搞懂线程池</a></p><p><img src="/images/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/diagram.png" alt="继承关系"></p><p><code>ThreadPoolExecutor</code>的参数：</p><table><thead><tr><th align="center">参数名</th><th align="center">是否必需</th><th align="center">数据类型</th><th><center>说明</center></th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">必需</td><td align="center">int</td><td>线程池的核心线程数</td></tr><tr><td align="center">maximumPoolSize</td><td align="center">必需</td><td align="center">int</td><td>线程池的最大线程数</td></tr><tr><td align="center">keepAliveTime</td><td align="center">必需</td><td align="center">long</td><td>当线程数大于核心线程数时，多余的空闲线程存活的最长时间</td></tr><tr><td align="center">unit</td><td align="center">必需</td><td align="center">TimeUnit</td><td>keepAliveTime的时间单位</td></tr><tr><td align="center">workQueue</td><td align="center">必需</td><td align="center">BlockingQueue&lt;Runnable&gt;</td><td>决定线程池的任务队列的类型</td></tr><tr><td align="center">threadFactory</td><td align="center">可选</td><td align="center">ThreadFactory</td><td>用于指定为线程池创建新线程的方式</td></tr><tr><td align="center">handler</td><td align="center">可选</td><td align="center">RejectedExecutionHandler</td><td>拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</td></tr></tbody></table><p><img src="/images/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/step.png" alt="线程池工作流程图"></p><p>几种常见的内置线程池</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和并行&quot;&gt;&lt;/a&gt;并发和并行&lt;/h2&gt;&lt;p&gt;并发就是同一时刻只有一条指令在执行，但由于CPU时间片很小，多个指令间能快速切换，宏观上形成同时执行的效果。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Android中的数据持久化</title>
    <link href="http://princesaoke.github.io/2024/05/30/Android%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://princesaoke.github.io/2024/05/30/Android%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2024-05-30T05:51:38.000Z</published>
    <updated>2024-06-13T15:01:25.672Z</updated>
    
    <content type="html"><![CDATA[<p>可在 Android Studio 打开<code>Device Explorer</code>，在<code>/data/data/&lt;APP包名&gt;</code>中可以看到应用的数据。</p><h2 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 写数据</span></span><br><span class="line"><span class="keyword">val</span> editor = getSharedPreferences(<span class="string">&quot;user&quot;</span>, Context.MODE_PRIVATE).edit()</span><br><span class="line">editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">editor.putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">editor.apply()  <span class="comment">// 将添加的数据提交，从而完成数据存储操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 读数据</span></span><br><span class="line"><span class="keyword">val</span> prefs = getSharedPreferences(<span class="string">&quot;user&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> name = prefs.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> age = prefs.getInt(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> married = prefs.getBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">Log.d(<span class="string">&quot;MyLog&quot;</span>, <span class="string">&quot;姓名：<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">Log.d(<span class="string">&quot;MyLog&quot;</span>, <span class="string">&quot;年龄：<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">Log.d(<span class="string">&quot;MyLog&quot;</span>, <span class="string">&quot;是否已婚：<span class="variable">$married</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中<code>getSharedPreferences</code>的第二个参数<code>Context.MODE_PRIVATE</code>表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写，且只有这一种模式，其他几种操作模式均已被废弃。</p><p>SharedPreferences文件是使用XML格式来对数据进行管理的：</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/shared_preferences.png" alt="SharedPreferences"></p><h2 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a>MMKV</h2><p><a href="https://github.com/Tencent/MMKV">MMKV Github 仓库</a></p><p>安装引入：</p><figure class="highlight kts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 将 &quot;1.3.5&quot; 替换为最新版本</span></span><br><span class="line">    implementation <span class="string">&#x27;com.tencent:mmkv:1.3.5&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在APP启动时初始化MMKV，设定MMKV的根目录：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mmkvPath = MMKV.initialize(<span class="keyword">this</span>)</span><br><span class="line">    Log.i(<span class="string">&quot;MyLog&quot;</span>, <span class="string">&quot;MMKV存储路径: <span class="variable">$mmkvPath</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mmkv = MMKV.defaultMMKV()</span><br><span class="line">    mmkv.encode(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    mmkv.encode(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    mmkv.encode(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name = mmkv.decodeString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> age = mmkv.decodeInt(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> married = mmkv.decodeBool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>)   <span class="comment">// 当数据不存在时，取第二个参数为默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q：MMKV与SharedPreferences有何区别？MMKV的适用场景？</p><p>A：</p><blockquote><p>……</p></blockquote><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>Android内置了SQLite数据库，用于本地存储关系复杂的数据。</p><p>自定义一个继承<code>SQLiteOpenHelper</code>的类，当调用它的实例的<code>getReadableDatabase</code>或<code>getWritableDatabase</code>方法时，传入数据库名和版本号，就可以打开指定的数据库。若不存在该数据库，则会自动创建，然后触发SQLiteOpenHelper的<code>onCreate</code>方法。若传入的版本号大于数据库的版本号，就会触发<code>onUpgrade</code>方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDatabaseHelper</span>(<span class="keyword">val</span> context: Context, name: String, version: <span class="built_in">Int</span>) :</span><br><span class="line">    SQLiteOpenHelper(context, name, <span class="literal">null</span>, version) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> createBookSql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        create table Book (</span></span><br><span class="line"><span class="string">            id integer primary key autoincrement, </span></span><br><span class="line"><span class="string">            name text, </span></span><br><span class="line"><span class="string">            price real, </span></span><br><span class="line"><span class="string">            pages integer</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">        db.execSQL(createBookSql)</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;Book表创建成功&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpgrade</span><span class="params">(db: <span class="type">SQLiteDatabase</span>, oldVersion: <span class="type">Int</span>, newVersion: <span class="type">Int</span>)</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dbHelper = MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">&quot;BookStore.db&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> db = dbHelper.writableDatabase  <span class="comment">// 无数据库BookStore，则创建数据库，触发onCreate，创建Book表</span></span><br><span class="line"></span><br><span class="line">dbHelper = MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">&quot;BookStore.db&quot;</span>, <span class="number">2</span>)</span><br><span class="line">db = dbHelper.writableDatabase  <span class="comment">// 打开已有数据库，版本号更新，触发onUpgrade</span></span><br></pre></td></tr></table></figure><p>事务是数据库运行的基本单位。当事务执行成功时，所有对数据库的更新操作都会被提交；事务执行中途失败，那么该事务中所有已经进行的操作都会被撤销，恢复到事务执行前的状态。</p><p>以买书为例，买方得到书和卖方失去书必须同时成功或失败，要放在一个事务中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dbHelper = MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">&quot;BookStore.db&quot;</span>, <span class="number">1</span>)</span><br><span class="line">db.beginTransaction()   <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 即 DELETE FROM Book WHERE name == &quot;第一行代码&quot;</span></span><br><span class="line">    db.delete(<span class="string">&quot;Book&quot;</span>, <span class="string">&quot;name == ?&quot;</span>, arrayOf(<span class="string">&quot;第一行代码&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟事务失败</span></span><br><span class="line">        <span class="keyword">throw</span> NullPointerException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> values = ContentValues().apply &#123;</span><br><span class="line">        put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;第一行代码&quot;</span>)</span><br><span class="line">        put(<span class="string">&quot;price&quot;</span>, <span class="number">50.00</span>)</span><br><span class="line">        put(<span class="string">&quot;pages&quot;</span>, <span class="number">810</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    db.insert(<span class="string">&quot;Store&quot;</span>, <span class="literal">null</span>, values)    <span class="comment">// 将valus插入Store表中</span></span><br><span class="line">    db.setTransactionSuccessful()       <span class="comment">// 事务已经执行成功</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    db.endTransaction()                 <span class="comment">// 结束事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当事务失败时，<code>beginTransaction</code>到<code>endTransaction</code>之内的逻辑都不会生效</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(inputText: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// data为要打开的文件名</span></span><br><span class="line">        <span class="comment">// 第二个参数默认为`MODE_PRIVATE`，表示若该文件已存在，则直接覆盖原文件</span></span><br><span class="line">        <span class="comment">// `MODE_APPEND`表示若该文件已存在，在原文件基础上追加内容</span></span><br><span class="line">        <span class="keyword">val</span> output = openFileOutput(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> writer = BufferedWriter(OutputStreamWriter(output))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use作用是在Lambda表达式完成后关闭外层的流，无需手动关闭</span></span><br><span class="line">        writer.use &#123;</span><br><span class="line">            it.write(inputText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> content = StringBuilder()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> input = openFileInput(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> reader = BufferedReader(InputStreamReader(input))</span><br><span class="line">        reader.use &#123;</span><br><span class="line">            reader.forEachLine &#123; content.append(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可在 Android Studio 打开&lt;code&gt;Device Explorer&lt;/code&gt;，在&lt;code&gt;/data/data/&amp;lt;APP包名&amp;gt;&lt;/code&gt;中可以看到应用的数据。&lt;/p&gt;
&lt;h2 id=&quot;SharedPreferences&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中的BroadcastReceiver</title>
    <link href="http://princesaoke.github.io/2024/05/29/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/"/>
    <id>http://princesaoke.github.io/2024/05/29/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/</id>
    <published>2024-05-29T07:11:41.000Z</published>
    <updated>2024-05-29T12:31:01.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="广播接收"><a href="#广播接收" class="headerlink" title="广播接收"></a>广播接收</h1><p>在以下路径查询所有的 broadcast actions：<code>&lt;Android SDK 安装目录&gt;/platforms/&lt;Android API 版本&gt;/data</code>。</p><p>分为动态注册和静态注册。动态注册将BroadcastReceiver写在Activity中，因此只有APP启动时才能接收广播。静态注册写在<code>Manifest.xml</code>中，APP未启动也能接收广播，但只能接收除隐式广播（没有具体指定发送给哪个应用程序的广播）之外的小部分广播。</p><h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>自定义一个继承<code>BroadcastReceiver</code>的类，重写父类的<code>onReceive</code>方法。然后实例化一个<code>IntentFilter</code>，添加要接收的action。最后用<code>registerReceiver</code>方法将自定义类和IntentFilter对象绑定。这样当收到对应action的广播时就会调用onReceive：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver, intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">TimeChangeReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;时间改变&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：不要在<code>onReceive</code>方法中添加过多的逻辑或者进行任何的耗时操作，因为BroadcastReceiver中是不允许开启线程的，当onReceive运行了较长时间而没有结束时，程序就会出现错误</em></p><h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>Android 8.0（API 级别 26）或更高级别为目标的应用无法在其清单中注册隐式广播的广播接收器，除非广播是专门发送给这些应用的。不过，有几种广播不受这些限制的约束。具体有哪些可以参考<a href="https://developer.android.google.cn/develop/background-work/background-tasks/broadcasts/broadcast-exceptions?hl=zh-cn">隐式广播例外情况</a>。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/new.png" alt="新建隐式BroadcastReceiver"></p><p>以接收开机广播为例，在 Android Studio 中右键新建BroadcastReceiver，会将其自动添加到<code>Manifest.xml</code>。新建窗口中的<code>Exported</code>表示是否允许这个BroadcastReceiver接收本程序以外的广播，<code>Enabled</code>表示是否启用这个BroadcastReceiver。</p><p>在<code>Manifest.xml</code>进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 若是自定义的广播，name为包名 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;action android:name=&quot;com.saoke.androiddemo.MY_BROADCAST&quot;/&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="广播发送"><a href="#广播发送" class="headerlink" title="广播发送"></a>广播发送</h1><p>分为<code>标准广播</code>和<code>有序广播</code>。</p><p>标准广播是一种完全异步执行的广播，在广播发出之后，所有的BroadcastReceiver几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/normal_broadcasts.png" alt="标准广播"></p><p>有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是有先后顺序的，优先级高的BroadcastReceiver就可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。</p><p><img src="/images/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/ordered_broadcasts.png" alt="有序广播"></p><h2 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.saoke.androiddemo.MY_BROADCAST&quot;</span>)</span><br><span class="line">    intent.setPackage(packageName)  <span class="comment">// packageName 即 getPackageName()，获取当前APP的包名</span></span><br><span class="line">    sendBroadcast(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>setPackage()</code>指定这条广播是发送给哪个应用程序的，从而让它变成一条显式广播，否则静态注册的BroadcastReceiver将无法接收到这条广播</p><h2 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.saoke.androiddemo.MY_BROADCAST&quot;</span>)</span><br><span class="line">    intent.setPackage(packageName)</span><br><span class="line">    sendOrderedBroadcast(intent, <span class="string">&quot;saoke.androiddemo&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sendOrderedBroadcast</code>第二个参数为设置的权限，BroadcastReceiver要有对应权限才能接收到广播。权限为带<code>.</code>的字符串，无须权限可设为<code>null</code>。同样的标准广播也可设置权限。</p><p>可在<code>Manifest.xml</code>中设置BroadcastReceiver优先级，优先级高的先收到广播：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 若要接收的广播有设置权限，则APP要声明对应的权限 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;saoke.androiddemo&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 设置优先级为 100 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.saoke.androiddemo.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 若要接收的广播有设置权限，则接收器也要设置对应的权限 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;saoke.androiddemo&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可在<code>onReceive</code>中用<code>abortBroadcast()</code>截断广播，后面的BroadcastReceiver将无法再接收到这条广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;MyBroadcastReceiver收到广播&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        abortBroadcast()    <span class="comment">// 截断广播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;广播接收&quot;&gt;&lt;a href=&quot;#广播接收&quot; class=&quot;headerlink&quot; title=&quot;广播接收&quot;&gt;&lt;/a&gt;广播接收&lt;/h1&gt;&lt;p&gt;在以下路径查询所有的 broadcast actions：&lt;code&gt;&amp;lt;Android SDK 安装目录&amp;gt;/pl</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中的Activity</title>
    <link href="http://princesaoke.github.io/2024/05/27/Android%E4%B8%AD%E7%9A%84Activity/"/>
    <id>http://princesaoke.github.io/2024/05/27/Android%E4%B8%AD%E7%9A%84Activity/</id>
    <published>2024-05-27T15:14:30.000Z</published>
    <updated>2024-06-13T15:01:43.215Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaokangss/article/details/125547085">Activity的生命周期和启动模式详解</a></p><h2 id="Activity的状态"><a href="#Activity的状态" class="headerlink" title="Activity的状态"></a>Activity的状态</h2><ul><li><strong>运行状态</strong>：Activity位于返回栈的栈顶时就处于运行状态</li><li><strong>暂停状态</strong>：Activity不在栈顶，但仍然可见时，就处于暂停状态</li><li><strong>停止状态</strong>：Activity不在栈顶，且完全不可见的时，就处于停止状态。该状态下的Activity在内存紧张时可能被回收</li><li><strong>销毁状态</strong>：Activity从返回栈中移除，不在栈里后就变成了销毁状态，系统最倾向于回收处于这种状态的Activity</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/images/Android%E4%B8%AD%E7%9A%84Activity/life_cycle.png" alt="Activity的生命周期流程图"></p><ul><li><strong>onCreate</strong>：在Activity第一次被创建的时候调用，执行加载布局、绑定事件等</li><li><strong>onStart</strong>：在Activity由不可见变为可见的时候调用</li><li><strong>onResume</strong>：当焦点从未完全覆盖屏幕的Activity（弹窗等）切换到此Activity时（即此Activity准备好和用户进行交互时）调用，此时的Activity一定位于返回栈的栈顶，并且处于运行状态，在最前台</li><li><strong>onPause</strong>：在系统准备去启动或者恢复另一个Activity的时候调用，该方法的执行速度要快，否则会影响到新的栈顶Activity的使用</li><li><strong>onStop</strong>：在Activity完全不可见时调用。它和onPause方法的主要区别在于，若启动的新Activity是对话框式的，则onPause方法会执行，而onStop不会</li><li><strong>onDestroy</strong>：在Activity被销毁之前调用，之后Activity的状态将变为销毁状态</li><li><strong>onRestart</strong>：在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了</li></ul><p>Q：<code>Activity A</code>启动<code>Activity B</code>，那么<code>B</code>的<code>onResume</code>和<code>A</code>的<code>onPause</code>哪个先执行？</p><p>A：</p><blockquote><p><code>A</code>先执行<code>onPause</code>，紧接着<code>B</code>执行<code>onCreate</code>-&gt;<code>onStart</code>-&gt;<code>onResume</code>，接着执行<code>A</code>的<code>onStop</code></p></blockquote><p>Q：Activity进入停止状态后被系统回收，如何还原数据？</p><p>A：</p><blockquote><p>Activity中的<code>onSaveInstanceState</code>方法在Activity被回收前会被调用，它携带一个<code>Bundle</code>类型的参数用于保存数据。<br>可以在Activity中重写<code>onSaveInstanceState</code>方法，在Bundle对象中存入要保存的数据，<br>当Activity被回收后重新创建新的实例，在<code>onCreate</code>方法中可以获取到保存的Bundle对象。<br>判断当Bundle不为空时，对数据进行赋值还原。</p></blockquote><h2 id="Activity的返回栈"><a href="#Activity的返回栈" class="headerlink" title="Activity的返回栈"></a>Activity的返回栈</h2><p>……</p><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>在<code>Manifest.xml</code>中修改Activity的<code>launchMode</code>切换Activity的启动模式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;standard&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>standard是Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。在standard模式下，每当启动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该Activity的新实例。</p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当Activity的启动模式指定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。不过当FirstActivity并未处于栈顶位置时，再启动FirstActivity还是会创建新的实例。</p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。</p><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>指定为singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity，这样不管是哪个应用程序来访问这个Activity，都共用同一个返回栈，也就解决了共享Activity实例的问题</p><p>Q：<code>A</code>、<code>B</code>、<code>C</code>三个Activity，其中<code>A</code>、<code>C</code>为<code>standard</code>，<code>B</code>为<code>singleInstance</code>，从<code>A</code>进入<code>B</code>再从<code>B</code>进入<code>C</code>。现在连按三次返回，返回顺序是怎样的？</p><p>A：</p><blockquote><p>从<code>C</code>返回到<code>A</code>再返回到<code>B</code>。</p><p>这是因为<code>A</code>、<code>C</code>处于同一返回栈，而<code>B</code>为<code>singleInstance</code>，单独处于一个返回栈。<br>因此<code>C</code>先出栈，<code>A</code>成为栈顶；<code>A</code>再出栈后返回栈为空，于是显示另一个返回栈的栈顶Activity，即<code>B</code>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaokangss/article/details/125547085&quot;&gt;Activity的生命周期和启动模式详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Activity的状态&quot;&gt;&lt;a href=&quot;#Activity</summary>
      
    
    
    
    <category term="移动端" scheme="http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://princesaoke.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>阿里智能信息前端实习面经</title>
    <link href="http://princesaoke.github.io/2024/05/15/%E9%98%BF%E9%87%8C%E6%99%BA%E8%83%BD%E4%BF%A1%E6%81%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/05/15/%E9%98%BF%E9%87%8C%E6%99%BA%E8%83%BD%E4%BF%A1%E6%81%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-05-15T13:34:56.000Z</published>
    <updated>2024-05-17T04:24:21.503Z</updated>
    
    <content type="html"><![CDATA[<p>一面挂，四十五分钟。</p><ul><li><span style="color: green">✔</span> 编程题：URL combo - 字符串分割</li><li><span style="color: green">✔</span> 编程题：统计网页中出现了几种HTML元素</li><li><span style="color: red">❌</span> Array如何转化为Set</li><li><span style="color: green">✔</span> 自我介绍，说一下学习和项目经历</li><li><span style="color: green">✔</span> 为什么学习Flutter？Flutter优势何在？</li><li><span style="color: green">✔</span> Flutter三棵树分别起什么作用？</li><li><span style="color: red">❌</span> Flutter状态管理相关，子组件如何与父组件通信？</li><li><span style="color: red">❌</span> Flutter如何与底层原生通信，如image_picker调用系统相机的原理？</li><li><span style="color: red">❌</span> 说一下MQTT协议？有什么特性？为什么物联网用MQTT？MQTT是基于TCP还是UDP？</li><li><span style="color: red">❌</span> 说一下 HTTP1.0 和 HTTP2.0 的区别</li><li><span style="color: red">❌</span> 说一下前端工程化？Vite有什么优势？</li><li><span style="color: green">✔</span> 为什么没有选择客户端开发？</li><li><span style="color: green">✔</span> 未来规划读研还是就业？</li></ul><p>编程题：URL combo - 字符串分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是天猫首页一个经过 combo 的 js 资源 url，请找出 combo 规律并用 js 写一个可复用的函数来解该 url，得到每个 combo 前的 url 地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urlStr = <span class="string">&#x27;https://g.alicdn.com/??code/npm/web-rax-framework/0.6.5/dist/framework.web.min.js,mtb/lib-windvane/2.1.8/windvane.cmd.js,mtb/lib-promise/3.1.3/polyfillB.js,mtb/lib-mtop/2.4.0/mtop.js,mtb/lib-login/1.5.3/login.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unComboUrl</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 以&#x27;/&#x27;分割，还原出baseUrl</span></span><br><span class="line">    <span class="comment">// 再以逗号分割，将每一项与baseUrl合并</span></span><br><span class="line">    <span class="keyword">const</span> l = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> baseUrl = l[<span class="number">0</span>] + <span class="string">&#x27;//&#x27;</span> + l[<span class="number">2</span>] + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> list = url.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(list[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = baseUrl + list[i]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(list[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">unComboUrl</span>(urlStr)</span><br></pre></td></tr></table></figure><p>编程题：统计网页中出现了几种HTML元素</p><p>一开始没写出来，因为我没法用DOM操作提取出HTML标签，后来面试官改成字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个网页中，用尽可能少的代码，计算出当前网页用了多少种 HTML 元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串，遇到`&lt;`则开始识别HTML标签，`&gt;`或空格前的即为标签，将其入栈</span></span><br><span class="line"><span class="comment">// 遇到`&lt;/`则为闭标签，识别后将栈顶对应标签出栈，若栈顶不匹配，则说明栈顶是非闭合标签，同样出栈，直到匹配为止</span></span><br><span class="line"><span class="comment">// 若是形如`&lt;img /&gt;`的标签，则不用入栈进入下一步</span></span><br><span class="line"><span class="comment">// 将出栈的标签加入集合，得到无重复的标签，集合大小即HTML种类数量</span></span><br></pre></td></tr></table></figure><p>HTTP1.0 和 HTTP2.0的区别：</p><p>HTTP1.0：</p><ul><li><strong>单一请求-响应模式</strong>：每次请求-响应都需要建立一个新的TCP连接，这个过程包括三次握手，增加了延迟</li><li><strong>无状态连接</strong>：每个请求都是独立的，服务器不维护客户端的状态</li><li><strong>请求头和响应头冗余</strong>：每次请求都会发送完整的头部信息，导致数据冗余和效率低下</li><li><strong>文本协议</strong>：所有的请求和响应都是基于文本的，解析速度相对较慢</li><li><strong>有限的并发</strong>：因为每个请求都需要一个单独的TCP连接，浏览器通常限制同一域名下的并发连接数，通常是4到6个</li></ul><p>HTTP2.0：</p><ul><li><strong>多路复用</strong>：实现了多路复用，允许在单个TCP连接上并发多个请求-响应对，从而减少了连接的数量和延迟</li><li><strong>二进制协议</strong>：相对于HTTP&#x2F;1.0的文本协议，HTTP&#x2F;2.0采用二进制格式，解析更高效</li><li><strong>头部压缩</strong>：使用HPACK压缩算法来减少头部信息的大小，从而减少带宽消耗</li><li><strong>服务器推送</strong>：服务器可以主动向客户端推送资源，而无需客户端明确请求，这样可以减少延迟并提高性能</li><li><strong>流优先级</strong>：客户端和服务器可以通过设置流优先级来优化资源的传输顺序</li><li><strong>连接管理</strong>：更有效的连接管理机制，通过单个连接处理多个并发请求，减少了连接建立和维护的开销</li><li><strong>改进的安全性</strong>：虽然HTTP&#x2F;2.0可以在明文（HTTP）和加密（HTTPS）下工作，但通常与TLS（传输层安全协议）结合使用，以提供更好的安全性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一面挂，四十五分钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color: green&quot;&gt;✔&lt;/span&gt; 编程题：URL combo - 字符串分割&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: green&quot;&gt;✔&lt;/span&gt; 编程题：统计网页中出</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://princesaoke.github.io/2024/05/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://princesaoke.github.io/2024/05/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2024-05-14T12:47:03.000Z</published>
    <updated>2024-09-27T03:30:39.405Z</updated>
    
    <content type="html"><![CDATA[<p>稳定排序：冒泡排序、插入排序、归并排序、基数排序</p><p>不稳定排序：选择排序、快速排序、希尔排序、堆排序</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>总共需要比较<code>n - 1</code>趟，每趟<code>n - 1 - i</code>次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(T a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) swap(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基于<code>分治</code>和<code>递归</code>。</p><p>其基本思路是，在数组中选择一个元素作为基准值，然后将数组中小于基准值的元素移动到它的左边，大于基准值的元素移动到它的右边。然后对左右两个子数组递归地重复这个过程，直到子数组的大小为1或0。</p><p>是不稳定排序。当要比较的值和基准值一样时，根据代码可能放在基准值左边或右边。</p><p>最好情况：每次划分左右两边的元素数量相同各为一半，则此时时间复杂度为<code>O(nlogn)</code></p><p>最坏情况：每次划分所有元素都在一边，另一边为空，则此时与冒泡排序类似，时间复杂度为<code>O(n²)</code></p><p>平均情况：时间复杂度为<code>O(nlogn)</code></p><p>因此关键在于每次基准值的选取。</p><p>通过不同方式选取基准值，有以下几种衍生快排：</p><ul><li><p><strong>随机快速排序</strong>：即在数组中完全随机地挑选一个值作为基准值。</p></li><li><p><strong>三数取中快速排序</strong>：即取数组中第一个、中间、最后一个这三个元素的中位数作为基准值。</p></li><li><p><strong>三划分快速排序</strong>：适用于数组中有较多大小相同的数。对于等于基准值的数分为除左右外的第三部分，不用继续参与递归。</p></li></ul><p>图解：</p><p>以数组中第一个元素为基准值</p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_1.jpg" alt="快排1"></p><p>左指针不断右移，直到找到比基准值大的元素停下；右指针不断左移，直到找到比基准值小的元素停下</p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_2.jpg" alt="快排2"></p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_3.jpg" alt="快排3"></p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_4.jpg" alt="快排4"></p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_5.jpg" alt="快排5"></p><p>当两指针碰面或超过，说明已经全部遍历了</p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_6.jpg" alt="快排6"></p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_7.jpg" alt="快排7"></p><p>交换后左边都小于基准值，右边都大于基准值</p><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quick_sort_8.jpg" alt="快排8"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 以数组中第一个元素为基准值，确定其位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(T a[], <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = begin + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = end;</span><br><span class="line">    T base = a[begin];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[left++] &lt; base);   <span class="comment">// 左指针不断右移，直到找到比基准值大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (a[right--] &gt; base);  <span class="comment">// 右指针不断左移，直到找到比基准值小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">break</span>;    <span class="comment">// 当两指针碰面或超过，说明已经全部遍历了</span></span><br><span class="line">        swap(a[left], a[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[right], a[begin]);       <span class="comment">// 交换后right左边都小于base，右边都大于base</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomPartition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> randomIndex = Random(begin, end);  <span class="comment">// 可取不同值作为基准值，这里随机一个下标</span></span><br><span class="line">    swap(a[randomIndex], a[begin]);</span><br><span class="line">    <span class="keyword">return</span> partition(a, begin, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(T a[], <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> middle = partition(a, begin, end);</span><br><span class="line">        quickSort(a, begin, middle - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, middle + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;稳定排序：冒泡排序、插入排序、归并排序、基数排序&lt;/p&gt;
&lt;p&gt;不稳定排序：选择排序、快速排序、希尔排序、堆排序&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://princesaoke.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>饿了么客户端实习面经</title>
    <link href="http://princesaoke.github.io/2024/05/07/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/05/07/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-05-07T11:30:21.000Z</published>
    <updated>2024-05-17T04:15:31.399Z</updated>
    
    <content type="html"><![CDATA[<p>答的很烂……就没几个问题是答出来的 T^T</p><p>共四十多分钟。</p><ul><li><span style="color: green">✔</span> 自我介绍</li><li><span style="color: green">✔</span> 详细讲一下实习期间做了哪些事情？实现的细节？</li><li><span style="color: red">❌</span> LazyColumn和Column有什么区别？为什么能提升性能？</li><li><span style="color: red">❌</span> 长列表的数据如果一次性加载会卡顿，如何处理？分页查询相关。如何刷新？前一页的数据如何处理？</li><li><span style="color: red">❌</span> Flutter三个树？嵌套的组件渲染绘制的步骤？</li><li><span style="color: green">✔</span> UDP和TCP的区别</li><li><span style="color: red">❌</span> 2M的数据流，通过TCP发送，要经过哪些步骤？</li><li><span style="color: red">❌</span> APP的启动过程</li><li><span style="color: green">✔</span> Activity的生命周期？两个Activity跳转其分别的生命周期函数调用顺序？哪些情况下不会进入onStop？</li><li><span style="color: red">❌</span> 说一下快排</li><li><span style="color: green">✔</span> 最大递增子串</li><li><span style="color: green">✔</span> 链表翻转</li></ul><p>长列表性能问题应该是想问<code>RecyclerView</code>四级缓存机制吧。即<code>Scrap缓存</code>、<code>Recycle缓存</code>、<code>ViewCacheExtension缓存</code>、<code>RecycledViewPool缓存</code>。</p><p>RecyclerView在滚动时会复用已经存在的ViewHolder对象，而不是每次都创建新的ViewHolder。这样做的好处是减少了对象的创建和销毁次数，提高了内存利用率和性能。当列表项滚出屏幕时，对应的ViewHolder会被移除并加入到RecyclerView的内部缓存池中，当新的列表项需要显示时，RecyclerView会尝试从缓存池中获取可用的ViewHolder对象，避免了重新创建ViewHolder。</p><p>RecyclerView提供了setItemViewCacheSize()方法来设置缓存的ViewHolder数量。通过适当调整这个值，可以控制缓存的大小，避免过多的缓存导致内存占用过高。</p><p>Flutter三棵树指的是<code>Widget树</code>、<code>Element树</code>、<code>RenderObject树</code>。</p><p><a href="https://blog.csdn.net/xiaokangss/article/details/125547085">Activity的生命周期和启动模式详解</a></p><p><code>Fragment</code>在显示到销毁的过程中会执行自己的生命周期：<code>onAttach</code> -&gt; <code>onCreate</code> -&gt;<code>onCreateView</code> -&gt; <code>onActivityCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code> -&gt; <code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroyView</code> -&gt; <code>onDestroy</code> -&gt; <code>onDetach</code></p><p>同时也受到<code>Activity</code>生命周期的影响，如果Activity触发<code>onPause</code>，Fragment也会执行相应的onPause。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;答的很烂……就没几个问题是答出来的 T^T&lt;/p&gt;
&lt;p&gt;共四十多分钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color: green&quot;&gt;✔&lt;/span&gt; 自我介绍&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: green&quot;&gt;✔&lt;/span&gt; 详</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>美团客户端实习面经</title>
    <link href="http://princesaoke.github.io/2024/04/28/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>http://princesaoke.github.io/2024/04/28/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2024-04-28T14:08:43.000Z</published>
    <updated>2024-09-21T05:06:05.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试-4-27"><a href="#笔试-4-27" class="headerlink" title="笔试 4.27"></a>笔试 4.27</h2><p>题型：30题单选题，2题编程题</p><p>时间：2小时</p><p>单选题主要有计算机网络、操作系统、数据结构、数字找规律、三元一次方程应用题等。</p><p>记录单选题涉及到的知识点</p><ul><li>有效的子网掩码</li><li>SQL共享锁和排它锁，其他事务能否读写</li><li>HTTP2 和 HTTP3 的区别</li></ul><p>编程题AC第一题，第二题是一个九宫格魔法阵，周围的数值改变怎么怎么样的，没一点思路。</p><p>当时没记录，现在忘了。。</p><h2 id="一面-5-16"><a href="#一面-5-16" class="headerlink" title="一面 5.16"></a>一面 5.16</h2><ul><li><span style="color: green">✔</span> C和C++的区别</li><li><span style="color: red">❌</span> 子结构体对父结构体函数的重写</li><li><span style="color: green">✔</span> 进程和线程的区别</li><li><span style="color: green">✔</span> 同步和异步的区别？为什么需要异步？多线程操作时可能出现什么问题？</li><li><span style="color: red">❌</span> OSI七层网络模型</li><li><span style="color: green">✔</span> HTTP和HTTPS的区别？HTTP全称是什么？HTTPS的S指什么？</li><li><span style="color: green">✔</span> TCP和UDP的区别</li><li><span style="color: green">✔</span> 为什么要三次握手</li><li><span style="color: green">✔</span> 服务器如何知道请求中的不同类型的数据格式？</li><li><span style="color: red">❌</span> 编程题：翻转链表</li></ul><p>全都是考基础，没问项目没问实习。</p><p>开头自我介绍，然后问我熟悉什么语言，C++或Java会吗，一开始就是打算考编程语言。</p><p>C和C++的区别，答：一个是面向对象一个是面向过程，C++有输入输出流</p><p>然后出了个题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    f() &#123; <span class="built_in">printf</span>(<span class="string">&#x27;A&#x27;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    f() &#123; <span class="built_in">printf</span>(<span class="string">&#x27;B&#x27;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    A a = A();</span><br><span class="line">    B b = B();</span><br><span class="line">    a.f();</span><br><span class="line">    b.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问输出是什么。又问给<code>B</code>的<code>f()</code>加上<code>virtual</code>，输出是什么。</p><p>最后一题考编程题，两非递减数组原地排序，LeetCode上刷过，心中窃喜，结果语言切到C++，判题器有点问题没给提交模板，判不了题直接编译错误，面试官也弄不明白，就给我换了一题翻转链表，结果没做出来，被自己的抽象操作蠢哭了…… T^T</p><p>最后面试官还指出了我的不足。在我做编程题的时候他看了我的Github和博客，说我项目是足够的，但是要注重基础，编程语言的基础和底层，计网、数据结构四大件的基础等。</p><p>还是第一次有面试官给我提建议，发觉不同面试官之间面试方式还是有挺大差距的，有的没怎么问编程语言，有的不怎么问实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔试-4-27&quot;&gt;&lt;a href=&quot;#笔试-4-27&quot; class=&quot;headerlink&quot; title=&quot;笔试 4.27&quot;&gt;&lt;/a&gt;笔试 4.27&lt;/h2&gt;&lt;p&gt;题型：30题单选题，2题编程题&lt;/p&gt;
&lt;p&gt;时间：2小时&lt;/p&gt;
&lt;p&gt;单选题主要有计算机网络、操</summary>
      
    
    
    
    <category term="面经" scheme="http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
</feed>
