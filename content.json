{"meta":{"title":"骚客.的个人博客","subtitle":"记录我的学习过程","description":"使用Hexo搭建，欢迎交流","author":"骚客.","url":"http://PrinceSaoKe.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-09-02T06:14:08.855Z","updated":"2023-09-02T06:14:08.855Z","comments":false,"path":"/404.html","permalink":"http://princesaoke.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-12-20T16:16:19.189Z","updated":"2023-12-20T16:16:19.189Z","comments":false,"path":"about/index.html","permalink":"http://princesaoke.github.io/about/index.html","excerpt":"","text":"参观我的个人网站：http://saoke.fun"},{"title":"友情链接","date":"2023-09-02T06:14:08.860Z","updated":"2023-09-02T06:14:08.860Z","comments":true,"path":"links/index.html","permalink":"http://princesaoke.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-09-02T06:14:08.862Z","updated":"2023-09-02T06:14:08.862Z","comments":false,"path":"repository/index.html","permalink":"http://princesaoke.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-09-02T06:14:08.863Z","updated":"2023-09-02T06:14:08.863Z","comments":false,"path":"tags/index.html","permalink":"http://princesaoke.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-02T06:14:08.859Z","updated":"2023-09-02T06:14:08.859Z","comments":false,"path":"categories/index.html","permalink":"http://princesaoke.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"百度秋招面经","slug":"百度秋招面经","date":"2024-10-20T15:43:16.000Z","updated":"2024-10-22T07:23:54.648Z","comments":true,"path":"2024/10/20/百度秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/10/20/%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"这一天是部门群面，要等通过后再决定部门和岗位。是移动生态相关的部门，包括百度文库、百度贴吧、百度APP等。 一个下午连面三场，都通过了 一面 10.20 16:0030分钟左右。 ✔ 实习做了什么 ❌ Flutter和Android交互 ✔ HTTPS加密过程，可以被抓包破解吗？ ✔ DNS的解析过程 ✔ String、StringBuilder、StringBuffer的区别 ❌ StringBuffer是如何实现线程安全的？ ✔ 抽象类和接口的区别 ❌ 泛型的优点 ❌ Java反射 ✔ 线程和进程的区别 ✔ Java中如何保证线程的有序性和原子性？volatile的原理 ❌ Java线程池的优点？有几种常用线程池？ ✔ 线程池的工作流程 ✔ synchronized的使用场景 ❌ synchronized和lock的区别 ✔ Android四大组件 ✔ Activity生命周期 ✔ Activity启动模式 ✔ Android中的几种本地存储方式 ❌ MVP、MVC和MVVM的区别 ✔ 编程题：长度为n+1的无序数组，元素值为1~n，只有一个元素重复，找出该数，要求时间复杂度小于O(n^2)，空间复杂度为O(1) 反问哪块比较薄弱，面试官说我安卓方面掌握的在候选人中算比较好，Java一些更底层的原理可以再学习，基本上都ok。当场就让我过了，马上紧接着二面。 二面 10.20 16:3030分钟左右。 ✔ Flutter的渲染机制 ✔ Flutter用自己的绘制方案，和其他跨端框架使用原生控件相比，有哪些优缺点？ ❌ 鸿蒙了解过吗 ✔ 使用Flutter时，有对网络请求进行封装吗？ ✔ 本地数据持久化有哪些方式？ ❌ 路由机制的底层实现，底层是什么数据结构 ❌ OCR接口的凭证如何存储？有做加密吗？ ✔ 柱状图是如何实现的？ ✔ Android为什么要改为动态授权？ ❌ Vue3和Vue2的区别 ❌ 响应拦截器中处理了拦截的数据，后续的拦截器还能否收到数据？ ✔ MMKV为什么比SharedPreferences更快 ✔ 编程题：翻转链表 反问哪块比较薄弱，面试官说我有Android和Flutter的经验比较好，实践方面可以更深入，总的来说也挺好的。当场就让我过了，马上紧接着三面。 三面 10.20 17:1030分钟左右。 ✔ 有哪些跨平台框架，Flutter和Android相比有哪些优劣 ❌ 既然Flutter有诸多优势，为什么还是有很多项目不使用Flutter？ ❌ Flutter性能上和原生差在哪？ ✔ 为什么选择移动端方向？ ✔ 有哪些本地持久化方案 ✔ 为什么放弃转正 ✔ 了解过鸿蒙吗？有实践吗？ ✔ 说一下实践中比较有挑战性的部分 ✔ Vue学习了多久，掌握了多少 ✔ 市面上的AI用过吗？你觉得国内的大语言模型存在哪些问题 ✔ 开放题：你觉得AI在未来可能在哪些领域 ✔ 有哪些企业的Offer 面试官负责的部门是百度APP的技术中台，包括账号相关、SDK、前端、消息中台、交易保障等基础服务 反问哪块比较薄弱，面试官说我移动端的技术栈比较match，实践方面和二面面试官一样，觉得企业级的深度不够。 当场就让我过了，过几天hr会联系。最后面试官说如果她能优选的话，希望我可以去她那个部门。激动","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"虾皮秋招面经","slug":"虾皮秋招面经","date":"2024-10-20T06:49:45.000Z","updated":"2024-11-10T09:26:46.991Z","comments":true,"path":"2024/10/20/虾皮秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/10/20/%E8%99%BE%E7%9A%AE%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"一面 10.19 ✔ 编程题：删除单向链表倒数第n个节点 ✔ Flutter和其他跨平台框架有什么区别？ ❌ AtomaticInteger是如何实现的？ ❌ getStorage持久化存储在本地的文件格式是什么样的？怎么从磁盘中读取的？ ✔ 在主线程中进行IO操作可能出现什么问题（ANR）？在子线程中操作会有吗？ ✔ MMKV和SharedPreferences的区别 ❌ 用protobuf数据协议和SharedPreference的区别 ✔ HTTP协议的常见响应码 ✔ HTTP三个版本之间的区别 ❌ Android中跨进程通信的几种方法，几种方法之间的区别（binder和消息队列） ✔ MQTT基于TCP还是UDP，MQTT的优势 ❌ 用TCP可以做推送吗？还有哪些协议可以推送？ ❌ 图片加载器用过哪些？Image.network源码看过吗？ ✔ Android中的数据库如何使用？ ✔ HashMap和ConcurrentHashMap的区别 ❌ HashMap和LinkedHashMap的区别 ✔ 多线程同时访问HashMap可能会发生什么问题？ ✔ Java中sleep()和wait()的区别 ✔ 悲观锁和乐观锁 ✔ 项目中用拦截器做了什么 ❌ 自己的项目中token有几级，多久过期 ✔ 项目中的基于拓展方法做屏幕适配 ✔ HTTPS加密过程，为什么要混合加密 ❌ 如何知道服务器发来的证书是合法的？ 反问，可以再加强算法数据结构、网络、操作系统，一些常问的问题。 二面 10.26场景拷打穿插八股，逮着简历上写的一个下载器问，问的很细。 面试官没开摄像头，上来就问我实习公司的规模，是不是去的外包公司，我直接？？？ 而且很多时候感觉她没理解我说的东西，问的一些问题也奇奇怪怪的，我之前的回答都说了，结果又问一遍。面试体验不太好。 ✔ 为什么放弃转正？ ❌ 下载器的设计架构？用了什么设计模式 ✔ 单例如何保证对象只被创建一次 ✔ volatile的功能 ✔ 什么是线程和进程 ❌ Flutter下载没有用到多线程，是如何让主线程不卡死的？ ✔ 实现一个安卓的下载管理器怎么做 ✔ 下载完成是如何通知主线程的？ ❌ CPU是如何调度线程和进程的？调度算法？ ❌ 进程切换开销比线程切换开销大的原因 ❌ 死锁条件 ✔ 有哪些锁 ✔ 使用自旋锁的场景，有什么优点和缺点？如何避免缺点 ❌ 用过哪些设计模式？工厂模式的应用场景和设计理念？ ✔ HTTPS相关？如何确认证书的合法性？ ❌ HTTPS一定安全吗？是否有漏洞？ ❌ 抓包原理？如何抓HTTPS ✔ 网络请求涉及的整个流程 ❌ DNS会带来哪些问题？DNS劫持是怎么做到的？如何解决？ ❌ 如何提升HTTPS请求速度 ❌ 多路复用的原理 ✔ HTTP2.0 和 HTTP3.0 的区别 ❌ HTTP3.0 QUIC为什么更快？如何实现可靠性的 ✔ 下载器缓存策略，如何做本地持久化 ❌ 图片加载缓存原理，LRU，如何实现图片缓存，用什么数据结构？ ✔ 哈希表原理 ❌ Android中解决哈希冲突的方法 难度挺大，出现了好多之前没问过的，像线程调度、HTTPS抓包、DNS劫持、LRU。 已挂。 一面 11.9 iOS之前随手投的iOS开发，居然发笔试了，做完又给面试了。 ✔ 对iOS方向怎么想 ✔ 为什么选Flutter而不是其他跨端框架 ❌ Flutter的劣势？RN的优势？ ❌ MQTT订阅发布步骤？为什么MQTT比HTTP更稳定 ❌ TCP和UDP的区别 ❌ 多路复用是什么 ✔ 基于流和基于报文的区别 ❌ 接收方如何知道发送方流数据的总大小？如何知道从哪一位字节开始？ ✔ 有直接用TCP实现过连接吗 ✔ 端口是什么？服务器和客户端的端口分别有什么用？ ✔ 除HTTP、MQTT外其他的建立连接的方式 ❌ 服务器如何主动给客户端推送消息？ ✔ MMKV的优势 ❌ 了解过mmap吗？ ✔ DNS ❌ HTTPS抓包 ✔ HTTPS加密过程 ❌ 如何判断证书是否合法 ✔ 进程和线程的区别 ✔ 哪些部分是线程私有的？哪些是线程共享的？ ❌ 线程间通信的方法 ✔ 消息队列如何实现进程间通信 ✔ 什么是管道，常见的管道，Linux中的管道符| ✔ 线程安全，有哪些锁 ✔ 编程题：手写快排 反问：无iOS经验影响大吗？ 答：没什么影响，受限于设备原因大部分校招生都没啥iOS的经验。 反问：哪部分比较薄弱？ 答：计网的一些细节，某些特性是属于TCP还是HTTP有些记混了，MMKV原理和mmap可以去了解","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"阿里淘天秋招面经","slug":"阿里淘天秋招面经","date":"2024-10-20T06:20:16.000Z","updated":"2024-10-20T06:39:28.661Z","comments":true,"path":"2024/10/20/阿里淘天秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/10/20/%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"一面 10.17 1688部门45分钟左右。 ✔ Android和Flutter的区别 ✔ 编程题：用数组实现栈 ✔ 编程题：两个线程交替打印 ✔ Java中锁的类型 ❌ AtomaticInteger是如何实现的？ ✔ 如何自定义View ✔ 如何用RecyclerView实现一个数据列表？有哪些关键方法？ ❌ 如何用RecyclerView实现每个列表项不一样的布局？RecyclerView的源码看过吗 ✔ 如何用RecyclerView实现一个数据列表？有哪些关键方法？ ❌ 下载器断点续传、并发下载如何实现？ 最后反问觉得哪块比较薄弱，面试官说都还好，许愿过。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"Android中的View","slug":"Android中的View","date":"2024-10-16T16:37:03.000Z","updated":"2024-10-16T19:23:22.081Z","comments":true,"path":"2024/10/17/Android中的View/","link":"","permalink":"http://princesaoke.github.io/2024/10/17/Android%E4%B8%AD%E7%9A%84View/","excerpt":"","text":"Android自定义View的基石——View工作原理总结 Android中View的更新方法：invalidate()和requestLayout() Activity创建View DecorView下是一个竖直方向的LinearLayout，包含一个id为android.R.id.content的子View，在Activity的onCreate()中调用setContentView()就是设置这个contentView。 Activity的onCreate()方法调用之前，创建Window（PhoneWindow）Activity的onCreate方法中调用setContentView()方法，创建DecorView和contentView，将指定的布局文件加载到contentView中Activity的onResume方法调用之后，将DecorView添加到Window中，之后依次开始View的measure、layout和draw流程 三大流程performTraversals()方法内会依次调用measureHierarchy()、performLayout()、performDraw()，进而开始View的三大流程：测量measure、布局layout、绘制draw measuremeasure流程的作用是对View的大小进行测量。 MeasureSpec类，由一个32位int值表示，高2位表示SpecMode（测量模式），低30位表示SpecSize（测量尺寸大小），通过位运算实现。 三种测量模式： UNSPECIFIED：父View不会限制子View的大小，一般用于系统内部，开发中使用很少 EXACTLY：父View能够确定子View的大小，如match_parent或给定精确尺寸（dp或px） AT_MOST：子View的大小不能超过父View尺寸，具体尺寸需要由子View自身来确定，对应wrap_content 确定View尺寸的方法： 当子View的LayoutParams指定为精确数值时，不管父View的测量模式是什么，子View的测量模式均为EXACTLY，测量尺寸为LayoutParams指定的值 当子View的LayoutParams指定为match_parent时，子View的测量模式取决于父View，即如果父View的测量模式为EXACTLY，那么子View的测量模式为EXACTLY；如果父View的测量模式为AT_MOST，那么子View的测量模式为AT_MOST，子View的测量尺寸均为父View可用空间大小 当子View的LayoutParams指定为wrap_content时，不管父View的测量模式是什么，子View的测量模式均为AT_MOST，测量尺寸为父View可用空间大小 对于最顶层的DecorView： DecorView的LayoutParams指定为MATCH_PARENT时，它的测量模式为EXACTLY，测量尺寸为屏幕尺寸 DecorView的LayoutParams指定为WRAP_CONTENT时，它的测量模式为WRAP_CONTENT，测量尺寸为屏幕尺寸 View的measure流程： ViewGroup的measure流程： ViewGroup中并没有重写onMeasure()方法，因为每个ViewGroup的布局方式都不一样，无法得出一个统一的实现方式，需要不同ViewGroup自己去实现。 遍历子View，获取每个子View的MeasureSpec，然后调用每个子View的measure()方法进行测量。再根据子View的测量结果对ViewGroup自身进行测量。 layoutlayout的作用是根据测量大小确定View的最终位置。 layout()方法中比较left、right、top、bottom是否改变，若改变则执行onLayout()。对于单一的View，onLayout()中不做任何事。对于ViewGroup，调用抽象的onLayout()方法（同样需要子类自己去实现），遍历子View并调用其layout()方法确定位置，不断递归。 drawdraw的作用是将View绘制到屏幕上。 调用drawBackground()方法绘制背景 调用onDraw()方法绘制自身内容 调用dispatchDraw()方法绘制子View 调用onDrawForeground()方法绘制装饰，包括滚动条和前景 其中onDraw()是抽象方法，需要不同的View自己去实现绘制方式。 在单一的View中dispatchDraw()是空方法，ViewGroup则实现了其逻辑，遍历所有的子View并调用其draw()方法。 invalidate、postInvalidate 与 requestLayout三者都是View中的方法，用于刷新视图，最终都会调用ViewRootImpl的performTraversals()方法。 invalidate不会执行measure和layout流程，只执行draw流程。 invalidate与requestLayout都必须在主线程调用，要在子线程中刷新视图用postInvalidate方法 调用View的invalidate()方法后会逐级调用父View的方法，最终导致ViewRootImpl的scheduleTraversals()方法被调用，进而调用performTraversals()方法。由于mLayoutRequested的值为false，因此不会执行measure和layout流程，只执行draw流程。 draw流程的执行过程和是否开启硬件加速有关。如果关闭了硬件加速，从DecorView开始的所有View都会重新完成绘制。如果开启了硬件加速，只有调用invalidate()方法的View（包括它的子View）会完成重新绘制。由此也可以看出，开启硬件加速确实可以提高重绘的效率。 postInvalidate其实就是通过Handler完成了线程的切换，使得invalidate()方法在主线程中被调用。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"美团客户端秋招面经","slug":"美团客户端秋招面经","date":"2024-09-29T04:03:22.000Z","updated":"2024-10-22T07:26:43.031Z","comments":true,"path":"2024/09/29/美团客户端秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/09/29/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"和暑期实习一样的岗位。 美团客户端实习面经 笔试 9.21和暑期实习一样，两个小时。30道选择题，共60分；2道编程题，共40分。 前端岗位和客户端岗位考的是同一场，选择题考了挺多JavaScript，还有一些CSS 选择题 JS的Promise，then的执行顺序，事件循环相关 CSS属性，计算元素宽度 死锁的必要条件 面向对象特性 TCP传输相关 const let var 创建型设计模式 单例 编译原理相关，文法推导 数据结构相关，完全二叉树的节点个数范围，堆最多和最少的节点数 编程题第一题比较简单，AC，题目大致是： 每次在数组中的任意下标那一格涂色，若某个范围内涂色数量大于未涂色数量，则下一次可以把该范围全部涂色。问：给出数组的长度，至少要多少次才能全部涂色？ 最快的情况当然是迅速按范围涂色，由于是要大于才能把范围全部涂色，因此前三次涂色都是每次涂一格。第四次涂色，最多能涂小于3的最大值即2个，第五次能涂小于5的最大值即4个，数列就是：1，2，3，5，9，17……。从2开始，n + 1 = 2 * n - 1。 第二题： 做的时候已经有思路了，但是时间来不及细细斟酌代码了。 一个长度为m的数组，每个格子中是一个链表，所有标签相同的物品都放在同一格中。这里需要遍历一次物品标签。 一个长度为m的数组match用于保存该位置的标签应该贴在哪个物品上。记标签匹配为good，不匹配为bad。对于一个链表中标签相同的物品，计算最高美观值的步骤：先把所有bad的美观值累加，要得出不同标签匹配的情况的美观值，只要把bad累加 - 自己的bad值 + 自己的good值，再用打擂台的方法得到美观值最高的贴法，对应贴的序号填入数组match。 知道每个出现的标签应该贴在哪，剩下就简单了。遍历物品，只要判断match中贴的不是自己，如果是，在合计中加上good值，不是就加上bad值。 一面 9.27 核心本地商业-美团平台一小时左右。 ✔ 自我介绍？学习过哪些编程语言？通过什么方式？打算从事哪些技术栈？ ❌ 批量下载用Android怎么实现？线程池有了解吗？ ✔ 简单介绍MQTT ❌ MQTT和HTTP底层有什么区别？如何用Android写一个推送？ ✔ 如何解决Flutter组件多层嵌套的问题？ ✔ 如何防止XSS攻击？ ✔ 数据库如何存储密码？MD5如何校验密码？哈希算法如何保证密码不被知晓？彩虹表破解？ ✔ JSON数据的value可以有哪些数据类型？ ✔ 链表和数组的区别？ ✔ 面向对象三大特性，分别讲一下 ✔ 静态变量和非静态变量的区别？静态变量什么时候分配内存的？ ❌ 什么是内存泄漏？如何排查？例举Android中常见的内存泄漏？ ✔ 发送HTTP请求时要填哪些参数？请求头、请求方法、响应字段 ✔ HTTP、TCP分别是哪一层的协议 ✔ HTTPS为什么安全？SSL的过程 ❌ 客户端如何判断服务端的证书是合法的？客户端如何知道证书被中间人篡改了？ ✔ TCP三次握手过程，为什么要三次？ ✔ 进程和线程的区别 ❌ 两个线程如何通信？Android子线程与主线程的通信，子线程如何通知主线程刷新UI ❌ 进程间如何通信？用代码如何实现？ ✔ 编程题：合并两个有序链表 ❌ 编程题：代码实现死锁 ✔ 同步和异步的区别 问的还算简单，结尾直接约了二面在当天。不过二面面试官没空，推到第三天了。激动 二面 9.29 核心本地商业-美团平台40分钟左右。 ✔ 有什么想补充的？打算做哪方面技术栈？ ✔ Flutter的优点 ❌ 结合底层机制、编译原理、程序运行，Flutter是如何从Dart源码到应用程序并运行的？ ❌ 结合Flutter和前端在布局渲染方面的共同点，界面是如何渲染显示的？canvas相关 ❌ 结合编译原理，非页面的代码，业务逻辑代码是怎么运行的？如发一个网络请求。源码如何在设备上运行起来？Dart语言的编译流程？ ✔ Java的编译流程？JVM起到什么作用？ ✔ 为了让程序运行，JVM需要做什么事？ ✔ 用C语言和Java的区别？ ✔ 面向过程和面向对象各自的特点 ✔ 学习了哪些专业课程？在实际开发中用到了哪些？ ✔ 在业务开发中不同的网络协议如何做选择？ ✔ 数据结构与算法在实际开发中的应用？有哪些常用的数据结构 ❌ 数据超出数组长度如何处理？如何扩容？ 感觉面试官很想问我dart和Flutter底层的运行原理，可惜确实不了解。 9.30已挂。差点以为好运来了，呜呜呜 一面 10.11 软硬件服务-骑行事业部被捞了。一小时左右。 ✔ 自我介绍，介绍项目、实习 ✔ 进程和线程的区别 ✔ Java中的几种锁 ✔ 进程通信的几种方式 ✔ 对象锁和类锁的区别 ✔ OSI七层网络模型，传输层的协议 ✔ TCP和UDP的区别 ✔ HTTP基于哪个传输层协议，有哪些版本，3.0基于TCP还是UDP，各版本的区别 ✔ HTTPS加密过程，为什么要混合加密？ ✔ 四种引用方式与区别 ❌ 软弱虚引用的使用场景 ✔ 浅拷贝和深拷贝 ✔ HashMap原理，链表和红黑树转换的阈值，ConcurrentHashMap如何保证线程安全 ❌ Java8前后的ConcurrentHashMap实现方式的区别 ✔ volatile关键字的作用 ✔ Java中类的加载机制 ❌ 类加载器有哪几种 ❌ Android中的handler消息机制 ❌ 四大组件的作用 ❌ Activity、Service、BroadcastReceiver什么情况下会出现ANR ✔ Activity的启动模式 ❌ ListView和RecyclerView的区别 ✔ RecyclerView四级缓存机制 ❌ 如何计算和屏幕一样大小的图片的占用内存 ❌ Android的事件分发机制 ✔ 编程题：分层输出二叉树的层序遍历 开头问了一下实习，可能是觉得没什么好聊的，转而问八股了。之前面美团基本只问了八股没怎么问Android，这次一问，好多都没答上来。 最后手撕环节，层序遍历用队列一气呵成写完，面试官要求分层输出，和刚刚的小黑盒一面的代码题一模一样，但是没有去看。看的出来面试官很想让我过，一直在提示我，但是始终没有get到点，好在最后用自己的方法也是做出来了，被自己蠢哭。 反问的时候问了面试官自己有哪些薄弱点，面试官说我Android相关的需要再更深入了解，手撕代码有待加强。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"计算机网络","slug":"计算机网络","date":"2024-09-27T01:23:39.000Z","updated":"2024-11-13T09:14:07.845Z","comments":true,"path":"2024/09/27/计算机网络/","link":"","permalink":"http://princesaoke.github.io/2024/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"一文吃透TCP面试八股文 TCP&#x2F;IP协议之传输层：TCP&#x2F;UDP协议详解（一） HTTP 和 HTTPS 的区别（面试常考题） http请求中get和post方法的区别 TCP，全称Transport Controll Protocol，传输控制协议。 UDP，全称User Data Protocol，用户数据报协议。 OSI七层网络模型、TCP&#x2F;IP四层模型、TCP&#x2F;IP五层模型OSI七层网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 TCP&#x2F;IP四层模型：应用层、传输层、网络层、网络接口层 TCP&#x2F;IP五层模型：应用层、传输层、网络层、数据链路层、物理层 TCP、UDP位于哪一层二者都是传输层协议。 TCP 与 UDP 的区别 TCP是面向连接的，UDP是无连接的 TCP是可靠的，UDP是不可靠的 TCP有拥塞控制机制，UDP没有 TCP是面向字节流的，UDP是面向数据报文的 TCP只支持点对点通信，UDP支持一对一，一对多，多对多 TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区 TCP报文首部不同，TCP首部20个字节，UDP首部8个字节 TCP如何保证可靠性 数据包校验防止发送过来的数据是错误数据 确认序列号，对失序报文进行重排 丢弃重复数据包，防止数据冗余重复 确认应答机制，接收方接受数据之后会发送一个确认 超时重传机制，发送方发出数据后会启动一个定时器，超过该定时器时间依旧未收到对方确认，便会重新发送该数据 流量控制确保接收方收到的数据在自身缓冲区中不会溢出 拥塞控制，保证数据在网络中传播的可靠性，降低丢包的概率，提高TCP的可靠性 TCP 和 UDP 各自的适用场景对实时性要求比较高，且允许数据丢失的情况，选择UDP，比如实时视频通话、游戏。 不允许数据丢失，及大多数情况适用TCP。 报文格式UDP报文： TCP报文： TCP 和 UDP 分别对应的常见应用层协议基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH 基于UDP的应用层协议：DNS、TFTP、SNMP HTTP1.0 和 HTTP2.0 的区别 长连接，Connection: Keep-Alive，以便其他请求复用，只要任意一端没有明确提出断开连接，则保持TCP连接状态 多路复用 HTTP1.0 基于文本格式，而 HTTP2.0 基于二进制格式 头部压缩 HTTP 和 HTTPS 的区别 HTTP是明文传输，HTTPS使用SSL加密传输 HTTP在三次握手后即可传输报文，而HTTPS三次握手后还要进行SSL握手 HTTP端口是80，HTTPS端口是443 SSL通过先非对称加密的方式传输密钥，再用密钥对传输数据进行对称加密，来解决窃听风险。之所以要两种加密方式混用，是因为对称加密比非对称加密要快，因此数据传输使用对称加密，而非对称加密可以实现交换密钥。 客户端如何校验证书合法性 发送端数字证书分为两部分，一部分是公钥等信息，另一部分是数字签名。将第一部分的信息通过哈希算法计算出哈希值，再用私钥加密，即是数字签名。 客户端收到证书后，根据公钥解密数字签名得到哈希值，再与自己计算的哈希值比较，相同则说明合法。 由于中间人无法得知私钥，即便篡改了证书也无法修改正确的哈希值，因此无法伪造。 HTTPS抓包其实就是中间人攻击的原理。需要将抓包用的证书添加到浏览器，作为中间人。 GET 和 POST 的区别 GET用于获取资源、读取数据；POST用于修改和写入数据 GET把参数包含在URL中，POST通过request body传递参数，因此POST能发送的数据更大，GET有URL长度限制 POST多几个首部字段，如content-type，POST能发送更多数据类型，GET只能发送ASCII字符 GET会将静态资源缓存起来，POST不会，因此POST更安全 POST在真正接收数据之前会先将请求头发送给服务器进行确认，服务器返回100 Continue响应，然后才真正发送数据，因此GET比POST快 常见请求头和响应头 请求头 说明 示例 Accept 指示客户端可以接受的内容类型，例如text&#x2F;html，application&#x2F;json等 Accept-Charset 可接受的字符编码类型 Accept-Charset: utf-8 Connection 客户端（浏览器）想要优先使用的连接类型 Connection: keep-alive Cookie Content-Length 以8进制表示的请求体的长度 Content-Length: 348 Content-Type Content-Type: application&#x2F;x-www-form-urlencoded Host 服务器的域名以及服务器所监听的端口号 Host: www.baidu.com:80 User-Agent 浏览器的身份标识字符串 User-Agent: Mozilla 响应头 说明 示例 Access-Control-Allow-Origin 指定哪些网站可以跨域源资源共享 Access-Control-Allow-Origin: * Content-Length 响应消息体的长度，用8进制字节表示 Content-Length: 348 Date 此条消息被发送时的日期和时间 Date: Tue, 15 Nov 1994 08:12:31 GMT Last-Modified 所请求的对象的最后修改日期 Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT Set-Cookie 用于在客户端设置 Cookie，通常用于会话管理或跟踪用户状态 FTP 和 SFTP 的区别FTP，File Transfer Protocol，文件传输协议 SFTP，Secure File Transfer Protocol，安全文件传输协议 SFTP通过提供加密的连接和安全的数据传输来提高安全性，而FTP的安全性较低 FTP使用TCP&#x2F;IP协议，而SFTP是SSH协议的一部分 FTP使用21端口，而SFTP通过SSH协议的22端口 MQTT 和 HTTP 的区别 MQTT以数据为中心，而HTTP是以文档为中心的 MQTT生成的消息大小较小，因为它使用二进制格式。HTTP生成的消息大小更大，因为它使用ASCII格式 MQTT是轻量级和发布&#x2F;订阅模型，HTTP是基于请求&#x2F;响应模型","categories":[{"name":"计网","slug":"计网","permalink":"http://princesaoke.github.io/categories/%E8%AE%A1%E7%BD%91/"}],"tags":[]},{"title":"字节跳动Android秋招面经","slug":"字节跳动Android秋招面经","date":"2024-09-24T14:59:43.000Z","updated":"2024-10-09T09:06:03.161Z","comments":true,"path":"2024/09/24/字节跳动Android秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/09/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"无笔试，直接约一面。飞书部门。 一面 9.24一小时左右。 ✔ 自我介绍 ✔ 谈实习，说一下难点和解决方法 ❌ flutter或Android中的手势消费原理 ❌ flutter是如何生成一个安卓应用的 ✔ flutter渲染原理，三棵树 ❌ flutter的桥，调用native能力，如调用相机 ✔ 线程和进程的区别 ❌ 多线程相关，线程间哪些是共享的？进程间哪些是共享的？ ❌ 什么是线程安全，如何保证线程安全 ✔ Java的基本数据类型与包装类型有哪些？二者有什么区别？ ❌ 深拷贝和浅拷贝的区别？具体是如何copy的？ ✔ 链表和哈希表的区别，适用场景 ✔ HashMap实现原理，若用对象作为键，修改对象的属性，获取到的值会改变吗 ❌ requestlayout 和 invalidate 的区别 ❌ RecyclerView是如何展示列表数据的？notifyItemChanged局部刷新列表数据，其他局部刷新的方法 ✔ MMKV的使用，相对 SharedPreferences 的优点 ❌ TCP和UDP的区别，TCP的可靠传输是怎么实现的？ ❌ 2G的单词，给100M空间，如何知道出现频率top10的单词？ ✔ flutter对比原生安卓的优劣势 ❌ flutter用的布局模型是什么 ❌ 编程题：输出二叉树的后序遍历（不用递归） 计网基础还是不熟悉。问了一些安卓相关的也没答上来。 java在虚拟机中除了线程计数器、jvm栈和方法栈是线程私有的，其余的java堆、方法区、和运行时常量池都是线程共享的内存区域。 9.25已挂 T^T","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"小红书Android秋招面经","slug":"小红书Android秋招面经","date":"2024-09-22T09:02:16.000Z","updated":"2024-09-22T10:42:08.374Z","comments":true,"path":"2024/09/22/小红书Android秋招面经/","link":"","permalink":"http://princesaoke.github.io/2024/09/22/%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"笔试 9.2220道选择题，共40分；3道编程题，共60分。 选择题 Android中给View添加点击事件的方法 URL为http://xxx.com/user/login.do，是什么方法的请求？ 哪些情况会造成ANR 不用四大组件中哪个不用Intent启动 SharedPreferences的文件存储路径，SharedPreferences数据读写方法过程 银行家算法，判断哪个顺序不会死锁 合法的出栈顺序 给出排序的中间状态，判断是哪种排序，归并 TCP、UDP的特点与区别 编程题偏难。 第一题：给定一个整数数组和一个整数x，将数组分成连续的任意份，要满足每份的乘积都不能是x的倍数，且数组中每个元素都不是x的倍数。问最少需要分多少份？ 有思路，但不知为何只对了18%，小红书的判题器不会给出没通过的测试数据。 分的要尽可能少，则每一份要尽可能大。由于是连续的，可以从头开始看。当乘积变成x的倍数后，无论之后再乘上什么数都仍是x的倍数，因此当乘积变成倍数时就要分了。 定义一个curr记录乘积，初始值为数组第一个元素，从第二个元素开始遍历数组。若乘积对x求模不为0，则curr = curr * a[i]；否则，将结果count加一，同时curr = a[i]。遍历结束后，最后一组还要再count加一，输出count。 第二题：给定收藏夹数n和整数x，接下来n行给出每个收藏夹内所有文章的标签，每个收藏夹内标签的数量可能不同，标签可能重复。现在要找出两个收藏夹，满足二者标签种类刚好为x。有满足则输出YES和收藏夹编号，无满足则输出NO。 有思路，但只对了83%。 定义一个vector&lt;vector&lt;string&gt;&gt;用于存储所有收藏夹及其内部的标签。双重循环遍历0 &lt;= i &lt; n - 1)与i + 1 &lt;= j &lt; n，每次循环定义一个集合用于标签去重，将两收藏夹的标签全部加入集合，判断集合大小是否等于x。 第三题：给出n条直线，接下来n行，每行给出直线斜率k和截距b，k不为0。问x&gt;0的交点有几个？ 没时间写了。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"Java中的HashMap","slug":"Java中的HashMap","date":"2024-07-26T15:30:21.000Z","updated":"2024-08-19T08:52:46.934Z","comments":true,"path":"2024/07/26/Java中的HashMap/","link":"","permalink":"http://princesaoke.github.io/2024/07/26/Java%E4%B8%AD%E7%9A%84HashMap/","excerpt":"","text":"为啥HashMap的默认容量是16？ 实现原理HashMap用于存储键值对，内部为散列表，每个数组槽位是一个链表或红黑树，即类似桶排序的结构。 当调用HashMap的put方法新增键值对时，会根据HashMap类的静态方法hash，用键值对的键来计算出哈希值，并用(散列表大小n - 1) &amp; hash的值作为散列表数组下标，将新增的键值对放入。 为解决哈希碰撞，每个散列表数组槽位内是一个链表或红黑树。当链表长度大于8，且散列表数组长度大于等64时，链表转化为红黑树；当红黑树节点小于6时退化成链表。 来说计算哈希值的hashCode方法。当键不为null时，将键的hashCode方法的值，和自身右移16位的值进行异或，结果作为计算后的哈希值返回。键为空则结果为0。 再来说说(n - 1) &amp; hash这个式子。其实就等同于hash的值对散列表长度n求模：hash % n。这样能确保计算出的哈希值不会超出散列表下标范围。 这里使用与运算&amp;而不是模运算，是因为位运算是直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。 且：$$ x &#x2F; 2^n &#x3D; x &gt;&gt;&gt; n $$$$ x % 2^n &#x3D; x &amp; (2^n - 1) $$ 当除数是2的n次方时，x除的结果就等于二进制直接右移n位，模的结果就等于x和除数减一的二进制进行与运算。 例：$ 21 &#x2F; 8 $ 和 $ 21 % 8 $ 21的二进制：10101， 8的二进制：01000， 7的二进制：00111 $ 21 &#x2F; 8 &#x3D; 21右移三位 &#x3D; 00010 &#x3D; 2 $ ， $ 21 % 8 &#x3D; 21 &amp; 7 &#x3D; 00101 &#x3D; 5 $ 扩容机制虽然解决了哈希碰撞的问题，但若散列表太小，键值对太多，频繁出现哈希碰撞，链表或红黑树就会变得很长，此时就需要对散列表扩容。 前面提到，键值对放在散列表中的哪个位置，是由(散列表大小n - 1) &amp; hash决定的，与散列表大小有关。现在散列表大小改变了，意味着键值对存放的位置可能发生改变，要计算出扩容后所有键值对的新位置。 JDK1.7 中的做法是每个键值对重新hash映射到新的散列表，在 JDK1.8 进行了改进： 根据之前的结论，散列表长度必须是 $ 2^n $ ，每次扩容为之前的两倍。这样的好处是，扩容后计算(n - 1) &amp; hash，有变化的只有扩容前的n那一位。 例：原本散列表长度为8，下标为2处有一键值对，现长度扩容为16 8-1的二进制为00111，16-1的二进制为01111 则对于(n - 1) &amp; hash，原先的值就是下标2，即00010，说明hash为??010，扩容后的值应该为0?010。 若?为0，则扩容后位置也不变，无需迁移。若?为1，则扩容后的新位置就是原先的下标加上扩容前的散列表长度。 HashMap 和 Hashtable 的区别 父类不同：HashMap继承抽象类AbstractMap；而Hashtable实现Dictionary类。二者都实现Map接口 线程安全不同：Hashtable是线程安全的，而HashMap不是 能否有null：Hashtable中key和value都不允许出现null；而HashMap允许有一个为null的key，value可以有多个null，因此不能用get()返回null来判断HashMap中是否有某个键 哈希值的使用不同：Hashtable直接使用对象的hashCode；而HashMap重新计算哈希值 扩容方式不同：HashMap内散列表默认大小为16，扩容后一定为2n；Hashtable初始大小为11，扩容方式为old * 2 + 1","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"}]},{"title":"Java中的类加载机制","slug":"Java中的类加载机制","date":"2024-07-20T16:11:09.000Z","updated":"2024-10-30T07:27:48.135Z","comments":true,"path":"2024/07/21/Java中的类加载机制/","link":"","permalink":"http://princesaoke.github.io/2024/07/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Java类加载机制分为五步：加载、验证、准备、解析、初始化。 加载：通过类全名获取类的二进制流，装入方法区，生成Class对象 验证：验证二进制流是否符合格式 准备：为类的静态变量划分空间 解析：将常量池内的符号引用转化为直接引用 初始化：执行静态代码块，为静态变量赋初值 几种类加载器： 启动类加载器 拓展类加载器 应用类加载器 自定义类加载器 双亲委派机制核心思想是，当类加载器要加载一个类时，会先将加载任务委托给父类加载器，这个过程会一直递归直到最顶层的启动类加载器。只有当父类加载器无法完成加载任务时，才由子类加载器执行。 优点： 避免类的重复加载 防止核心API被注入篡改，已经被加载过的类不会重复加载，避免了被篡改注入恶意代码的类被加载 Java中的staticJava中的static关键字解析 静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象。既然没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。 我们最常见的static方法就是main方法，而main方法必须是static的，是因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。 Java规定static不能用来修饰局部变量。 与C&#x2F;C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域 1234567891011public class Main &#123; public static void main(String[] args) &#123; Person.name = &quot;张三&quot;; Person.age = 18; // 报错 &#125;&#125;class Person &#123; public static String name; private static int age;&#125; Q：Java中可以通过this访问静态成员变量吗？下面的代码输出是什么？ 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Test test = new Test(); test.printValue(); &#125; static int value = 0; private void printValue() &#123; int value = 1; // 该value只是函数内部的局部变量，与this无关 System.out.println(this.value); // 访问的是静态成员变量value &#125;&#125; A：可以，输出为0。 Q：以下代码输出是什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Father &#123; public static void main(String[] args) &#123; System.out.println(&quot;Father中的main函数&quot;); new Son(); &#125; Other other = new Other(&quot;Father&quot;); static &#123; System.out.println(&quot;Father中的静态代码块1&quot;); &#125; static &#123; System.out.println(&quot;Father中的静态代码块2&quot;); &#125; &#123; System.out.println(&quot;Father中的非静态代码块&quot;); &#125; public Father() &#123; System.out.println(&quot;Father中的构造函数&quot;); &#125;&#125;public class Son extends Father &#123; Other other = new Other(&quot;Son&quot;); static &#123; System.out.println(&quot;Son中的静态代码块&quot;); &#125; public Son() &#123; System.out.println(&quot;Son中的构造函数&quot;); &#125;&#125;public class Other &#123; static &#123; System.out.println(&quot;Other中的静态代码块&quot;); &#125; public Other(String str) &#123; System.out.println(&quot;Other中的构造函数，调用者：&quot; + str); &#125; &#123; System.out.println(&quot;Other中的非静态代码块&quot;); &#125;&#125; A：输出为 123456789101112Father中的静态代码块1Father中的静态代码块2Father中的main函数Son中的静态代码块Other中的静态代码块Other中的非静态代码块Other中的构造函数，调用者：FatherFather中的非静态代码块Father中的构造函数Other中的非静态代码块Other中的构造函数，调用者：SonSon中的构造函数 要运行静态函数main，首先要加载Father类。加载Father类时按顺序执行static块，输出前两行。 随后执行main函数，输出第三行。 再实例化Son。实例化前要先加载Son类，又因Son继承Father，则要先加载Father和Son，而Father已经加载了，于是加载Son，执行Son中的static块，输出第四行。 接着要实例化Son，在构造函数前要先初始化成员变量。因为继承Father所以要先初始化Father，Father有个Other类型的成员变量和一个非static块，按照先后顺序执行，又需要先加载并实例化Other。 于是加载Other，static块输出第五行。Other的非static块输出第六行，构造函数输出第七行。 接着Father初始化完成员变量继续按顺序执行非static块，输出第八行。 现在Son的父类Father成员变量已经初始化，于是Father的构造函数输出第九行。 Son的父类结束，轮到Son初始化成员变量，非static块每次实例化一个对象都会执行一次，因此Other的非static块再次执行输出第十行。其构造函数再输出第十一行。 最后Son的构造函数输出最后一行。Son实例化结束，main函数结束。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"}]},{"title":"Flutter笔记","slug":"Flutter笔记","date":"2024-07-10T01:17:26.000Z","updated":"2024-11-09T14:08:58.390Z","comments":true,"path":"2024/07/10/Flutter笔记/","link":"","permalink":"http://princesaoke.github.io/2024/07/10/Flutter%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Flutter与其他跨平台方案的区别ReactNative之类的框架，只是通过JavaScript虚拟机扩展调用系统组件，由Android和iOS系统进行组件的渲染；Flutter则是自己实现了一套组件渲染的逻辑。 Flutter的底层图像渲染引擎是Skia（它同时也是Android官方的图像渲染引擎）。Skia 是一款用 C++ 开发的、性能彪悍的 2D 图像绘制引擎，因为其出色的绘制表现被广泛应用在 Chrome 和 Android 等核心产品上。Skia 在图形转换、文字渲染、位图渲染方面都表现卓越，并提供了开发者友好的 API。Skia 已经是 Android 官方的图像渲染引擎了，因此 Flutter Android SDK 无需内嵌 Skia 引擎就可以获得天然的 Skia 支持；而对于 iOS 平台来说，由于 Skia 是跨平台的，因此它作为 Flutter iOS 渲染引擎被嵌入到 Flutter 的 iOS SDK 中，替代了 iOS 闭源的 Core Graphics&#x2F;Core Animation&#x2F;Core Text，这也正是 Flutter iOS SDK 打包的 App 包体积比 Android 要大一些的原因。Skia 保证了同一套代码调用在 Android 和 iOS 平台上的渲染效果是完全一致的。 StatefulWidget生命周期Stateful 组件的生命周期​ createState：执行完毕后表示当前组件已经在组件树中 initState：只会被调用一次，在其中进行初始化操作，如加载网络数据、添加监听器等 didChangeDependencies：在initState后或其所依赖的InheritedWidget发生变化时调用 build：在标脏后的下一帧被调用 didUpdateWidget：当组件的configuration发生变化时调用此函数 deactivate：当框架从树中移除此State对象时将会调用此方法，deactivate后还可以重新插入到树中 dispose：当框架从树中永久移除此State对象时将会调用此方法，在其中释放相关资源","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Java中的String","slug":"Java中的String","date":"2024-06-25T15:01:34.000Z","updated":"2024-07-25T08:38:51.570Z","comments":true,"path":"2024/06/25/Java中的String/","link":"","permalink":"http://princesaoke.github.io/2024/06/25/Java%E4%B8%AD%E7%9A%84String/","excerpt":"","text":"从零开始学Java之StringBuilder与StringBuffer使用及源码解读 String为什么设计为不可变？如何保证String不可变？一旦一个String对象被创建，其存储的文本内容就不能被改变。这是因为： 让并发编程变得更简单。引起线程安全问题的根本原因在于：多个线程需要同时访问同一个共享资源，修改资源，容易出现问题。如果共享资源在创建之后就完全不再变更，如同一个常量，有修改则返回一个新对象，则可以保证线程安全 不可变的对象因为状态不会改变，所以更容易进行缓存和重用。字符串常量池的出现正是基于这个原因。当代码中出现相同的字符串字面量时，JVM会确保所有的引用都指向常量池中的同一个对象，从而节约内存。 因为String的内容不会改变，所以它的哈希值也就固定不变。这使得String对象特别适合作为HashMap或HashSet等集合的键，因为计算哈希值只需要进行一次，提高了哈希表操作的效率。 保证String不可变的措施： String类内部使用一个私有的字符数组来存储字符串数据。这个字符数组在创建字符串时被初始化，之后不允许被改变。 String类也不提供任何可以修改其内容的公共方法，像concat这些看似修改字符串的操作，实际上都是返回一个新创建的字符串对象，而原始字符串对象保持不变。 String类本身被声明为final，这意味着它不能被继承，防止通过子类添加修改方法来改变字符串内容的可能。 StringBuilder 和 StringBufferStringBuilder和StringBuffer定义的字符串内容可变。 当遇到大量字符串连接时，由于String的不变性，每次都是返回一个新的String对象，因此用StringBuilder更合适，它不会生成很多新的对象，StringBuffer和StringBuilder类似，但每个方法上都加了synchronized关键字，所以是线程安全的。 String：适用于字符串内容不会改变的场景，比如说作为HashMap的key StringBuilder：适用于单线程环境下需要频繁修改字符串内容的场景，比如在循环中拼接或修改字符串，是String的完美替代品 StringBuffer：现在已经不怎么用了，因为一般不会在多线程场景下去频繁的修改字符串内容 StringBuilder和StringBuffer均继承自抽象类AbstractStringBuilder，其append方法最终是调用父类的append： 以StringBuilder为例 而父类的append将字符串放入其字符数组中，同时记录字符数量的count也同步增加。其中ensureCapacityInternal方法是用来确保字符数组能放得下新加的字符串，当数组大小不够时会扩容。 若原有容量oldCapacity小于需要的容量minimumCapacity，就会利用Arrays.copyOf()方法，将当前数组的值拷贝给newCapacity()个长度的新数组，最后再重新赋值给value字节数组。因此是利用数组复制的方法来实现扩容。 newCapacity方法作用是计算出扩容后新数组的长度，若大于整型的最大值则抛出OutOfMemoryError。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"}]},{"title":"Android中的Service","slug":"Android中的Service","date":"2024-06-09T09:21:24.000Z","updated":"2024-06-11T01:00:03.369Z","comments":true,"path":"2024/06/09/Android中的Service/","link":"","permalink":"http://princesaoke.github.io/2024/06/09/Android%E4%B8%AD%E7%9A%84Service/","excerpt":"","text":"Android Studio 中","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"进程、线程和协程","slug":"进程、线程和协程","date":"2024-06-07T09:34:04.000Z","updated":"2024-11-10T09:12:54.380Z","comments":true,"path":"2024/06/07/进程、线程和协程/","link":"","permalink":"http://princesaoke.github.io/2024/06/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"并发和并行并发就是同一时刻只有一条指令在执行，但由于CPU时间片很小，多个指令间能快速切换，宏观上形成同时执行的效果。 并行则是真正意义上的同时进行。 并发三要素 原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 有序性：程序执行的顺序按照代码的先后顺序执行 线程和进程的区别 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 一个进程可以有多个线程，至少有一个主线程 一个进程崩溃后，在保护模式下不会对其他进程产生影响；但一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 Q：为什么进程切换的消耗比线程切换大？ A： 进程拥有独立的内存空间和资源管理机制，每次切换时需要保存和恢复更多的上下文信息；而线程共享同一进程的内存和大部分资源，切换时涉及的上下文信息较少。且进程切换更多发生在内核态，而同一进程内的线程切换更多发生在用户态，因此开销相对较小。 多进程和多线程分别有何优势？ 线程之间可以更轻松的共享数据 系统创建进程需要为该进程重新分配系统资源，故创建线程代价比较小 线程崩溃可能导致整个进程崩溃，而进程崩溃不会影响到另一个进程 哪些是线程共享的？线程共享： 全局变量和堆 文件描述符，包括打开的文件、网络连接、输入输出流等，这些都是进程级别的资源 Q：Java三种创建线程的方法有什么区别？ A： …… Java中锁的类型 悲观锁、乐观锁：悲观锁总是认为其他线程会修改数据，因此每次操作都上锁，如synchronized；乐观锁则假设其他线程不会修改数据，不上锁，如CAS 公平锁、非公平锁：公平锁按申请锁的顺序获取，如ReentrantLock；非公平锁不保证顺序 自旋锁：线程循环等待直到获取锁 可重入锁、不可重入锁：可重入锁允许内层使用锁，不会产生死锁；不可重入锁不允许 共享锁&#x2F;读锁、独享锁&#x2F;写锁：共享锁允许多个执行单元同时获取锁，独享锁只允许一个 线程池Java 多线程：彻底搞懂线程池 ThreadPoolExecutor的参数： 参数名 是否必需 数据类型 说明 corePoolSize 必需 int 线程池的核心线程数 maximumPoolSize 必需 int 线程池的最大线程数 keepAliveTime 必需 long 当线程数大于核心线程数时，多余的空闲线程存活的最长时间 unit 必需 TimeUnit keepAliveTime的时间单位 workQueue 必需 BlockingQueue&lt;Runnable&gt; 决定线程池的任务队列的类型 threadFactory 可选 ThreadFactory 用于指定为线程池创建新线程的方式 handler 可选 RejectedExecutionHandler 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 几种常见的内置线程池","categories":[],"tags":[]},{"title":"Android中的数据持久化","slug":"Android中的数据持久化","date":"2024-05-30T05:51:38.000Z","updated":"2024-06-13T15:01:25.672Z","comments":true,"path":"2024/05/30/Android中的数据持久化/","link":"","permalink":"http://princesaoke.github.io/2024/05/30/Android%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"","text":"可在 Android Studio 打开Device Explorer，在/data/data/&lt;APP包名&gt;中可以看到应用的数据。 SharedPreferences123456789101112131415/// 写数据val editor = getSharedPreferences(&quot;user&quot;, Context.MODE_PRIVATE).edit()editor.putString(&quot;name&quot;, &quot;张三&quot;)editor.putInt(&quot;age&quot;, 18)editor.putBoolean(&quot;married&quot;, false)editor.apply() // 将添加的数据提交，从而完成数据存储操作/// 读数据val prefs = getSharedPreferences(&quot;user&quot;, Context.MODE_PRIVATE)val name = prefs.getString(&quot;name&quot;, &quot;&quot;)val age = prefs.getInt(&quot;age&quot;, 0)val married = prefs.getBoolean(&quot;married&quot;, false)Log.d(&quot;MyLog&quot;, &quot;姓名：$name&quot;)Log.d(&quot;MyLog&quot;, &quot;年龄：$age&quot;)Log.d(&quot;MyLog&quot;, &quot;是否已婚：$married&quot;) 其中getSharedPreferences的第二个参数Context.MODE_PRIVATE表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写，且只有这一种模式，其他几种操作模式均已被废弃。 SharedPreferences文件是使用XML格式来对数据进行管理的： MMKVMMKV Github 仓库 安装引入： 1234dependencies &#123; // 将 &quot;1.3.5&quot; 替换为最新版本 implementation &#x27;com.tencent:mmkv:1.3.5&#x27;&#125; 在APP启动时初始化MMKV，设定MMKV的根目录： 123456789101112131415override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val mmkvPath = MMKV.initialize(this) Log.i(&quot;MyLog&quot;, &quot;MMKV存储路径: $mmkvPath&quot;) val mmkv = MMKV.defaultMMKV() mmkv.encode(&quot;name&quot;, &quot;李四&quot;) mmkv.encode(&quot;age&quot;, 18) mmkv.encode(&quot;married&quot;, false) val name = mmkv.decodeString(&quot;name&quot;) val age = mmkv.decodeInt(&quot;age&quot;) val married = mmkv.decodeBool(&quot;married&quot;, false) // 当数据不存在时，取第二个参数为默认值&#125; Q：MMKV与SharedPreferences有何区别？MMKV的适用场景？ A： …… SQLiteAndroid内置了SQLite数据库，用于本地存储关系复杂的数据。 自定义一个继承SQLiteOpenHelper的类，当调用它的实例的getReadableDatabase或getWritableDatabase方法时，传入数据库名和版本号，就可以打开指定的数据库。若不存在该数据库，则会自动创建，然后触发SQLiteOpenHelper的onCreate方法。若传入的版本号大于数据库的版本号，就会触发onUpgrade方法。 123456789101112131415161718192021222324class MyDatabaseHelper(val context: Context, name: String, version: Int) : SQLiteOpenHelper(context, name, null, version) &#123; private val createBookSql = &quot;&quot;&quot; create table Book ( id integer primary key autoincrement, name text, price real, pages integer ) &quot;&quot;&quot; override fun onCreate(db: SQLiteDatabase) &#123; db.execSQL(createBookSql) Toast.makeText(context, &quot;Book表创建成功&quot;, Toast.LENGTH_SHORT).show() &#125; override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123; &#125;&#125;val dbHelper = MyDatabaseHelper(this, &quot;BookStore.db&quot;, 1)val db = dbHelper.writableDatabase // 无数据库BookStore，则创建数据库，触发onCreate，创建Book表dbHelper = MyDatabaseHelper(this, &quot;BookStore.db&quot;, 2)db = dbHelper.writableDatabase // 打开已有数据库，版本号更新，触发onUpgrade 事务是数据库运行的基本单位。当事务执行成功时，所有对数据库的更新操作都会被提交；事务执行中途失败，那么该事务中所有已经进行的操作都会被撤销，恢复到事务执行前的状态。 以买书为例，买方得到书和卖方失去书必须同时成功或失败，要放在一个事务中： 1234567891011121314151617181920212223val dbHelper = MyDatabaseHelper(this, &quot;BookStore.db&quot;, 1)db.beginTransaction() // 开启事务try &#123; // 即 DELETE FROM Book WHERE name == &quot;第一行代码&quot; db.delete(&quot;Book&quot;, &quot;name == ?&quot;, arrayOf(&quot;第一行代码&quot;)) if (true) &#123; // 模拟事务失败 throw NullPointerException() &#125; val values = ContentValues().apply &#123; put(&quot;name&quot;, &quot;第一行代码&quot;) put(&quot;price&quot;, 50.00) put(&quot;pages&quot;, 810) &#125; db.insert(&quot;Store&quot;, null, values) // 将valus插入Store表中 db.setTransactionSuccessful() // 事务已经执行成功&#125; catch (e: Exception) &#123; e.printStackTrace()&#125; finally &#123; db.endTransaction() // 结束事务&#125; 当事务失败时，beginTransaction到endTransaction之内的逻辑都不会生效 读写文件123456789101112131415161718192021222324252627282930313233/// 写文件fun save(inputText: String) &#123; try &#123; // data为要打开的文件名 // 第二个参数默认为`MODE_PRIVATE`，表示若该文件已存在，则直接覆盖原文件 // `MODE_APPEND`表示若该文件已存在，在原文件基础上追加内容 val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) // use作用是在Lambda表达式完成后关闭外层的流，无需手动关闭 writer.use &#123; it.write(inputText) &#125; &#125; catch (e: IOException) &#123; e.printStackTrace() &#125;&#125;/// 读文件fun load(): String &#123; val content = StringBuilder() try &#123; val input = openFileInput(&quot;data&quot;) val reader = BufferedReader(InputStreamReader(input)) reader.use &#123; reader.forEachLine &#123; content.append(it) &#125; &#125; &#125; catch (e: IOException) &#123; e.printStackTrace() &#125; return content.toString()&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的BroadcastReceiver","slug":"Android中的BroadcastReceiver","date":"2024-05-29T07:11:41.000Z","updated":"2024-05-29T12:31:01.311Z","comments":true,"path":"2024/05/29/Android中的BroadcastReceiver/","link":"","permalink":"http://princesaoke.github.io/2024/05/29/Android%E4%B8%AD%E7%9A%84BroadcastReceiver/","excerpt":"","text":"广播接收在以下路径查询所有的 broadcast actions：&lt;Android SDK 安装目录&gt;/platforms/&lt;Android API 版本&gt;/data。 分为动态注册和静态注册。动态注册将BroadcastReceiver写在Activity中，因此只有APP启动时才能接收广播。静态注册写在Manifest.xml中，APP未启动也能接收广播，但只能接收除隐式广播（没有具体指定发送给哪个应用程序的广播）之外的小部分广播。 动态注册自定义一个继承BroadcastReceiver的类，重写父类的onReceive方法。然后实例化一个IntentFilter，添加要接收的action。最后用registerReceiver方法将自定义类和IntentFilter对象绑定。这样当收到对应action的广播时就会调用onReceive： 1234567891011121314151617181920212223class MainActivity : AppCompatActivity() &#123; lateinit var timeChangeReceiver: TimeChangeReceiver override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;) timeChangeReceiver = TimeChangeReceiver() registerReceiver(timeChangeReceiver, intentFilter) &#125; override fun onDestroy() &#123; super.onDestroy() unregisterReceiver(timeChangeReceiver) &#125; inner class TimeChangeReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; Toast.makeText(context, &quot;时间改变&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;&#125; 注：不要在onReceive方法中添加过多的逻辑或者进行任何的耗时操作，因为BroadcastReceiver中是不允许开启线程的，当onReceive运行了较长时间而没有结束时，程序就会出现错误 静态注册Android 8.0（API 级别 26）或更高级别为目标的应用无法在其清单中注册隐式广播的广播接收器，除非广播是专门发送给这些应用的。不过，有几种广播不受这些限制的约束。具体有哪些可以参考隐式广播例外情况。 以接收开机广播为例，在 Android Studio 中右键新建BroadcastReceiver，会将其自动添加到Manifest.xml。新建窗口中的Exported表示是否允许这个BroadcastReceiver接收本程序以外的广播，Enabled表示是否启用这个BroadcastReceiver。 在Manifest.xml进行修改： 1234567891011121314151617181920&lt;manifest&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;application&gt; &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;!-- 若是自定义的广播，name为包名 --&gt; &lt;!-- &lt;action android:name=&quot;com.saoke.androiddemo.MY_BROADCAST&quot;/&gt; --&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 广播发送分为标准广播和有序广播。 标准广播是一种完全异步执行的广播，在广播发出之后，所有的BroadcastReceiver几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。 有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是有先后顺序的，优先级高的BroadcastReceiver就可以先收到广播消息，并且前面的BroadcastReceiver还可以截断正在传递的广播，这样后面的BroadcastReceiver就无法收到广播消息了。 发送标准广播12345button.setOnClickListener &#123; val intent = Intent(&quot;com.saoke.androiddemo.MY_BROADCAST&quot;) intent.setPackage(packageName) // packageName 即 getPackageName()，获取当前APP的包名 sendBroadcast(intent)&#125; 其中setPackage()指定这条广播是发送给哪个应用程序的，从而让它变成一条显式广播，否则静态注册的BroadcastReceiver将无法接收到这条广播 发送有序广播12345button.setOnClickListener &#123; val intent = Intent(&quot;com.saoke.androiddemo.MY_BROADCAST&quot;) intent.setPackage(packageName) sendOrderedBroadcast(intent, &quot;saoke.androiddemo&quot;)&#125; 其中sendOrderedBroadcast第二个参数为设置的权限，BroadcastReceiver要有对应权限才能接收到广播。权限为带.的字符串，无须权限可设为null。同样的标准广播也可设置权限。 可在Manifest.xml中设置BroadcastReceiver优先级，优先级高的先收到广播： 12345678910111213141516171819202122232425&lt;manifest&gt; &lt;!-- 若要接收的广播有设置权限，则APP要声明对应的权限 --&gt; &lt;permission android:protectionLevel=&quot;normal&quot; android:name=&quot;saoke.androiddemo&quot; /&gt; &lt;application&gt; &lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;!-- 设置优先级为 100 --&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.saoke.androiddemo.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt; &lt;!-- 若要接收的广播有设置权限，则接收器也要设置对应的权限 --&gt; &lt;uses-permission android:name=&quot;saoke.androiddemo&quot; /&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; 可在onReceive中用abortBroadcast()截断广播，后面的BroadcastReceiver将无法再接收到这条广播： 123456class MyBroadcastReceiver : BroadcastReceiver() &#123; override fun onReceive(context: Context, intent: Intent) &#123; Toast.makeText(context, &quot;MyBroadcastReceiver收到广播&quot;, Toast.LENGTH_SHORT).show() abortBroadcast() // 截断广播 &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的Activity","slug":"Android中的Activity","date":"2024-05-27T15:14:30.000Z","updated":"2024-06-13T15:01:43.215Z","comments":true,"path":"2024/05/27/Android中的Activity/","link":"","permalink":"http://princesaoke.github.io/2024/05/27/Android%E4%B8%AD%E7%9A%84Activity/","excerpt":"","text":"Activity的生命周期和启动模式详解 Activity的状态 运行状态：Activity位于返回栈的栈顶时就处于运行状态 暂停状态：Activity不在栈顶，但仍然可见时，就处于暂停状态 停止状态：Activity不在栈顶，且完全不可见的时，就处于停止状态。该状态下的Activity在内存紧张时可能被回收 销毁状态：Activity从返回栈中移除，不在栈里后就变成了销毁状态，系统最倾向于回收处于这种状态的Activity 生命周期 onCreate：在Activity第一次被创建的时候调用，执行加载布局、绑定事件等 onStart：在Activity由不可见变为可见的时候调用 onResume：当焦点从未完全覆盖屏幕的Activity（弹窗等）切换到此Activity时（即此Activity准备好和用户进行交互时）调用，此时的Activity一定位于返回栈的栈顶，并且处于运行状态，在最前台 onPause：在系统准备去启动或者恢复另一个Activity的时候调用，该方法的执行速度要快，否则会影响到新的栈顶Activity的使用 onStop：在Activity完全不可见时调用。它和onPause方法的主要区别在于，若启动的新Activity是对话框式的，则onPause方法会执行，而onStop不会 onDestroy：在Activity被销毁之前调用，之后Activity的状态将变为销毁状态 onRestart：在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了 Q：Activity A启动Activity B，那么B的onResume和A的onPause哪个先执行？ A： A先执行onPause，紧接着B执行onCreate-&gt;onStart-&gt;onResume，接着执行A的onStop Q：Activity进入停止状态后被系统回收，如何还原数据？ A： Activity中的onSaveInstanceState方法在Activity被回收前会被调用，它携带一个Bundle类型的参数用于保存数据。可以在Activity中重写onSaveInstanceState方法，在Bundle对象中存入要保存的数据，当Activity被回收后重新创建新的实例，在onCreate方法中可以获取到保存的Bundle对象。判断当Bundle不为空时，对数据进行赋值还原。 Activity的返回栈…… 启动模式在Manifest.xml中修改Activity的launchMode切换Activity的启动模式 123456&lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;standard&quot;&gt; &lt;intent-filter&gt; &lt;!-- --&gt; &lt;/intent-filter&gt;&lt;/activity&gt; standardstandard是Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。在standard模式下，每当启动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该Activity的新实例。 singleTop当Activity的启动模式指定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。不过当FirstActivity并未处于栈顶位置时，再启动FirstActivity还是会创建新的实例。 singleTask当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。 singleInstance指定为singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity，这样不管是哪个应用程序来访问这个Activity，都共用同一个返回栈，也就解决了共享Activity实例的问题 Q：A、B、C三个Activity，其中A、C为standard，B为singleInstance，从A进入B再从B进入C。现在连按三次返回，返回顺序是怎样的？ A： 从C返回到A再返回到B。 这是因为A、C处于同一返回栈，而B为singleInstance，单独处于一个返回栈。因此C先出栈，A成为栈顶；A再出栈后返回栈为空，于是显示另一个返回栈的栈顶Activity，即B。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"阿里智能信息前端实习面经","slug":"阿里智能信息前端实习面经","date":"2024-05-15T13:34:56.000Z","updated":"2024-05-17T04:24:21.503Z","comments":true,"path":"2024/05/15/阿里智能信息前端实习面经/","link":"","permalink":"http://princesaoke.github.io/2024/05/15/%E9%98%BF%E9%87%8C%E6%99%BA%E8%83%BD%E4%BF%A1%E6%81%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"一面挂，四十五分钟。 ✔ 编程题：URL combo - 字符串分割 ✔ 编程题：统计网页中出现了几种HTML元素 ❌ Array如何转化为Set ✔ 自我介绍，说一下学习和项目经历 ✔ 为什么学习Flutter？Flutter优势何在？ ✔ Flutter三棵树分别起什么作用？ ❌ Flutter状态管理相关，子组件如何与父组件通信？ ❌ Flutter如何与底层原生通信，如image_picker调用系统相机的原理？ ❌ 说一下MQTT协议？有什么特性？为什么物联网用MQTT？MQTT是基于TCP还是UDP？ ❌ 说一下 HTTP1.0 和 HTTP2.0 的区别 ❌ 说一下前端工程化？Vite有什么优势？ ✔ 为什么没有选择客户端开发？ ✔ 未来规划读研还是就业？ 编程题：URL combo - 字符串分割 123456789101112131415161718192021// 以下是天猫首页一个经过 combo 的 js 资源 url，请找出 combo 规律并用 js 写一个可复用的函数来解该 url，得到每个 combo 前的 url 地址。const urlStr = &#x27;https://g.alicdn.com/??code/npm/web-rax-framework/0.6.5/dist/framework.web.min.js,mtb/lib-windvane/2.1.8/windvane.cmd.js,mtb/lib-promise/3.1.3/polyfillB.js,mtb/lib-mtop/2.4.0/mtop.js,mtb/lib-login/1.5.3/login.js&#x27;;function unComboUrl(url) &#123; // 以&#x27;/&#x27;分割，还原出baseUrl // 再以逗号分割，将每一项与baseUrl合并 const l = url.split(&#x27;/&#x27;) const baseUrl = l[0] + &#x27;//&#x27; + l[2] + &#x27;/&#x27; var list = url.split(&#x27;,&#x27;) for (let i = 0; i &lt; list.length; i++) &#123; if (i == 0) &#123; console.log(list[0]) continue &#125; list[i] = baseUrl + list[i] console.log(list[i]) &#125;&#125;unComboUrl(urlStr) 编程题：统计网页中出现了几种HTML元素 一开始没写出来，因为我没法用DOM操作提取出HTML标签，后来面试官改成字符串： 123456// 在一个网页中，用尽可能少的代码，计算出当前网页用了多少种 HTML 元素。// 遍历字符串，遇到`&lt;`则开始识别HTML标签，`&gt;`或空格前的即为标签，将其入栈// 遇到`&lt;/`则为闭标签，识别后将栈顶对应标签出栈，若栈顶不匹配，则说明栈顶是非闭合标签，同样出栈，直到匹配为止// 若是形如`&lt;img /&gt;`的标签，则不用入栈进入下一步// 将出栈的标签加入集合，得到无重复的标签，集合大小即HTML种类数量 HTTP1.0 和 HTTP2.0的区别： HTTP1.0： 单一请求-响应模式：每次请求-响应都需要建立一个新的TCP连接，这个过程包括三次握手，增加了延迟 无状态连接：每个请求都是独立的，服务器不维护客户端的状态 请求头和响应头冗余：每次请求都会发送完整的头部信息，导致数据冗余和效率低下 文本协议：所有的请求和响应都是基于文本的，解析速度相对较慢 有限的并发：因为每个请求都需要一个单独的TCP连接，浏览器通常限制同一域名下的并发连接数，通常是4到6个 HTTP2.0： 多路复用：实现了多路复用，允许在单个TCP连接上并发多个请求-响应对，从而减少了连接的数量和延迟 二进制协议：相对于HTTP&#x2F;1.0的文本协议，HTTP&#x2F;2.0采用二进制格式，解析更高效 头部压缩：使用HPACK压缩算法来减少头部信息的大小，从而减少带宽消耗 服务器推送：服务器可以主动向客户端推送资源，而无需客户端明确请求，这样可以减少延迟并提高性能 流优先级：客户端和服务器可以通过设置流优先级来优化资源的传输顺序 连接管理：更有效的连接管理机制，通过单个连接处理多个并发请求，减少了连接建立和维护的开销 改进的安全性：虽然HTTP&#x2F;2.0可以在明文（HTTP）和加密（HTTPS）下工作，但通常与TLS（传输层安全协议）结合使用，以提供更好的安全性","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"排序算法总结","slug":"排序算法总结","date":"2024-05-14T12:47:03.000Z","updated":"2024-11-12T15:49:21.366Z","comments":true,"path":"2024/05/14/排序算法总结/","link":"","permalink":"http://princesaoke.github.io/2024/05/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"稳定排序：冒泡排序、插入排序、归并排序、基数排序 不稳定排序：选择排序、快速排序、希尔排序、堆排序 冒泡排序总共需要比较n - 1趟，每趟n - 1 - i次。 12345void bubbleSort(T a[], int n) &#123; for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; n - 1 - i; j++) if (a[j] &gt; a[j + 1]) swap(a[j], a[j + 1]);&#125; 快速排序基于分治和递归。 其基本思路是，在数组中选择一个元素作为基准值，然后将数组中小于基准值的元素移动到它的左边，大于基准值的元素移动到它的右边。然后对左右两个子数组递归地重复这个过程，直到子数组的大小为1或0。 是不稳定排序。当要比较的值和基准值一样时，根据代码可能放在基准值左边或右边。 最好情况：每次划分左右两边的元素数量相同各为一半，则此时时间复杂度为O(nlogn) 最坏情况：每次划分所有元素都在一边，另一边为空，则此时与冒泡排序类似，时间复杂度为O(n²) 平均情况：时间复杂度为O(nlogn) 因此关键在于每次基准值的选取。 通过不同方式选取基准值，有以下几种衍生快排： 随机快速排序：即在数组中完全随机地挑选一个值作为基准值。 三数取中快速排序：即取数组中第一个、中间、最后一个这三个元素的中位数作为基准值。 三划分快速排序：适用于数组中有较多大小相同的数。对于等于基准值的数分为除左右外的第三部分，不用继续参与递归。 图解： 以数组中第一个元素为基准值 左指针不断右移，直到找到比基准值大的元素停下；右指针不断左移，直到找到比基准值小的元素停下 当两指针碰面或超过，说明已经全部遍历了 交换后左边都小于基准值，右边都大于基准值 12345678910111213141516171819202122232425262728/// 以数组中第一个元素为基准值，确定其位置int partition(T a[], int begin, int end) &#123; int left = begin + 1; int right = end; T base = a[begin]; while (true) &#123; while (a[left++] &lt; base); // 左指针不断右移，直到找到比基准值大的元素 while (a[right--] &gt; base); // 右指针不断左移，直到找到比基准值小的元素 if (left &gt;= right) break; // 当两指针碰面或超过，说明已经全部遍历了 swap(a[left], a[right]); &#125; swap(a[right], a[begin]); // 交换后right左边都小于base，右边都大于base return right;&#125;int randomPartition() &#123; int randomIndex = Random(begin, end); // 可取不同值作为基准值，这里随机一个下标 swap(a[randomIndex], a[begin]); return partition(a, begin, end);&#125;void quickSort(T a[], int begin, int end) &#123; if (begin &lt; end) &#123; int middle = partition(a, begin, end); quickSort(a, begin, middle - 1); quickSort(a, middle + 1, end); &#125;&#125; 堆排序平均时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041public class HeapSortTest &#123; /// 堆排序（大根堆） public int[] heapSort(int[] nums) &#123; buildMaxHeap(nums); int heapSize = nums.length; for (int i = 0; i &lt; nums.length - 1; i++) &#123; // 将堆中第一个与最后一个交换 int curr = nums[0]; nums[0] = nums[heapSize - 1]; nums[heapSize - 1] = curr; heapSize--; adjust(nums, heapSize, 0); &#125; return nums; &#125; /// 从最后一个非叶节点开始，倒着往前调整排序 public void buildMaxHeap(int[] nums) &#123; for (int i = nums.length / 2 - 1; i &gt;= 0; i--) &#123; adjust(nums, nums.length, i); &#125; &#125; /// 将下标为i的节点与其左右子节点进行比较调整，若有交换则递归地比较交换的子节点，确保交换后子树依然有序 public void adjust(int[] nums, int heapSize, int i) &#123; int l = (i + 1) * 2 - 1; int r = (i + 1) * 2; int max = i; if (l &lt; heapSize &amp;&amp; nums[l] &gt; nums[max]) max = l; if (r &lt; heapSize &amp;&amp; nums[r] &gt; nums[max]) max = r; if (i != max) &#123; // 父节点与比其大的子节点交换 int curr = nums[i]; nums[i] = nums[max]; nums[max] = curr; adjust(nums, heapSize, max); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://princesaoke.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"饿了么客户端实习面经","slug":"饿了么客户端实习面经","date":"2024-05-07T11:30:21.000Z","updated":"2024-05-17T04:15:31.399Z","comments":true,"path":"2024/05/07/饿了么客户端实习面经/","link":"","permalink":"http://princesaoke.github.io/2024/05/07/%E9%A5%BF%E4%BA%86%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"答的很烂……就没几个问题是答出来的 T^T 共四十多分钟。 ✔ 自我介绍 ✔ 详细讲一下实习期间做了哪些事情？实现的细节？ ❌ LazyColumn和Column有什么区别？为什么能提升性能？ ❌ 长列表的数据如果一次性加载会卡顿，如何处理？分页查询相关。如何刷新？前一页的数据如何处理？ ❌ Flutter三个树？嵌套的组件渲染绘制的步骤？ ✔ UDP和TCP的区别 ❌ 2M的数据流，通过TCP发送，要经过哪些步骤？ ❌ APP的启动过程 ✔ Activity的生命周期？两个Activity跳转其分别的生命周期函数调用顺序？哪些情况下不会进入onStop？ ❌ 说一下快排 ✔ 最大递增子串 ✔ 链表翻转 长列表性能问题应该是想问RecyclerView四级缓存机制吧。即Scrap缓存、Recycle缓存、ViewCacheExtension缓存、RecycledViewPool缓存。 RecyclerView在滚动时会复用已经存在的ViewHolder对象，而不是每次都创建新的ViewHolder。这样做的好处是减少了对象的创建和销毁次数，提高了内存利用率和性能。当列表项滚出屏幕时，对应的ViewHolder会被移除并加入到RecyclerView的内部缓存池中，当新的列表项需要显示时，RecyclerView会尝试从缓存池中获取可用的ViewHolder对象，避免了重新创建ViewHolder。 RecyclerView提供了setItemViewCacheSize()方法来设置缓存的ViewHolder数量。通过适当调整这个值，可以控制缓存的大小，避免过多的缓存导致内存占用过高。 Flutter三棵树指的是Widget树、Element树、RenderObject树。 Activity的生命周期和启动模式详解 Fragment在显示到销毁的过程中会执行自己的生命周期：onAttach -&gt; onCreate -&gt;onCreateView -&gt; onActivityCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroyView -&gt; onDestroy -&gt; onDetach 同时也受到Activity生命周期的影响，如果Activity触发onPause，Fragment也会执行相应的onPause。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"美团客户端实习面经","slug":"美团客户端实习面经","date":"2024-04-28T14:08:43.000Z","updated":"2024-09-21T05:06:05.119Z","comments":true,"path":"2024/04/28/美团客户端实习面经/","link":"","permalink":"http://princesaoke.github.io/2024/04/28/%E7%BE%8E%E5%9B%A2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"笔试 4.27题型：30题单选题，2题编程题 时间：2小时 单选题主要有计算机网络、操作系统、数据结构、数字找规律、三元一次方程应用题等。 记录单选题涉及到的知识点 有效的子网掩码 SQL共享锁和排它锁，其他事务能否读写 HTTP2 和 HTTP3 的区别 编程题AC第一题，第二题是一个九宫格魔法阵，周围的数值改变怎么怎么样的，没一点思路。 当时没记录，现在忘了。。 一面 5.16 ✔ C和C++的区别 ❌ 子结构体对父结构体函数的重写 ✔ 进程和线程的区别 ✔ 同步和异步的区别？为什么需要异步？多线程操作时可能出现什么问题？ ❌ OSI七层网络模型 ✔ HTTP和HTTPS的区别？HTTP全称是什么？HTTPS的S指什么？ ✔ TCP和UDP的区别 ✔ 为什么要三次握手 ✔ 服务器如何知道请求中的不同类型的数据格式？ ❌ 编程题：翻转链表 全都是考基础，没问项目没问实习。 开头自我介绍，然后问我熟悉什么语言，C++或Java会吗，一开始就是打算考编程语言。 C和C++的区别，答：一个是面向对象一个是面向过程，C++有输入输出流 然后出了个题： 123456789101112131415struct A &#123; f() &#123; printf(&#x27;A&#x27;); &#125;&#125;;struct B : A &#123; f() &#123; printf(&#x27;B&#x27;); &#125;&#125;;int main() &#123; A a = A(); B b = B(); a.f(); b.f(); return 0;&#125; 问输出是什么。又问给B的f()加上virtual，输出是什么。 最后一题考编程题，两非递减数组原地排序，LeetCode上刷过，心中窃喜，结果语言切到C++，判题器有点问题没给提交模板，判不了题直接编译错误，面试官也弄不明白，就给我换了一题翻转链表，结果没做出来，被自己的抽象操作蠢哭了…… T^T 最后面试官还指出了我的不足。在我做编程题的时候他看了我的Github和博客，说我项目是足够的，但是要注重基础，编程语言的基础和底层，计网、数据结构四大件的基础等。 还是第一次有面试官给我提建议，发觉不同面试官之间面试方式还是有挺大差距的，有的没怎么问编程语言，有的不怎么问实践。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"各种编码格式","slug":"各种编码格式","date":"2024-04-11T16:27:17.000Z","updated":"2024-04-11T17:11:13.047Z","comments":true,"path":"2024/04/12/各种编码格式/","link":"","permalink":"http://princesaoke.github.io/2024/04/12/%E5%90%84%E7%A7%8D%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"ASCII码 十进制 缩写&#x2F;字符 解释 二进制 八进制 十六进制 0 NUL(null) 空字符 0000 0000 00 0x00 1 SOH(start of headline) 标题开始 0000 0001 01 0x01 2 STX (start of text) 正文开始 0000 0010 02 0x02 3 ETX (end of text) 正文结束 0000 0011 03 0x03 4 EOT (end of transmission) 传输结束 0000 0100 04 0x04 5 ENQ (enquiry) 请求 0000 0101 05 0x05 6 ACK (acknowledge) 收到通知 0000 0110 06 0x06 7 BEL (bell) 响铃 0000 0111 07 0x07 8 BS (backspace) 退格 0000 1000 010 0x08 9 HT (horizontal tab) 水平制表符 0000 1001 011 0x09 10 LF (NL line feed, new line) 换行键 0000 1010 012 0x0A 11 VT (vertical tab) 垂直制表符 0000 1011 013 0x0B 12 FF (NP form feed, new page) 换页键 0000 1100 014 0x0C 13 CR (carriage return) 回车键 0000 1101 015 0x0D 14 SO (shift out) 不用切换 0000 1110 016 0x0E 15 SI (shift in) 启用切换 0000 1111 017 0x0F 16 DLE (data link escape) 数据链路转义 0001 0000 020 0x10 17 DC1 (device control 1) 设备控制1 0001 0001 021 0x11 18 DC2 (device control 2) 设备控制2 0001 0010 022 0x12 19 DC3 (device control 3) 设备控制3 0001 0011 023 0x13 20 DC4 (device control 4) 设备控制4 0001 0100 024 0x14 21 NAK (negative acknowledge) 拒绝接收 0001 0101 025 0x15 22 SYN (synchronous idle) 同步空闲 0001 0110 026 0x16 23 ETB (end of trans. block) 结束传输块 0001 0111 027 0x17 24 CAN (cancel) 取消 0001 1000 030 0x18 25 EM (end of medium) 媒介结束 0001 1001 031 0x19 26 SUB (substitute) 代替 0001 1010 032 0x1A 27 ESC (escape) 换码(溢出) 0001 1011 033 0x1B 28 FS (file separator) 文件分隔符 0001 1100 034 0x1C 29 GS (group separator) 分组符 0001 1101 035 0x1D 30 RS (record separator) 记录分隔符 0001 1110 036 0x1E 31 US (unit separator) 单元分隔符 0001 1111 037 0x1F 32 (space) 空格 0010 0000 040 0x20 33 ! 叹号 0010 0001 041 0x21 34 “ 双引号 0010 0010 042 0x22 35 # 井号 0010 0011 043 0x23 36 $ 美元符 0010 0100 044 0x24 37 % 百分号 0010 0101 045 0x25 38 &amp; 和号 0010 0110 046 0x26 39 ‘ 闭单引号 0010 0111 047 0x27 40 ( 开括号 0010 1000 050 0x28 41 ) 闭括号 0010 1001 051 0x29 42 * 星号 0010 1010 052 0x2A 43 + 加号 0010 1011 053 0x2B 44 , 逗号 0010 1100 054 0x2C 45 - 减号&#x2F;破折号 0010 1101 055 0x2D 46 . 句号 0010 1110 056 0x2E 47 &#x2F; 斜杠 0010 1111 057 0x2F 48 0 字符0 0011 0000 060 0x30 49 1 字符1 0011 0001 061 0x31 50 2 字符2 0011 0010 062 0x32 51 3 字符3 0011 0011 063 0x33 52 4 字符4 0011 0100 064 0x34 53 5 字符5 0011 0101 065 0x35 54 6 字符6 0011 0110 066 0x36 55 7 字符7 0011 0111 067 0x37 56 8 字符8 0011 1000 070 0x38 57 9 字符9 0011 1001 071 0x39 58 : 冒号 0011 1010 072 0x3A 59 ; 分号 0011 1011 073 0x3B 60 &lt; 小于 0011 1100 074 0x3C 61 &#x3D; 等号 0011 1101 075 0x3D 62 &gt; 大于 0011 1110 076 0x3E 63 ? 问号 0011 1111 077 0x3F 64 @ 电子邮件符号 0100 0000 0100 0x40 65 A 大写字母A 0100 0001 0101 0x41 66 B 大写字母B 0100 0010 0102 0x42 67 C 大写字母C 0100 0011 0103 0x43 68 D 大写字母D 0100 0100 0104 0x44 69 E 大写字母E 0100 0101 0105 0x45 70 F 大写字母F 0100 0110 0106 0x46 71 G 大写字母G 0100 0111 0107 0x47 72 H 大写字母H 0100 1000 0110 0x48 73 I 大写字母I 0100 1001 0111 0x49 74 J 大写字母J 01001010 0112 0x4A 75 K 大写字母K 0100 1011 0113 0x4B 76 L 大写字母L 0100 1100 0114 0x4C 77 M 大写字母M 0100 1101 0115 0x4D 78 N 大写字母N 0100 1110 0116 0x4E 79 O 大写字母O 0100 1111 0117 0x4F 80 P 大写字母P 0101 0000 0120 0x50 81 Q 大写字母Q 0101 0001 0121 0x51 82 R 大写字母R 0101 0010 0122 0x52 83 S 大写字母S 0101 0011 0123 0x53 84 T 大写字母T 0101 0100 0124 0x54 85 U 大写字母U 0101 0101 0125 0x55 86 V 大写字母V 0101 0110 0126 0x56 87 W 大写字母W 0101 0111 0127 0x57 88 X 大写字母X 0101 1000 0130 0x58 89 Y 大写字母Y 0101 1001 0131 0x59 90 Z 大写字母Z 0101 1010 0132 0x5A 91 [ 开方括号 0101 1011 0133 0x5B 92 \\ 反斜杠 0101 1100 0134 0x5C 93 ] 闭方括号 0101 1101 0135 0x5D 94 ^ 脱字符 0101 1110 0136 0x5E 95 _ 下划线 0101 1111 0137 0x5F 96 &#96; 开单引号 0110 0000 0140 0x60 97 a 小写字母a 0110 0001 0141 0x61 98 b 小写字母b 0110 0010 0142 0x62 99 c 小写字母c 0110 0011 0143 0x63 100 d 小写字母d 0110 0100 0144 0x64 101 e 小写字母e 0110 0101 0145 0x65 102 f 小写字母f 0110 0110 0146 0x66 103 g 小写字母g 0110 0111 0147 0x67 104 h 小写字母h 0110 1000 0150 0x68 105 i 小写字母i 0110 1001 0151 0x69 106 j 小写字母j 0110 1010 0152 0x6A 107 k 小写字母k 0110 1011 0153 0x6B 108 l 小写字母l 0110 1100 0154 0x6C 109 m 小写字母m 0110 1101 0155 0x6D 110 n 小写字母n 0110 1110 0156 0x6E 111 o 小写字母o 0110 1111 0157 0x6F 112 p 小写字母p 0111 0000 0160 0x70 113 q 小写字母q 0111 0001 0161 0x71 114 r 小写字母r 0111 0010 0162 0x72 115 s 小写字母s 0111 0011 0163 0x73 116 t 小写字母t 0111 0100 0164 0x74 117 u 小写字母u 0111 0101 0165 0x75 118 v 小写字母v 0111 0110 0166 0x76 119 w 小写字母w 0111 0111 0167 0x77 120 x 小写字母x 0111 1000 0170 0x78 121 y 小写字母y 0111 1001 0171 0x79 122 z 小写字母z 0111 1010 0172 0x7A 123 { 开花括号 0111 1011 0173 0x7B 124 | 垂线 0111 1100 0174 0x7C 125 } 闭花括号 0111 1101 0175 0x7D 126 ~ 波浪号 0111 1110 0176 0x7E 127 DEL (delete) 删除 0111 1111 0177 0x7F Base64将二进制流划分为若干3个字节的块（不足补0），然后再把每个块划分位4个6比特组，每个6比特组对应Base64字母表中的64个字符之一，再转换成字符对应的ASCII码在网络上传输。","categories":[],"tags":[]},{"title":"MQTT协议","slug":"MQTT协议","date":"2024-04-02T16:24:10.000Z","updated":"2024-05-16T07:42:41.478Z","comments":true,"path":"2024/04/03/MQTT协议/","link":"","permalink":"http://princesaoke.github.io/2024/04/03/MQTT%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"MQTT协议，终于有人讲清楚了 Flutter中的MQTT库：mqtt_client、mqtt5_client MQTT（Message Queuing Telemetry Transport）是一种轻量级的、开放的、基于发布&#x2F;订阅模式的消息传输协议。它具有以下特性： 轻量级: MQTT的设计目标之一是在网络带宽和设备资源有限的环境下运行。它的协议头部较小，传输效率高，适用于各种物联网设备，包括嵌入式系统和传感器。 发布&#x2F;订阅模式: MQTT采用发布&#x2F;订阅模式进行消息传输，其中发布者（publisher）发布消息到特定的主题（topic），而订阅者（subscriber）则订阅感兴趣的主题。这种模式可以实现解耦，让设备和应用程序之间的通信更加灵活。 可靠性: MQTT支持三种级别的服务质量（QoS），包括最多一次（QoS 0）、至少一次（QoS 1）和只有一次（QoS 2）。通过这些级别，可以根据应用程序的需求选择适当的消息传输可靠性。 持久性会话: 客户端可以选择使用持久性会话，这意味着即使客户端断开连接，服务器仍然会保留客户端的订阅状态和未传递的消息。这对于设备的稳健性和状态管理非常有用。 安全性: MQTT支持使用TLS&#x2F;SSL进行加密，以确保传输数据的安全性。此外，它还支持基于用户名和密码的身份验证机制，以及其他高级的安全特性。 物联网适合使用MQTT的原因 低带宽、高延迟环境: MQTT的轻量级设计使其非常适合在带宽有限、延迟较高的网络环境中运行，这正是许多物联网应用所面临的情况。 异构性: 物联网涉及各种设备，包括传感器、嵌入式系统、移动设备等，这些设备可能具有不同的处理能力和通信能力。MQTT作为一种通用的、轻量级的协议，可以轻松地在这些异构设备之间进行通信。 解耦性: MQTT的发布&#x2F;订阅模式允许设备和应用程序之间进行解耦，从而提高了系统的灵活性和可扩展性。设备可以发布数据到特定的主题，而应用程序可以订阅感兴趣的主题，双方无需直接通信。 可靠性和持久性: MQTT支持不同级别的服务质量，可以根据应用程序的需求选择适当的级别。它还支持持久性会话，保证了设备和应用程序之间的稳健通信。","categories":[],"tags":[]},{"title":"Jetpack_Compose","slug":"Jetpack-Compose","date":"2024-04-02T16:19:28.000Z","updated":"2024-04-02T16:22:43.610Z","comments":true,"path":"2024/04/03/Jetpack-Compose/","link":"","permalink":"http://princesaoke.github.io/2024/04/03/Jetpack-Compose/","excerpt":"","text":"声明式UI，类似Flutter。 从0上手Jetpack Compose，看这一篇就够了～","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"防双击","slug":"防双击","date":"2024-04-01T16:32:41.000Z","updated":"2024-04-01T16:34:24.825Z","comments":true,"path":"2024/04/02/防双击/","link":"","permalink":"http://princesaoke.github.io/2024/04/02/%E9%98%B2%E5%8F%8C%E5%87%BB/","excerpt":"","text":"实现1234567891011121314151617181920212223242526class DoubleClickFilter &#123; static int lastClickTime = 0; static int lastKey = 0; //区分不同点击事件 static Function() debounce(Function fn, [int key = 0, int interval = 500]) &#123; return () &#123; if (key != lastKey) &#123; lastClickTime = 0; lastKey = key; &#125; int currTime = DateTime.now().millisecondsSinceEpoch; if (currTime - lastClickTime &gt; interval) &#123; lastClickTime = currTime; fn(); &#125; &#125;; &#125;&#125;extension FunctionExtension on Function &#123; /// [key]用于区分不同点击事件 /// [interval]为防双击的时间间隔，单位毫秒 Function() debounce([int key = 0, int interval = 500]) &#123; return DoubleClickFilter.debounce(this, key, interval); &#125;&#125; 使用方法123456ElevatedButton( onPressed: () &#123; print(&#x27;500毫秒内点击不会触发第二次&#x27;); &#125;.debounce(), child: const Text(&#x27;防双击按钮&#x27;),);","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[]},{"title":"Flutter中的Slider","slug":"Flutter中的Slider","date":"2024-04-01T15:55:52.000Z","updated":"2024-04-01T15:58:27.385Z","comments":true,"path":"2024/04/01/Flutter中的Slider/","link":"","permalink":"http://princesaoke.github.io/2024/04/01/Flutter%E4%B8%AD%E7%9A%84Slider/","excerpt":"","text":"更改Slider样式要改变Flutter中默认的Slider的滑块样式，需要在Slider外包裹一层SliderTheme，在data中修改thumbShape。 123456789101112131415161718SliderTheme( data: SliderTheme.of(context).copyWith( trackHeight: 10.w, // 进度条轨道高度 thumbShape: MySliderThumbShape(enabledThumbRadius: 8.w, disabledThumbRadius: 5.w), //滑块 overlayShape: RoundSliderOverlayShape(overlayRadius: 7.w), ), child: Slider( value: voice.toDouble(), min: 0, max: 100, divisions: 100, activeColor: ColorConfig.color_2877FD, // 滑块左边轨道的颜色 inactiveColor: ColorConfig.color_F7F7F7, // 滑块右边轨道的颜色 onChanged: (v) &#123; // TODO &#125;, ),); 自定义滑块thumbShape接受一个SliderComponentShape，因此自定义的滑块要继承该类，并实现getPreferredSize和paint两个方法。 其中Size getPreferredSize(bool isEnabled, bool isDiscrete)要返回滑块的大小，isEnabled为滑块是否被按下。 在void paint方法中实现滑块的绘制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/// 自定义的音量Slider滑块class MySliderThumbShape extends SliderComponentShape &#123; const MySliderThumbShape(&#123; this.elevation = 5, this.pressedElevation = 20, this.enabledThumbRadius = 8, this.disabledThumbRadius, &#125;); final double elevation; final double pressedElevation; final double enabledThumbRadius; final double? disabledThumbRadius; double get _disabledThumbRadius =&gt; disabledThumbRadius ?? enabledThumbRadius; @override Size getPreferredSize(bool isEnabled, bool isDiscrete) &#123; return Size.fromRadius( isEnabled ? enabledThumbRadius : _disabledThumbRadius); &#125; @override void paint( PaintingContext context, Offset center, &#123; required Animation&lt;double&gt; activationAnimation, required Animation&lt;double&gt; enableAnimation, required bool isDiscrete, required TextPainter labelPainter, required RenderBox parentBox, required SliderThemeData sliderTheme, required TextDirection textDirection, required double value, required double textScaleFactor, required Size sizeWithOverflow, &#125;) &#123; final Canvas canvas = context.canvas; // 阴影的补间值 final Tween&lt;double&gt; elevationTween = Tween&lt;double&gt;( begin: elevation, end: pressedElevation, ); // 阴影的瞬时值 final double evaluatedElevation = elevationTween.evaluate(activationAnimation); // 滑块半径大小的补间值 final Tween&lt;double&gt; radiusTween = Tween&lt;double&gt;( begin: _disabledThumbRadius, end: enabledThumbRadius, ); // 滑块半径大小的瞬时值 final double radius = radiusTween.evaluate(enableAnimation); final Path path = Path(); path.addArc( Rect.fromCenter(center: center, width: 2 * radius, height: 2 * radius), 0, pi * 2, ); canvas.drawShadow(path, Colors.black, evaluatedElevation, true); canvas.drawCircle( center, (radius + 2) * (1 + activationAnimation.value * 0.5), Paint()..color = Colors.white, ); canvas.drawCircle( center, radius * (1 + activationAnimation.value * 0.5), Paint()..color = ColorConfig.color_2877FD, ); &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Flutter带下拉建议列表的搜索框","slug":"Flutter带下拉建议列表的搜索框","date":"2024-04-01T15:45:17.000Z","updated":"2024-04-01T15:55:25.107Z","comments":true,"path":"2024/04/01/Flutter带下拉建议列表的搜索框/","link":"","permalink":"http://princesaoke.github.io/2024/04/01/Flutter%E5%B8%A6%E4%B8%8B%E6%8B%89%E5%BB%BA%E8%AE%AE%E5%88%97%E8%A1%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A1%86/","excerpt":"","text":"基于DropdownMenu实现Flutter自带的DropdownMenu无法满足需求，在源码的基础上copy一份出来修改： suggest_search_bar.dart： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import &#x27;dart:async&#x27;;import &#x27;package:flutter/material.dart&#x27;;class SuggestSearchBar extends StatefulWidget &#123; /// 带建议的搜索框 const SuggestSearchBar(&#123; super.key, this.width, this.maxSuggestHeight = 300, this.hintText, this.onSelected, this.buildSuggestion, this.inputController, this.defaultSuggestion, this.trailingIcon, this.isCollapsed = false, this.contentPadding, &#125;); /// 搜索框的宽度，只有当`trailingIcon`不为null时生效 final double? width; /// 建议栏的最大高度 final double maxSuggestHeight; final String? hintText; final void Function(String?)? onSelected; final TextEditingController? inputController; final List&lt;String&gt;? defaultSuggestion; final Widget? trailingIcon; /// 构建搜索建议 /// /// 传入一个带`String`参数的方法，该参数为当前搜索框输入的值 /// 返回一个`Future&lt;List&lt;String&gt;&gt;`，为建议值列表 final Future&lt;List&lt;String&gt;&gt; Function(String)? buildSuggestion; /// 即搜索框[TextField]的[isCollapsed] final bool isCollapsed; /// 即搜索框[TextField]的[contentPadding] final EdgeInsetsGeometry? contentPadding; @override State&lt;SuggestSearchBar&gt; createState() =&gt; _SuggestSearchBarState();&#125;class _SuggestSearchBarState extends State&lt;SuggestSearchBar&gt; &#123; final StreamController&lt;List&lt;String&gt;&gt; streamController = StreamController(); late TextEditingController _inputController; @override void initState() &#123; super.initState(); _inputController = widget.inputController ?? TextEditingController(); if (widget.inputController == null || widget.buildSuggestion == null) &#123; return; &#125; widget.inputController!.addListener(onChanged); &#125; onChanged() async &#123; List&lt;String&gt; suggestionList = await widget.buildSuggestion!.call(widget.inputController!.text); streamController.add(suggestionList); &#125; @override Widget build(BuildContext context) &#123; return StreamBuilder&lt;List&lt;String&gt;&gt;( stream: streamController.stream, initialData: widget.defaultSuggestion, builder: (context, snapshot) &#123; List&lt;DropdownMenuEntry&lt;String&gt;&gt; entryList = []; if (snapshot.data != null) &#123; entryList = snapshot.data! .map((e) =&gt; DropdownMenuEntry&lt;String&gt;(label: e, value: e)) .toList(); &#125; return CustomedDropdownMenu&lt;String&gt;( width: widget.width, menuHeight: widget.maxSuggestHeight, hintText: widget.hintText, trailingIcon: widget.trailingIcon ?? InkWell( onTap: () &#123; _inputController.text = &quot;&quot;; widget.onSelected?.call(&quot;&quot;); &#125;, child: Icon(Icons.search)), onSelected: widget.onSelected, controller: _inputController, dropdownMenuEntries: entryList, enableFilter: true, requestFocusOnTap: true, isCollapsed: widget.isCollapsed, contentPadding: widget.contentPadding, ); &#125;, ); &#125;&#125; 对源码的修改： customed_dropdown_menu.dart： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863// Copyright 2014 The Flutter Authors. All rights reserved.// Use of this source code is governed by a BSD-style license that can be// found in the LICENSE file.import &#x27;dart:math&#x27; as math;import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter/rendering.dart&#x27;;import &#x27;package:flutter/services.dart&#x27;;// Navigation shortcuts to move the selected menu items up or down.Map&lt;ShortcutActivator, Intent&gt; _kMenuTraversalShortcuts = &lt;ShortcutActivator, Intent&gt;&#123; LogicalKeySet(LogicalKeyboardKey.arrowUp): const _ArrowUpIntent(), LogicalKeySet(LogicalKeyboardKey.arrowDown): const _ArrowDownIntent(),&#125;;const double _kMinimumWidth = 112.0;const double _kDefaultHorizontalPadding = 12.0;/// A dropdown menu that can be opened from a [TextField]. The selected/// menu item is displayed in that field.////// This widget is used to help people make a choice from a menu and put the/// selected item into the text input field. People can also filter the list based/// on the text input or search one item in the menu list.////// The menu is composed of a list of [DropdownMenuEntry]s. People can provide information,/// such as: label, leading icon or trailing icon for each entry. The [TextField]/// will be updated based on the selection from the menu entries. The text field/// will stay empty if the selected entry is disabled.////// The dropdown menu can be traversed by pressing the up or down key. During the/// process, the corresponding item will be highlighted and the text field will be updated./// Disabled items will be skipped during traversal.////// The menu can be scrollable if not all items in the list are displayed at once.////// &#123;@tool dartpad&#125;/// This sample shows how to display outlined [DropdownMenu] and filled [DropdownMenu].////// ** See code in examples/api/lib/material/dropdown_menu/dropdown_menu.0.dart **/// &#123;@end-tool&#125;////// See also:////// * [MenuAnchor], which is a widget used to mark the &quot;anchor&quot; for a set of submenus./// The [DropdownMenu] uses a [TextField] as the &quot;anchor&quot;./// * [TextField], which is a text input widget that uses an [InputDecoration]./// * [DropdownMenuEntry], which is used to build the [MenuItemButton] in the [DropdownMenu] list.class CustomedDropdownMenu&lt;T&gt; extends StatefulWidget &#123; /// Creates a const [DropdownMenu]. /// /// The leading and trailing icons in the text field can be customized by using /// [leadingIcon], [trailingIcon] and [selectedTrailingIcon] properties. They are /// passed down to the [InputDecoration] properties, and will override values /// in the [InputDecoration.prefixIcon] and [InputDecoration.suffixIcon]. /// /// Except leading and trailing icons, the text field can be configured by the /// [InputDecorationTheme] property. The menu can be configured by the [menuStyle]. const CustomedDropdownMenu(&#123; super.key, this.enabled = true, this.width, this.menuHeight, this.leadingIcon, this.trailingIcon, this.label, this.hintText, this.helperText, this.errorText, this.selectedTrailingIcon, this.enableFilter = false, this.enableSearch = true, this.textStyle, this.inputDecorationTheme, this.menuStyle, this.controller, this.initialSelection, this.onSelected, this.requestFocusOnTap, required this.dropdownMenuEntries, this.isCollapsed = false, this.contentPadding, &#125;); /// Determine if the [DropdownMenu] is enabled. /// /// Defaults to true. final bool enabled; /// Determine the width of the [DropdownMenu]. /// /// If this is null, the width of the [DropdownMenu] will be the same as the width of the widest /// menu item plus the width of the leading/trailing icon. final double? width; /// Determine the height of the menu. /// /// If this is null, the menu will display as many items as possible on the screen. final double? menuHeight; /// An optional Icon at the front of the text input field. /// /// Defaults to null. If this is not null, the menu items will have extra paddings to be aligned /// with the text in the text field. final Widget? leadingIcon; /// An optional icon at the end of the text field. /// /// Defaults to an [Icon] with [Icons.arrow_drop_down]. final Widget? trailingIcon; /// Optional widget that describes the input field. /// /// When the input field is empty and unfocused, the label is displayed on /// top of the input field (i.e., at the same location on the screen where /// text may be entered in the input field). When the input field receives /// focus (or if the field is non-empty), the label moves above, either /// vertically adjacent to, or to the center of the input field. /// /// Defaults to null. final Widget? label; /// Text that suggests what sort of input the field accepts. /// /// Defaults to null; final String? hintText; /// Text that provides context about the [DropdownMenu]&#x27;s value, such /// as how the value will be used. /// /// If non-null, the text is displayed below the input field, in /// the same location as [errorText]. If a non-null [errorText] value is /// specified then the helper text is not shown. /// /// Defaults to null; /// /// See also: /// /// * [InputDecoration.helperText], which is the text that provides context about the [InputDecorator.child]&#x27;s value. final String? helperText; /// Text that appears below the input field and the border to show the error message. /// /// If non-null, the border&#x27;s color animates to red and the [helperText] is not shown. /// /// Defaults to null; /// /// See also: /// /// * [InputDecoration.errorText], which is the text that appears below the [InputDecorator.child] and the border. final String? errorText; /// An optional icon at the end of the text field to indicate that the text /// field is pressed. /// /// Defaults to an [Icon] with [Icons.arrow_drop_up]. final Widget? selectedTrailingIcon; /// Determine if the menu list can be filtered by the text input. /// /// Defaults to false. final bool enableFilter; /// Determine if the first item that matches the text input can be highlighted. /// /// Defaults to true as the search function could be commonly used. final bool enableSearch; /// The text style for the [TextField] of the [DropdownMenu]; /// /// Defaults to the overall theme&#x27;s [TextTheme.labelLarge] /// if the dropdown menu theme&#x27;s value is null. final TextStyle? textStyle; /// Defines the default appearance of [InputDecoration] to show around the text field. /// /// By default, shows a outlined text field. final InputDecorationTheme? inputDecorationTheme; /// The [MenuStyle] that defines the visual attributes of the menu. /// /// The default width of the menu is set to the width of the text field. final MenuStyle? menuStyle; /// Controls the text being edited or selected in the menu. /// /// If null, this widget will create its own [TextEditingController]. final TextEditingController? controller; /// The value used to for an initial selection. /// /// Defaults to null. final T? initialSelection; /// The callback is called when a selection is made. /// /// Defaults to null. If null, only the text field is updated. final ValueChanged&lt;T?&gt;? onSelected; /// Determine if the dropdown button requests focus and the on-screen virtual /// keyboard is shown in response to a touch event. /// /// By default, on mobile platforms, tapping on the text field and opening /// the menu will not cause a focus request and the virtual keyboard will not /// appear. The default behavior for desktop platforms is for the dropdown to /// take the focus. /// /// Defaults to null. Setting this field to true or false, rather than allowing /// the implementation to choose based on the platform, can be useful for /// applications that want to override the default behavior. final bool? requestFocusOnTap; /// Descriptions of the menu items in the [DropdownMenu]. /// /// This is a required parameter. It is recommended that at least one [DropdownMenuEntry] /// is provided. If this is an empty list, the menu will be empty and only /// contain space for padding. final List&lt;DropdownMenuEntry&lt;T&gt;&gt; dropdownMenuEntries; /// 即搜索框[TextField]的[isCollapsed] final bool isCollapsed; /// 即搜索框[TextField]的[contentPadding] final EdgeInsetsGeometry? contentPadding; @override State&lt;CustomedDropdownMenu&lt;T&gt;&gt; createState() =&gt; _CustomedDropdownMenuState&lt;T&gt;();&#125;class _CustomedDropdownMenuState&lt;T&gt; extends State&lt;CustomedDropdownMenu&lt;T&gt;&gt; &#123; final GlobalKey _anchorKey = GlobalKey(); final GlobalKey _leadingKey = GlobalKey(); final MenuController _controller = MenuController(); late final TextEditingController _textEditingController; late bool _enableFilter; late List&lt;DropdownMenuEntry&lt;T&gt;&gt; filteredEntries; List&lt;Widget&gt;? _initialMenu; int? currentHighlight; double? leadingPadding; bool _menuHasEnabledItem = false; @override void initState() &#123; super.initState(); _textEditingController = widget.controller ?? TextEditingController(); _enableFilter = widget.enableFilter; filteredEntries = widget.dropdownMenuEntries; _menuHasEnabledItem = filteredEntries.any((DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.enabled); final int index = filteredEntries.indexWhere( (DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.value == widget.initialSelection); if (index != -1) &#123; _textEditingController.text = filteredEntries[index].label; _textEditingController.selection = TextSelection.collapsed(offset: _textEditingController.text.length); &#125; refreshLeadingPadding(); &#125; @override void didUpdateWidget(CustomedDropdownMenu&lt;T&gt; oldWidget) &#123; super.didUpdateWidget(oldWidget); if (oldWidget.dropdownMenuEntries != widget.dropdownMenuEntries) &#123; _menuHasEnabledItem = filteredEntries.any((DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.enabled); &#125; if (oldWidget.leadingIcon != widget.leadingIcon) &#123; refreshLeadingPadding(); &#125; if (oldWidget.initialSelection != widget.initialSelection) &#123; final int index = filteredEntries.indexWhere( (DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.value == widget.initialSelection); if (index != -1) &#123; _textEditingController.text = filteredEntries[index].label; _textEditingController.selection = TextSelection.collapsed(offset: _textEditingController.text.length); &#125; &#125; &#125; bool canRequestFocus() &#123; if (widget.requestFocusOnTap != null) &#123; return widget.requestFocusOnTap!; &#125; switch (Theme.of(context).platform) &#123; case TargetPlatform.iOS: case TargetPlatform.android: case TargetPlatform.fuchsia: return false; case TargetPlatform.macOS: case TargetPlatform.linux: case TargetPlatform.windows: return true; &#125; &#125; void refreshLeadingPadding() &#123; WidgetsBinding.instance.addPostFrameCallback((_) &#123; setState(() &#123; leadingPadding = getWidth(_leadingKey); &#125;); &#125;); &#125; double? getWidth(GlobalKey key) &#123; final BuildContext? context = key.currentContext; if (context != null) &#123; final RenderBox box = context.findRenderObject()! as RenderBox; return box.size.width; &#125; return null; &#125; List&lt;DropdownMenuEntry&lt;T&gt;&gt; filter(List&lt;DropdownMenuEntry&lt;T&gt;&gt; entries, TextEditingController textEditingController) &#123; final String filterText = textEditingController.text.toLowerCase(); return entries .where((DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.label.toLowerCase().contains(filterText)) .toList(); &#125; int? search(List&lt;DropdownMenuEntry&lt;T&gt;&gt; entries, TextEditingController textEditingController) &#123; final String searchText = textEditingController.value.text.toLowerCase(); if (searchText.isEmpty) &#123; return null; &#125; final int index = entries.indexWhere((DropdownMenuEntry&lt;T&gt; entry) =&gt; entry.label.toLowerCase().contains(searchText)); return index != -1 ? index : null; &#125; List&lt;Widget&gt; _buildButtons(List&lt;DropdownMenuEntry&lt;T&gt;&gt; filteredEntries, TextEditingController textEditingController, TextDirection textDirection, &#123;int? focusedIndex&#125;) &#123; final List&lt;Widget&gt; result = &lt;Widget&gt;[]; final double padding = leadingPadding ?? _kDefaultHorizontalPadding; final ButtonStyle defaultStyle; switch (textDirection) &#123; case TextDirection.rtl: defaultStyle = MenuItemButton.styleFrom( padding: EdgeInsets.only(left: _kDefaultHorizontalPadding, right: padding), ); break; case TextDirection.ltr: defaultStyle = MenuItemButton.styleFrom( padding: EdgeInsets.only(left: padding, right: _kDefaultHorizontalPadding), ); &#125; for (int i = 0; i &lt; filteredEntries.length; i++) &#123; final DropdownMenuEntry&lt;T&gt; entry = filteredEntries[i]; ButtonStyle effectiveStyle = entry.style ?? defaultStyle; final Color focusedBackgroundColor = effectiveStyle.foregroundColor ?.resolve(&lt;MaterialState&gt;&#123;MaterialState.focused&#125;) ?? Theme.of(context).colorScheme.onSurface; // Simulate the focused state because the text field should always be focused // during traversal. If the menu item has a custom foreground color, the &quot;focused&quot; // color will also change to foregroundColor.withOpacity(0.12). effectiveStyle = entry.enabled &amp;&amp; i == focusedIndex ? effectiveStyle.copyWith( backgroundColor: MaterialStatePropertyAll&lt;Color&gt;( focusedBackgroundColor.withOpacity(0.12))) : effectiveStyle; final MenuItemButton menuItemButton = MenuItemButton( style: effectiveStyle, leadingIcon: entry.leadingIcon, trailingIcon: entry.trailingIcon, onPressed: entry.enabled ? () &#123; textEditingController.text = entry.label; textEditingController.selection = TextSelection.collapsed( offset: textEditingController.text.length); currentHighlight = widget.enableSearch ? i : null; widget.onSelected?.call(entry.value); &#125; : null, requestFocusOnHover: false, child: Text(entry.label), ); result.add(menuItemButton); &#125; return result; &#125; void handleUpKeyInvoke(_) =&gt; setState(() &#123; if (!_menuHasEnabledItem || !_controller.isOpen) &#123; return; &#125; _enableFilter = false; currentHighlight ??= 0; currentHighlight = (currentHighlight! - 1) % filteredEntries.length; while (!filteredEntries[currentHighlight!].enabled) &#123; currentHighlight = (currentHighlight! - 1) % filteredEntries.length; &#125; final String currentLabel = filteredEntries[currentHighlight!].label; _textEditingController.text = currentLabel; _textEditingController.selection = TextSelection.collapsed(offset: _textEditingController.text.length); &#125;); void handleDownKeyInvoke(_) =&gt; setState(() &#123; if (!_menuHasEnabledItem || !_controller.isOpen) &#123; return; &#125; _enableFilter = false; currentHighlight ??= -1; currentHighlight = (currentHighlight! + 1) % filteredEntries.length; while (!filteredEntries[currentHighlight!].enabled) &#123; currentHighlight = (currentHighlight! + 1) % filteredEntries.length; &#125; final String currentLabel = filteredEntries[currentHighlight!].label; _textEditingController.text = currentLabel; _textEditingController.selection = TextSelection.collapsed(offset: _textEditingController.text.length); &#125;); void handlePressed(MenuController controller) &#123; if (controller.isOpen) &#123; currentHighlight = null; controller.close(); &#125; else &#123; // close to open if (_textEditingController.text.isNotEmpty) &#123; _enableFilter = false; &#125; controller.open(); &#125; setState(() &#123;&#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; final TextDirection textDirection = Directionality.of(context); _initialMenu ??= _buildButtons( widget.dropdownMenuEntries, _textEditingController, textDirection); final DropdownMenuThemeData theme = DropdownMenuTheme.of(context); final DropdownMenuThemeData defaults = _DropdownMenuDefaultsM3(context); if (_enableFilter) &#123; filteredEntries = filter(widget.dropdownMenuEntries, _textEditingController); &#125; if (widget.enableSearch) &#123; currentHighlight = search(filteredEntries, _textEditingController); &#125; final List&lt;Widget&gt; menu = _buildButtons( filteredEntries, _textEditingController, textDirection, focusedIndex: currentHighlight); final TextStyle? effectiveTextStyle = widget.textStyle ?? theme.textStyle ?? defaults.textStyle; MenuStyle? effectiveMenuStyle = widget.menuStyle ?? theme.menuStyle ?? defaults.menuStyle!; final double? anchorWidth = getWidth(_anchorKey); if (widget.width != null) &#123; effectiveMenuStyle = effectiveMenuStyle.copyWith( minimumSize: MaterialStatePropertyAll&lt;Size?&gt;(Size(widget.width!, 0.0))); &#125; else if (anchorWidth != null) &#123; effectiveMenuStyle = effectiveMenuStyle.copyWith( minimumSize: MaterialStatePropertyAll&lt;Size?&gt;(Size(anchorWidth, 0.0))); &#125; if (widget.menuHeight != null) &#123; effectiveMenuStyle = effectiveMenuStyle.copyWith( maximumSize: MaterialStatePropertyAll&lt;Size&gt;( Size(double.infinity, widget.menuHeight!))); &#125; final InputDecorationTheme effectiveInputDecorationTheme = widget.inputDecorationTheme ?? theme.inputDecorationTheme ?? defaults.inputDecorationTheme!; final MouseCursor effectiveMouseCursor = canRequestFocus() ? SystemMouseCursors.text : SystemMouseCursors.click; return Shortcuts( shortcuts: _kMenuTraversalShortcuts, child: Actions( actions: &lt;Type, Action&lt;Intent&gt;&gt;&#123; _ArrowUpIntent: CallbackAction&lt;_ArrowUpIntent&gt;( onInvoke: handleUpKeyInvoke, ), _ArrowDownIntent: CallbackAction&lt;_ArrowDownIntent&gt;( onInvoke: handleDownKeyInvoke, ), &#125;, child: MenuAnchor( style: effectiveMenuStyle, controller: _controller, menuChildren: menu, crossAxisUnconstrained: false, // 将建议设置为与搜索框宽度相同 onClose: () &#123; // setState(() &#123;&#125;); &#125;, // To update the status of the IconButton // 搜索框布局 builder: (BuildContext context, MenuController controller, Widget? child) &#123; assert(_initialMenu != null); final Widget? trailingButton; if (widget.trailingIcon != null) &#123; trailingButton = Padding( padding: const EdgeInsets.all(4.0), child: IconButton( isSelected: controller.isOpen, icon: widget.trailingIcon ?? const Icon(Icons.arrow_drop_down), selectedIcon: widget.selectedTrailingIcon ?? const Icon(Icons.arrow_drop_up), onPressed: () &#123; handlePressed(controller); &#125;, ), ); &#125; else &#123; trailingButton = null; &#125; final Widget leadingButton = Padding( padding: const EdgeInsets.all(8.0), child: widget.leadingIcon ?? const SizedBox()); return _DropdownMenuBody( width: widget.width, children: &lt;Widget&gt;[ TextField( key: _anchorKey, mouseCursor: effectiveMouseCursor, canRequestFocus: canRequestFocus(), enableInteractiveSelection: canRequestFocus(), textAlignVertical: TextAlignVertical.center, style: effectiveTextStyle, controller: _textEditingController, onEditingComplete: () &#123; if (currentHighlight != null) &#123; final DropdownMenuEntry&lt;T&gt; entry = filteredEntries[currentHighlight!]; if (entry.enabled) &#123; _textEditingController.text = entry.label; _textEditingController.selection = TextSelection.collapsed( offset: _textEditingController.text.length); widget.onSelected?.call(entry.value); &#125; &#125; else &#123; widget.onSelected?.call(null); &#125; if (!widget.enableSearch) &#123; currentHighlight = null; &#125; if (_textEditingController.text.isNotEmpty) &#123; controller.close(); &#125; &#125;, onTap: () &#123; handlePressed(controller); &#125;, onChanged: (String text) &#123; controller.open(); setState(() &#123; filteredEntries = widget.dropdownMenuEntries; _enableFilter = widget.enableFilter; &#125;); &#125;, decoration: InputDecoration( enabled: widget.enabled, label: widget.label, hintText: widget.hintText, helperText: widget.helperText, errorText: widget.errorText, contentPadding: widget.contentPadding, isCollapsed: widget.isCollapsed, prefixIcon: widget.leadingIcon != null ? Container( key: _leadingKey, child: widget.leadingIcon) : null, suffixIcon: trailingButton, ).applyDefaults(effectiveInputDecorationTheme)), for (Widget c in _initialMenu!) c, if (trailingButton != null) trailingButton, leadingButton, ], ); &#125;, ), ), ); &#125;&#125;class _ArrowUpIntent extends Intent &#123; const _ArrowUpIntent();&#125;class _ArrowDownIntent extends Intent &#123; const _ArrowDownIntent();&#125;class _DropdownMenuBody extends MultiChildRenderObjectWidget &#123; const _DropdownMenuBody(&#123; super.children, this.width, &#125;); final double? width; @override _RenderDropdownMenuBody createRenderObject(BuildContext context) &#123; return _RenderDropdownMenuBody( width: width, ); &#125;&#125;class _DropdownMenuBodyParentData extends ContainerBoxParentData&lt;RenderBox&gt; &#123;&#125;class _RenderDropdownMenuBody extends RenderBox with ContainerRenderObjectMixin&lt;RenderBox, _DropdownMenuBodyParentData&gt;, RenderBoxContainerDefaultsMixin&lt;RenderBox, _DropdownMenuBodyParentData&gt; &#123; _RenderDropdownMenuBody(&#123; this.width, &#125;); final double? width; @override void setupParentData(RenderBox child) &#123; if (child.parentData is! _DropdownMenuBodyParentData) &#123; child.parentData = _DropdownMenuBodyParentData(); &#125; &#125; @override void performLayout() &#123; final BoxConstraints constraints = this.constraints; double maxWidth = 0.0; double? maxHeight; RenderBox? child = firstChild; final BoxConstraints innerConstraints = BoxConstraints( maxWidth: width ?? computeMaxIntrinsicWidth(constraints.maxWidth), maxHeight: computeMaxIntrinsicHeight(constraints.maxHeight), ); while (child != null) &#123; if (child == firstChild) &#123; child.layout(innerConstraints, parentUsesSize: true); maxHeight ??= child.size.height; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; assert(child.parentData == childParentData); child = childParentData.nextSibling; continue; &#125; child.layout(innerConstraints, parentUsesSize: true); final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; childParentData.offset = Offset.zero; maxWidth = math.max(maxWidth, child.size.width); maxHeight ??= child.size.height; assert(child.parentData == childParentData); child = childParentData.nextSibling; &#125; assert(maxHeight != null); maxWidth = math.max(_kMinimumWidth, maxWidth); size = constraints.constrain(Size(width ?? maxWidth, maxHeight!)); &#125; @override void paint(PaintingContext context, Offset offset) &#123; final RenderBox? child = firstChild; if (child != null) &#123; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; context.paintChild(child, offset + childParentData.offset); &#125; &#125; @override Size computeDryLayout(BoxConstraints constraints) &#123; final BoxConstraints constraints = this.constraints; double maxWidth = 0.0; double? maxHeight; RenderBox? child = firstChild; final BoxConstraints innerConstraints = BoxConstraints( maxWidth: width ?? computeMaxIntrinsicWidth(constraints.maxWidth), maxHeight: computeMaxIntrinsicHeight(constraints.maxHeight), ); while (child != null) &#123; if (child == firstChild) &#123; final Size childSize = child.getDryLayout(innerConstraints); maxHeight ??= childSize.height; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; assert(child.parentData == childParentData); child = childParentData.nextSibling; continue; &#125; final Size childSize = child.getDryLayout(innerConstraints); final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; childParentData.offset = Offset.zero; maxWidth = math.max(maxWidth, childSize.width); maxHeight ??= childSize.height; assert(child.parentData == childParentData); child = childParentData.nextSibling; &#125; assert(maxHeight != null); maxWidth = math.max(_kMinimumWidth, maxWidth); return constraints.constrain(Size(width ?? maxWidth, maxHeight!)); &#125; @override double computeMinIntrinsicWidth(double height) &#123; RenderBox? child = firstChild; double width = 0; while (child != null) &#123; if (child == firstChild) &#123; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; child = childParentData.nextSibling; continue; &#125; final double maxIntrinsicWidth = child.getMinIntrinsicWidth(height); if (child == lastChild) &#123; width += maxIntrinsicWidth; &#125; if (child == childBefore(lastChild!)) &#123; width += maxIntrinsicWidth; &#125; width = math.max(width, maxIntrinsicWidth); final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; child = childParentData.nextSibling; &#125; return math.max(width, _kMinimumWidth); &#125; @override double computeMaxIntrinsicWidth(double height) &#123; RenderBox? child = firstChild; double width = 0; while (child != null) &#123; if (child == firstChild) &#123; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; child = childParentData.nextSibling; continue; &#125; final double maxIntrinsicWidth = child.getMaxIntrinsicWidth(height); // Add the width of leading Icon. if (child == lastChild) &#123; width += maxIntrinsicWidth; &#125; // Add the width of trailing Icon. if (child == childBefore(lastChild!)) &#123; width += maxIntrinsicWidth; &#125; width = math.max(width, maxIntrinsicWidth); final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; child = childParentData.nextSibling; &#125; return math.max(width, _kMinimumWidth); &#125; @override double computeMinIntrinsicHeight(double height) &#123; final RenderBox? child = firstChild; double width = 0; if (child != null) &#123; width = math.max(width, child.getMinIntrinsicHeight(height)); &#125; return width; &#125; @override double computeMaxIntrinsicHeight(double height) &#123; final RenderBox? child = firstChild; double width = 0; if (child != null) &#123; width = math.max(width, child.getMaxIntrinsicHeight(height)); &#125; return width; &#125; @override bool hitTestChildren(BoxHitTestResult result, &#123;required Offset position&#125;) &#123; final RenderBox? child = firstChild; if (child != null) &#123; final _DropdownMenuBodyParentData childParentData = child.parentData! as _DropdownMenuBodyParentData; final bool isHit = result.addWithPaintOffset( offset: childParentData.offset, position: position, hitTest: (BoxHitTestResult result, Offset transformed) &#123; assert(transformed == position - childParentData.offset); return child.hitTest(result, position: transformed); &#125;, ); if (isHit) &#123; return true; &#125; &#125; return false; &#125;&#125;// Hand coded defaults. These will be updated once we have tokens/spec.class _DropdownMenuDefaultsM3 extends DropdownMenuThemeData &#123; _DropdownMenuDefaultsM3(this.context); final BuildContext context; late final ThemeData _theme = Theme.of(context); @override TextStyle? get textStyle =&gt; _theme.textTheme.labelLarge; @override MenuStyle get menuStyle &#123; return const MenuStyle( minimumSize: MaterialStatePropertyAll&lt;Size&gt;(Size(_kMinimumWidth, 0.0)), maximumSize: MaterialStatePropertyAll&lt;Size&gt;(Size.infinite), visualDensity: VisualDensity.standard, ); &#125; @override InputDecorationTheme get inputDecorationTheme &#123; return const InputDecorationTheme(border: OutlineInputBorder()); &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Flutter组件记录","slug":"Flutter组件记录","date":"2024-03-13T15:22:12.000Z","updated":"2024-03-19T13:00:08.675Z","comments":true,"path":"2024/03/13/Flutter组件记录/","link":"","permalink":"http://princesaoke.github.io/2024/03/13/Flutter%E7%BB%84%E4%BB%B6%E8%AE%B0%E5%BD%95/","excerpt":"","text":"参考文章较老旧，可能有部分组件被弃用 部分组件未经使用过，无法确认描述正确性，仅供参考 信息展示Tooltip一个文本提示工具，帮助解释一个按钮或其他用户界面，当widget长时间按下时（当用户采取其他适当操作时）显示一个提示标签 LinearProgressIndicator &amp; CircularProgressIndicator线性进度条和环形进度条 RichText富文本Text，可以显示多种样式的text Stepper一个Material Design 步骤指示器，显示一系列步骤的过程 iOS风格CupertinoActivityIndicatoriOS风格的加载条，一个圆形的转圈菊花 CupertinoAlertDialogCupertinoButtonCupertinoDialogCupertinoDialogAction通常用于CupertinoAlertDialog的按钮 CupertinoSlideriOS风格的滑动条 CupertinoSwitchiOS风格的开关，美观且常用 CupertinoPageTransition提供iOS风格的页面过度动画 CupertinoNavigationBariOS风格的导航栏，通常和CupertinoPageScaffold一起使用 CupertinoTabBariOS风格的底部选项卡，通常和CupertinoTabScaffold一起使用 CupertinoPageScaffold一个iOS风格的页面的基本布局结构，包含内容和导航栏 CupertinoTabScaffold标签式iOS应用程序的结构，将选项卡栏放在内容选项卡之上 CupertinoTabView支持选项卡间并行导航项卡的根内容，通常与CupertinoTabScaffolde一起使用 手势交互LongPressDraggable其子widget在长按时可拖动 DragTarget一个拖动的目标widget，在完成拖动时它可以接收数据 Dismissible可以在拖动时隐藏的widget IgnorePointer手势将会穿透被其包裹的组件，如将其包裹在弹窗外，则可以穿过弹窗点击到下一层 AbsorbPointer可对children统一设置是否接收手势 容器AspectRatio指定子组件的宽高比 ConstrainedBox对其子项施加附加约束，如： 1234return ConstrainedBox( minWidth: 100, child: Container(width: 50), // 宽度小于最大宽度则不生效，宽度仍为100); Baseline根据子项的基线对它们的位置进行定位 Visibility根据传入的布尔值决定是否显示子组件 FutureBuilder基于与Future交互的最新快照来构建子组件 StreamBuilder基于与流交互的最新快照构建自身的子组件 绘制和裁剪ClipOval将子组件裁剪为椭圆 ClipRect将子组件裁剪为矩形 ClipPath用path绘制形状裁剪其子组件 CustomPaint提供一个画布，可在画布上绘制自定义图形 滚动布局SingleChildScrollView子组件超过父容器时可以滚动 Scrollbar一个 Material Design 滚动条，表示当前滚动到了什么位置 RefreshIndicator下拉刷新组件 Scrollable实现了可滚动widget的交互模型，但不包含UI显示相关的逻辑 NestedScrollView可嵌套其它滚动布局","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"JavaScript笔记","slug":"JavaScript笔记","date":"2024-03-12T16:39:38.000Z","updated":"2024-03-12T16:50:12.513Z","comments":true,"path":"2024/03/13/JavaScript笔记/","link":"","permalink":"http://princesaoke.github.io/2024/03/13/JavaScript%E7%AC%94%E8%AE%B0/","excerpt":"","text":"const、let、var的区别const是常量，定义时必须赋初值，值不可修改。只限制变量绑定的值，不会限制引用数据类型内部的变动。如： 12345678const a = 1a = 2 // 报错const b = &#123; name: &#x27;张三&#x27;&#125;b.name = &#x27;李四&#x27; // 不会报错b = 1 // 报错 let声明的是变量。 const和let只在块内有效，即两个花括号之间，相当于局部的值。 var定义的变量是全局的，但一个函数内var的变量不能在函数外访问。 12345678var a = &#x27;我是a&#x27;function fun() &#123; console.log(a) // 输出&#x27;我是a&#x27; var b = &#x27;我是b&#x27;&#125;console.log(b) // 报错 用var定义两个同名变量，后定义的会覆盖掉先定义的。const和let不允许重复定义。 var存在变量提升的特性。当用var定义了一个变量，即便还未执行到，该变量也已经存在了，且值为undefined。 123456function fun() &#123; if (a == undefined) &#123; var a = 10 &#125; console.log(a) // 输出为10&#125; 造成这种现象的原因是，if中用var定义了a，因变量提升（hoisting）特性，在执行前a被提升到函数作用域顶部，且初始值为undefined，于是if成立，早已存在的a由undefined被赋值为10。 将var改用let就不会有这样的问题。 总结：无特殊情况不要用var，声明变量用let。声明对象类型用const，非对象类型用let。 innerHTML 和 innerText 的区别12345678910111213&lt;html&gt; &lt;head&gt;&lt;title&gt;innerHTML与innerText的区别&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;hello world &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); alert(div1.innerHTML); // &lt;p id=&quot;p1&quot;&gt;hello world &lt;/p&gt; alert(div1.innerText) // hello world &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 正则表达式各种正则表达式样例 一些常用的正则校验 正则表达式剔除HTML标签与markdown语法符号生成文章简介12345678910111213141516171819202122232425/// 剔除文章中的markdown语法符号，剔除所有html标签const removeHTML = (htmlStr: string): string =&gt; &#123; // 定义script的正则表达式，去除js可以防止注入 const scriptRegex: RegExp = new RegExp(&#x27;&lt;script[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/script&gt;&#x27;, &#x27;gm&#x27;) // 定义style的正则表达式，去除style样式，防止css代码过多时只截取到css样式代码 const styleRegex: RegExp = new RegExp(&#x27;&lt;style[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/style&gt;&#x27;, &#x27;gm&#x27;) // 定义HTML标签的正则表达式，去除标签，只提取文字内容 const htmlRegex: RegExp = new RegExp(&#x27;&lt;[^&gt;]+&gt;&#x27;, &#x27;gm&#x27;) // 定义空格,回车,换行符,制表符 const spaceRegex: RegExp = new RegExp(&#x27;\\\\s*|\\t|\\r|\\n&#x27;, &#x27;gm&#x27;) // 过滤script标签 htmlStr = htmlStr.replace(scriptRegex, &quot;&quot;); // 过滤style标签 htmlStr = htmlStr.replace(styleRegex, &quot;&quot;); // 过滤html标签 htmlStr = htmlStr.replace(htmlRegex, &quot;&quot;); // 过滤空格等 htmlStr = htmlStr.replace(spaceRegex, &quot; &quot;); return htmlStr.trim().substring(0, 100); // 返回文本字符串，最大长度100&#125; 剔除&lt;script&gt;标签可以防止XSS攻击","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://princesaoke.github.io/tags/JavaScript/"}]},{"title":"HTML笔记","slug":"HTML笔记","date":"2024-03-12T16:35:07.000Z","updated":"2024-03-12T16:50:54.079Z","comments":true,"path":"2024/03/13/HTML笔记/","link":"","permalink":"http://princesaoke.github.io/2024/03/13/HTML%E7%AC%94%E8%AE%B0/","excerpt":"","text":"使用阿里巴巴图标库的图标这里只介绍通过在线链接的方法。 进入阿里巴巴图标库，选好需要的图标，放入购物车后将其加入项目。 进入资源管理-&gt;我的项目，切换到Font class，点击查看在线链接。 生成一个css链接，如//at.alicdn.com/t/c/font_4287312_tew9cz81kg.css，需要在前面加上http:，然后在HTML中引入： 123456&lt;head&gt; &lt;!-- 引入阿里巴巴图标库的项目 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/c/font_4287312_tew9cz81kg.css&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 用&lt;i&gt;元素使用图表，需要添加两个class：iconfont和对应的图标代码，如： 1234&lt;body&gt; &lt;!-- 假设图标代码为`icon-qq` --&gt; &lt;i class=&quot;iconfont icon-qq&quot;&gt;&lt;/i&gt;&lt;/body&gt; 其中图标代码可以在阿里巴巴图标库中复制 附上参考文章，其中有说明其他的引入图标方式","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://princesaoke.github.io/tags/HTML/"}]},{"title":"Web安全漏洞","slug":"Web安全漏洞","date":"2024-01-09T16:23:39.000Z","updated":"2024-05-15T07:57:49.930Z","comments":true,"path":"2024/01/10/Web安全漏洞/","link":"","permalink":"http://princesaoke.github.io/2024/01/10/Web%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"CSRFCSRF是什么 XSS浅谈XSS攻击的那些事（附常用绕过姿势） 存储型XSS反射型XSS","categories":[],"tags":[]},{"title":"CSS笔记","slug":"CSS笔记","date":"2023-12-25T16:37:29.000Z","updated":"2023-12-25T16:57:53.588Z","comments":true,"path":"2023/12/26/CSS笔记/","link":"","permalink":"http://princesaoke.github.io/2023/12/26/CSS%E7%AC%94%E8%AE%B0/","excerpt":"","text":"盒子模型 元素的总宽度为：margin-left+border+padding-left+width+padding-right+border+margin-right 所以如果元素有margin、border、padding，实际大小会比CSS中写的width和height更大。 box-sizing属性可以令width和height直接包含padding和border。","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://princesaoke.github.io/tags/CSS/"}]},{"title":"智元机器人客户端实习面经","slug":"智元机器人客户端实习面经","date":"2023-12-12T08:01:09.000Z","updated":"2024-05-08T07:54:31.239Z","comments":true,"path":"2023/12/12/智元机器人客户端实习面经/","link":"","permalink":"http://princesaoke.github.io/2023/12/12/%E6%99%BA%E5%85%83%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"面试是一个月以前的事了，已经被录用，有些地方记不清了。总共面了两轮，都是飞书线上面试。每次面试最后都有反问环节，我都事先准备了要反问的问题。 一面一面问的都是Flutter相关的技术问题，完全没有牵扯到其他方面，面试官是负责社招的，实习后也由他来带我。总共面了40分钟左右，问题如下，打钩的是我觉得算回答出来的： ✔ 自我介绍 ✔ 学习Flutter多久了？ ❌ 了解Dart中的dynamic和var吗？它们赋值后可以更改数据类型吗？ ✔ const和final的区别，late的用法？ ✔ Dart空安全相关，?.和?? ❌ Dart如何实现单例？ ❌ 给一张UI图，说出大致的布局实现方式？ ✔ 要点击导航栏切换body，如何实现？ ❌ 快速点击导航栏切换页面，多个页面请求完成后在短时间内快速渲染，页面会出现闪烁，如何解决？ ❌ 更改页面的宽度，要icon不变，仅缩小文字的宽度，文字溢出设置成省略号的样式，如何实现？ ✔ Dart中的可选参数是什么，有什么用，如何设置其默认值？ ❌ 组件前加const起到什么作用？ ❌ 如何实现局部刷新？ ✔ 如何实现动画？如改变透明度、位移、旋转等 ✔ 如何用Flutter的Canvas绘制出折线、带填充的矩形？ 问到动画和Canvas是因为简历上有写。 Dart中的var和js类似，是可变的，当时没接触到这个概念。单例的实现见Dart笔记，页面闪烁用防双击处理，局部刷新用ValueNotifier。 一面个人感觉挺失败的，很多问题都没回答上来。比如给UI图实现布局，我有开发经验按理这不是难事，但面试官给的是PC端的页面，我之前做的都是移动端，导航栏在底部，PC端导航栏在左边，而且一些布局也略微不同，加上面试是直接口述而非敲代码可以修改，一时有点无从下手，气氛明显尴尬了起来。问到局部刷新，我记得似乎曾经在某个帖子有看到过SafeArea与之相关，就半蒙半猜地说了，面试结束后一百度，根本是牛头不对马嘴……面到后面自己都没自信了，只想快点结束。 当时面完就觉得没戏了，没想到过了两天居然收到了hr的电话，约了二面。 二面二面的问题更有开放性，面试官好像是软件部门的主管，有开摄像头，在我回答不出来的时候会引导我思考，所以感觉会轻松一些，总共20多分钟。 ✔ 自我介绍 ✔ 为什么想要来实习？ ✔ 为什么学习Flutter？ ❌ 为什么Flutter选用Dart作语言？Dart优势何在？ ✔ 问项目，哪些功能是调用第三方接口？项目是否获奖？开发中最大的困难是什么？ ❌ 结合信安专业，如何防止攻击者破解用户账号密码？ ✔ 除了移动端、Flutter，是否关注了其他技术相关的东西或行业发展？ 和一面相比明显感觉二面的问题更综合考量一个人的能力、行业理解和培养价值。 有点出乎我意料的是，面试官看到我是信安专业的，问了我安全方面的问题。先是问有什么提高账号安全性的方法，我回答数据库密码存储哈希值而非明文、做输入检查防止SQL注入等。又问如果有人尝试用暴力尝试的方法破解密码应该如何防御？我回答加验证码。又问现在AI很强大，可以完成验证，是否有别的方法？面试官提示如果绕过客户端直接给后端发包呢，我回答APP加混淆避免反编译，不要让攻击者知道接口URL。面试官说加混淆可以，但接口总是要暴露在外的，有没有别的办法？我回答后端判断短时间内是否有同一个IP地址多次尝试登录同一个账号，如果是说明有人在暴力破解，就拒绝请求。面试官说如果是在连校园网的环境下，很多设备的IP地址是一样的，可能造成“误伤”，并且后端如何知道设备的登录次数呢？又问如果是固定密码去试账号要如何防御？最后我没有回答出来，面试官说这可能要不止一次网络请求，应该是属于进阶一点的问题了。 最后反问环节我问面试官我有哪些地方表达得不好，面试官回答这不能说。他告诉我大概五个工作日内会有结果，这一等就是半个月，就在我以为凉凉了要准备投下一份简历的时候，又接到了hr的电话，被录用了。 现在回想起来，还是有很多可以改进的地方。 首先是自我介绍，我觉得可以准备得充分些，简历上有的就不用说太多了，可以突出个人优势，也好暗示面试官的关注重点。如果只是把简历上已有的信息说一遍意义不大。 其次是有些地方没get到面试官想问的点。比如二面问后端如何知道设备的登录次数，应该是想问服务器如何识别是同一台设备，需要用到cookie什么的，当时脑子没转过弯来没想到考察的是cookie。 复盘后发觉两次面试都答的不咋地，没想到还能被录用，或许技术栈符合也是很重要的原因之一吧，也是很感谢面试官能给我这个机会。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"Vue3笔记","slug":"Vue3笔记","date":"2023-11-28T08:55:45.000Z","updated":"2024-03-12T16:02:58.228Z","comments":true,"path":"2023/11/28/Vue3笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/28/Vue3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Vue3官方文档 参考文章： 手把手教你使用Vite创建Vue3项目 尚硅谷甄选 创建项目终端运行： 1npm create vue@latest 使用 Vite 创建项目注意：Vite 需要 Node.js 版本 18+，20+ 终端执行： 1npm create vite@latest 指令v-html&#123;&#123; button &#125;&#125;中元素不会被解析，需要用&lt;div v-html=&quot;button&quot;&gt; 12345678&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const button = ref(&#x27;&lt;button&gt;Click Me&lt;/button&gt;&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div v-html=&quot;button&quot;&gt;&lt;/div&gt;&lt;/template&gt; 相当于将&lt;div&gt;的innerHTML设为button中的元素 v-bind使用指令v-bind:属性名=&quot;&quot;或其简写:属性名=&quot;&quot;为元素添加单个属性，或者使用v-bind=&quot;&quot;添加多个属性，具体如下： 12345678910111213141516&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const myId = ref(&#x27;nav&#x27;) const myClass = ref(&#x27;container&#x27;) const isButtonDisabled = ref(true) const myAttr = &#123; id: &#x27;nav&#x27;, class: &#x27;container&#x27; &#125;&lt;/script&gt;&lt;template&gt; &lt;div v-bind:id=&quot;myId&quot; :class=&quot;myClass&quot;&gt;bind&lt;/div&gt; &lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; &lt;span v-bind=&quot;myAttr&quot;&gt;&lt;/span&gt;&lt;/template&gt; v-for12345678910111213141516&lt;script setup&gt; import &#123; reactive &#125; from &#x27;vue&#x27; const stars = reactive([ &#123; name: &#x27;角木蛟&#x27;, part: &#x27;东方苍龙&#x27; &#125;, &#123; name: &#x27;井木犴&#x27;, part: &#x27;南方朱雀&#x27; &#125;, &#123; name: &#x27;奎木狼&#x27;, part: &#x27;西方白虎&#x27; &#125;, &#123; name: &#x27;斗木獬&#x27;, part: &#x27;北方玄武&#x27; &#125;, ])&lt;/script&gt;&lt;template&gt; &lt;ul v-for=&quot;star in stars&quot;&gt; &lt;li&gt;星宿名：&#123;&#123; star.name &#125;&#125;，所属星象：&#123;&#123; star.part &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; v-if 和 v-show 的区别v-show不管初始条件是否为真，元素都会被渲染，只不过是根据条件修改元素的样式来判断是否显示。当v-show=&quot;false&quot;时，给元素加上style=&quot;display: none;&quot;，当v-show=&quot;true&quot;时，移除该样式。因此元素始终是存在的。 v-if=&quot;false&quot;则是将元素直接删除，DOM元素不再存在。 由于v-show始终都会渲染元素，因此有更高的初始渲染消耗，而v-if若为假则初始时不需要渲染，则没有这部分的消耗。但切换时v-show只需要移除display: none，因此相比v-if的切换消耗会更低。 如果需要频繁切换则用v-show，如果在运行时很少改变则用v-if。 响应式数据ref 和 reactive 的区别12345&lt;script setup&gt; import &#123; ref, reactive &#125; from &#x27;vue&#x27; const count = ref(0) const user = reactive(&#123; id: 1, name: &#x27;星日马&#x27; &#125;)&lt;/script&gt; ref可以用于基本数据类型和对象，但reactive只能用于对象 访问ref的值要count.value，而访问reactive的值直接user不需要加value ref适合基本数据类型，reactive适合对象 单独将ref对象中的变量赋值给新变量，新变量也支持响应式；但对reactive进行同样操作则新变量不具备响应式 ref通过外层包裹一个对象来实现，reactive通过proxy实现 toRef将普通变量和响应式对象的成员变量进行双向响应式绑定，不论是改变普通变量的值还是成员变量的值，数据都会更新，解决了reactive无法抽离出响应式变量的问题。 123456789101112131415161718192021222324&lt;script setup&gt; import &#123; ref, reactive, toRef &#125; from &#x27;vue&#x27; const flower = ref(&#123; name: &#x27;梅花&#x27;, price: 48 &#125;) const user = reactive(&#123; id: 1, name: &#x27;房日兔&#x27; &#125;) const flowerPrice = toRef(flower.value, &#x27;price&#x27;) let userId = toRef(user, &#x27;id&#x27;) setInterval(() =&gt; &#123; flower.value.price++ // 改变对象的成员变量的值，普通变量的值也会更新 userId.value++ // 改变普通变量的值，成员变量也会更新 &#125;, 1000);&lt;/script&gt;&lt;template&gt; &lt;h1&gt;flowerPrice: &#123;&#123; flowerPrice &#125;&#125;&lt;/h1&gt; &lt;h1&gt;userId: &#123;&#123; userId &#125;&#125;&lt;/h1&gt;&lt;/template&gt; toRefs与toRef的区别尚不明确。 123456789101112131415161718192021222324&lt;script setup&gt; import &#123; ref, reactive, toRefs &#125; from &#x27;vue&#x27; const flower = ref(&#123; name: &#x27;梅花&#x27;, price: 48 &#125;) const user = reactive(&#123; id: 1, name: &#x27;房日兔&#x27; &#125;) let flowerPrice = toRefs(flower.value)[&#x27;price&#x27;] let userId = toRefs(user).id setInterval(() =&gt; &#123; flower.value.price++ userId.value++ &#125;, 1000);&lt;/script&gt;&lt;template&gt; &lt;h1&gt;flowerPrice: &#123;&#123; flowerPrice &#125;&#125;&lt;/h1&gt; &lt;h1&gt;user.id: &#123;&#123; user.id &#125;&#125;&lt;/h1&gt;&lt;/template&gt; 事件处理可以使用v-on指令来监听DOM事件，也可缩写成@，用法： 123456789101112&lt;script setup&gt;function myFunction() &#123; console.log(&#x27;触发了myFunction方法&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;button v-on:click=&quot;myFunction&quot;&gt;&lt;/button&gt; &lt;button @click=&quot;myFunction&quot;&gt;&lt;/button&gt;&lt;/template&gt; 事件修饰符在原生JS中，我们可以使用even.preventDefault()来阻止默认事件或使用event.stopPropagation()阻止事件冒泡，Vue提供了更优雅的实现方式，即事件修饰符： 1234567891011121314151617181920212223&lt;script setup&gt;function myFunction() &#123; console.log(&#x27;触发了myFunction方法&#x27;)&#125;function clickDiv() &#123; console.log(&#x27;点击了div&#x27;)&#125;function clickP() &#123; console.log(&#x27;点击了p&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;a href=&quot;https://PrinceSaoKe.github.io&quot; @click.prevent=&quot;myFunction&quot;&gt;点了不会跳转的超链接&lt;/a&gt; &lt;div @click=&quot;clickDiv&quot;&gt; &lt;p @click.stop=&quot;clickP&quot;&gt;Hello World!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 输出为： 1点击了p 若不加.stop，则输出为： 12点击了p点击了div 该写法等同于： 1234567891011121314151617181920212223242526&lt;script setup&gt;function myFunction(event) &#123; event.preventDefault() console.log(&#x27;触发了myFunction方法&#x27;)&#125;function clickDiv(event) &#123; event.stopPropagation() console.log(&#x27;点击了div&#x27;)&#125;function clickP(event) &#123; event.stopPropagation() console.log(&#x27;点击了p&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;a href=&quot;http://princesaoke.github.io&quot; @click.prevent=&quot;myFunction&quot;&gt;点了不会跳转的超链接&lt;/a&gt; &lt;div @click=&quot;clickDiv&quot;&gt; &lt;p @click=&quot;clickP&quot;&gt;Hello World!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &#x2F;public 文件夹和 &#x2F;src&#x2F;assets 文件夹的区别 引用/public中的文件时不需要写public目录，直接&lt;img src=&quot;/logo.png&quot;&gt;，而引用/src/assets中的文件要写全路径&lt;img src=&quot;@/assets/logo.png&quot;&gt; 打包时/src/assets下的文件会被打包工具处理，包括压缩、重命名等，而/public则不会，是直接复制到dist里 如果文件不需要被处理，如网站的结构用图（favicon.ico、logo图片等），放public；否则如内容图片或者需要被构建为base64的小图标放assets 开发过程中的跨域问题浏览器和后端服务器之间存在跨域问题，但服务器和服务器之间可以随意访问，因此要在本地配置一个代理服务器来做中转，浏览器将请求发到本地代理服务器，代理服务器再发到后端服务器，就不会跨域报错了。 先将axios的baseURL设置为&#39;/api&#39;，然后修改vite.config.ts： 1234567891011121314151617export default defineConfig(&#123; plugins: [ // ... ], server: &#123; port: 5173, open: true, proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://saoke.fun:8080&#x27;, // 代理地址，这里设置的地址会代替axios中设置的baseURL changeOrigin: true, // 如果接口跨域，需要进行这个参数配置 rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;) secure: false, // 如果是https接口需要进行此配置 &#125; &#125; &#125;&#125;) 参考文章：一篇看懂vue如何做调试后台接口的配置和proxy的工作原理以及为什么能解决跨域 简单请求与复杂请求满足以下条件的才是简单请求： 请求方式为GET、POST、HEAD 不能手动设置除Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type之外的请求头 Content-Type的值只限于application/x-www-form-urlencoded、multipart/form-data、text/plain 不能为XMLHttpRequestUpdate注册监听器 请求中没有使用readableStream对象 非简单请求就是复杂请求。 复杂请求会多发一次OPTIONS预请求，服务器返回预响应，成功后才会发送真实请求。预请求存在跨域问题。 参考文章： 简单请求和复杂请求的区别 ajax请求：简单请求&amp;复杂请求 项目构建要将打包好的文件按css、js进行分类，在vite.config.ts进行以下配置： 1234567891011121314151617181920212223export default defineConfig(&#123; plugins: [ // ... ], build: &#123; rollupOptions: &#123; output: &#123; chunkFileNames: &#x27;static/js/[name]-[hash].js&#x27;, entryFileNames: &#x27;static/js/[name]-[hash].js&#x27;, assetFileNames: &#x27;static/[ext]/[name]-[hash][extname]&#x27;, //manualChunks 两种使用形式 // manualChunks:&#123; // elementPlus:[&#x27;element-plus&#x27;] // &#125; manualChunks(id) &#123; if (id.includes(&#x27;element-plus&#x27;)) &#123; return &#x27;element-plus&#x27;; &#125; &#125; &#125; &#125; &#125;&#125;) 参考文章： vue3打包后没有默认进行分包？立马解决⚡ ViteVite官方文档 Vue RouterVue Router 官方文档 参考文章 Element PlusElement Plus 官方文档 PiniaPinia官方文档 参考文章 可能用到的工具 名称 下载方式 官方文档 描述 NVM NVM下载地址 一个nodejs的版本管理工具，通过它可以安装和切换不同版本的nodejs NRM npm install -g nrm npm的镜像管理工具，可以在npm镜像源间快速切换 v-md-editor npm i @kangc&#x2F;v-md-editor -S v-md-editor官方文档 markdown编辑器 highlight.js npm install highlight.js highlight.js 官方文档 为markdown代码块添加高亮","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://princesaoke.github.io/tags/Vue3/"}]},{"title":"MySQL笔记","slug":"MySQL笔记","date":"2023-11-22T08:03:48.000Z","updated":"2023-11-23T12:25:55.475Z","comments":true,"path":"2023/11/22/MySQL笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/22/MySQL%E7%AC%94%E8%AE%B0/","excerpt":"","text":"很全的MySQL常用指令 安装MySQL在官方下载地址下载压缩包。 解压到要保存的路径，在 环境变量 -&gt; 系统变量 -&gt; Path 里面添加一行，指向MySQL的bin目录，如D:\\mysql-8.0.33-winx64\\bin。 在MySQL的bin文件夹里新建文件my.ini，文件内容为： 123456789[mysqld]# 设置mysql的安装目录(能看到bin即可)basedir=D:\\mysql-8.0.33-winx64\\# 设置mysql的数据存放目录datadir=D:\\mysql-8.0.33-winx64\\data\\# mysql端口port=3306# 跳过授权skip-grant-tables 记得把其中的路径换成你自己的安装路径。 然后以管理员身份打开cmd，进入MySQL的bin目录，输入： 1234567891011121314151617# 安装 mysql 服务mysqld –install# 初始化 data 文件夹 （你可以初始化多次，但是每次必须清空data文件夹）mysqld --initialize-insecure --user=mysql# 启动 mysql 服务net start mysql# 登录 mysql(让你输密码，直接回车即可)mysql -uroot -p# 修改 root 账户密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH &#x27;mysql_native_password&#x27; BY &#x27;新密码&#x27;;# 刷新权限，使之生效flush privileges; 然后将my.ini里跳过授权给注释掉# skip-grant-tables 输入\\q退出登录MySQL，然后重启MySQL用新设置的密码登录即可： 123net stop mysqlnet start mysqlmysql -uroot -p mysql -uroot -p这句意思是用户名为root，也可以在-p后直接跟密码，这样密码是可见的。 Windows Server 2022 上遇到的问题安装MySQL和初始化data文件夹时报错：找不到MSVCP140.dll文件解决方法：安装 Microsoft Visual C++ Redistributable 客户端库，点击前往下载。 输入net start mysql时报错：服务没有响应控制功能解决方法：下载VCRUNTIME140_1.dll，解压后拷贝到MySQL的bin文件夹下。 远程连接数据库开放MySQL端口首先要确保服务器的MySQL端口是放行的，在my.ini中我们设置了3306端口。 以阿里云服务器为例，在安全组中手动添加访问规则，目的端口3306，源0.0.0.0。 若端口没有放行，则会有以下报错： 1ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;XXX.XXX.XXX.XXX:3306&#x27; (10060) 设置远程登录权限在服务器上登录MySQL，然后输入： 123use mysql;update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; // 开放远程登录权限flush privileges; // 刷新权限 若没开启权限，则报错： 1ERROR 1130 (HY000): Host &#x27;XXX.XXX.XXX.XXX&#x27; is not allowed to connect to this MySQL server 远程登录MySQL在自己的电脑上打开cmd，输入： 1mysql -h主机地址 -u用户名 -p MySQL数据的备份终端进入MySQL安装目录下的bin目录，执行指令： 1234mysqldump -uroot -p 数据库名 &gt; 备份文件路径及文件名# 如：mysqldump -uroot -p flower_shop &gt; flower_shop_backup.sql MySQL备份数据的还原登录MySQL后执行以下指令： 123create database 数据库名称; // 创建一个新的数据库用于承载迁移来的数据use 数据库名称; // 切换到该数据库source 文件路径; // 导入备份数据 存储过程 &#x2F; Procedure相当于编程语言中的方法，定义SQL语句模板，可以传参调用。 创建一个存储过程，用于查询某种花的价格，调用后删除： 12345678910delimiter $$create procedure getFlowerPrice(in name varchar(15))begin select price from flower where flower.name=name;end $$delimiter ;call getFlowerPrice(&#x27;红玫瑰&#x27;);drop procedure getFlowerPrice; # 删除存储过程 其中delimiter作用是修改SQL语句结束符，避免存储过程中的;和语句结束符混淆。 触发器 &#x2F; Trigger在数据插入、修改、删除时自动执行某些操作，可用于数据库日志记录等。 创建一个触发器，当录入一种花但未给出花语时，将花语设为“暂无”： 123456789101112delimiter $$create trigger my_trigger before insert on flower for each rowbegin if new.flower_language is null then set new.flower_language=&#x27;暂无&#x27;; end if;end $$delimiter ;show triggers; # 查看触发器drop trigger flower_shop.my_trigger; # 删除触发器","categories":[{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://princesaoke.github.io/tags/MySQL/"}]},{"title":"Dart笔记","slug":"Dart笔记","date":"2023-11-08T08:34:56.000Z","updated":"2024-04-01T16:24:35.005Z","comments":true,"path":"2023/11/08/Dart笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/08/Dart%E7%AC%94%E8%AE%B0/","excerpt":"","text":"var 和 dynamicvar未赋初值时，默认值为null，赋值后数据类型可变。 1234var variable;print(variable); // nullvariable = &#x27;我是字符串&#x27;variable = 10.00 dynamic未赋初值时，默认值为null，赋值后数据类型可变，同var。 List.map()常用情景：一个对象列表，要将列表中所有对象的某个属性提取出来进行某些操作，生成一个新的列表： 12List&lt;UserModel&gt; userList = [UserModel(name: &#x27;张三&#x27;, age: 20), UserModel(name: &#x27;李四&#x27;, age: 18)];List&lt;String&gt; nameList = userList.map((user) =&gt; user.name).toList(); Flutter为何采用Dart语言？Dart优势何在？类型拓展方法1234extension DividerExtension on int &#123; /// 垂直方向间距 SizedBox vGap =&gt; SizedBox(height: this);&#125; 用例： 123456789Column(children: [ const Text(&#x27;太阴&#x27;), 20.vGap, const Text(&#x27;太阳&#x27;), 20.vGap, const Text(&#x27;少阴&#x27;), 20.vGap, const Text(&#x27;少阳&#x27;),]); Dart中的工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#x27;package:flutter/material.dart&#x27;;class DebugButton extends StatelessWidget &#123; const DebugButton(&#123; super.key, required this.text, this.onPressed, this.backgroundColor, &#125;); final String text; final void Function()? onPressed; final Color? backgroundColor; /// Primary按钮 const factory DebugButton.primary(&#123; required String text, Color? backgroundColor, void Function()? onPressed, &#125;) = _DebugPrimaryButton; @override Widget build(BuildContext context) &#123; return OutlinedButton( onPressed: () =&gt; onPressed?.call(), style: OutlinedButton.styleFrom( padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 20), backgroundColor: backgroundColor, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)), ), child: Text(text), ); &#125;&#125;class _DebugPrimaryButton extends DebugButton &#123; const _DebugPrimaryButton(&#123; required super.text, super.backgroundColor, super.onPressed, &#125;); @override Widget build(BuildContext context) &#123; return ElevatedButton( onPressed: () =&gt; onPressed?.call(), style: ElevatedButton.styleFrom( padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 20), backgroundColor: backgroundColor, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)), ), child: Text(text), ); &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Kotlin笔记","slug":"Kotlin笔记","date":"2023-10-27T02:52:41.000Z","updated":"2024-06-13T15:09:03.341Z","comments":true,"path":"2023/10/27/Kotlin笔记/","link":"","permalink":"http://princesaoke.github.io/2023/10/27/Kotlin%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Kotlin 与 Java 的关系Java运行过程：Java源代码 -&gt; 编译 -&gt; 生成class文件 -&gt; JVM解释执行 Java虚拟机并不关心class文件是如何生成的，因此也可以使用Kotlin生成class文件，JVM也可以解释执行。 Kotlin可以无缝使用Java第三方的开源库。 Q：Android为什么推荐Kotlin？Kotlin与Java比有哪些优势？ A： 空安全 Lambda表达式和高阶函数 Kotlin更简洁，引入了数据类、get、set方法等 拓展函数 支持协程 完全兼容Java val 与 var类比JavaScript中的const和let。 val用于声明常量，相当于加了final，赋值后无法修改；var用于声明变量。 Any、Unit Any等同于Java中的Object，是所有类的父类 Unit等同于void，当函数无返回值时会自动加上返回值Unit ifKotlin中的if是带有返回值的，返回值即花括号内的最后一行表达式的值： 12345val max = if(a &gt; b) &#123; a&#125; else &#123; b&#125; 字符串字符串模板$后花括号内可以是一个表达式： 12val str = &quot;你好&quot;println(&quot;$str，$&#123;str.replace(&quot;你好&quot;, &quot;再见&quot;)&#125;！&quot;) // 你好，再见！ 多行字符串三对双引号内的字符串可换行： 12345678val poem = &quot;&quot;&quot; 关关雎鸠， 在河之洲。 窈窕淑女， 君子好逑。&quot;&quot;&quot;.trimIndent()println(poem) 其中trimIndent函数的作用是去除输入行的公共最小缩进（空行不影响）。输出为 1234关关雎鸠， 在河之洲。窈窕淑女， 君子好逑。 有时为了让代码更清晰，我们可以使用|符号结合trimMargin函数来标记实际字符串的开始位置： 12345678val poem = &quot;&quot;&quot; | 蒹葭苍苍， |白露为霜。 | 所谓伊人， |在水一方。&quot;&quot;&quot;.trimMargin()println(poem) 其中trimMargin函数的作用是将多行字符串中的每行内容使用特定的前导字符（默认为|）进行标记，然后去除这些字符及其前面的空白。输出为 1234 蒹葭苍苍，白露为霜。 所谓伊人，在水一方。 也可指定不同的前导字符： 12345678val poem = &quot;&quot;&quot; &gt;郎骑竹马来， &gt; 绕床弄青梅。 &gt;同居长干里， &gt; 两小无嫌猜。&quot;&quot;&quot;.trimMargin(&quot;&gt;&quot;)println(poem) when相当于switch，不过用起来更方便。 1234567fun getScore(name: String) = when(name) &#123; &quot;张三&quot; -&gt; 85 &quot;李四&quot; -&gt; &#123; return 91 &#125; else -&gt; 0&#125; 区间闭区间1val range = 0..10 // [0, 10] 左闭右开区间1val range = 0 until 10 // [0, 10) 降序闭区间1val range = 10 downTo 0 // [10, 0] 循环for - in 循环12345678910// 输出 0~9for (i in 0 until 10) &#123; println(i)&#125;// 每次循环 i+=2for (i in 0..10 step 2) &#123; println(i)&#125;// 输出 0~10 内的偶数 构造函数Kotlin中有主次构造函数之分。 主构造函数没有函数体，直接定义在类名的后面。若想在主构造函数中编写一些逻辑，将代码写在init中： 1234567class Student(val name, val grade) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125;&#125;Student(&#x27;张三&#x27;, 86) 次构造函数有函数体，且必须调用主构造函数。 1234567891011class Student(val name, val grade) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125; constructor(name: String) : this(name, 0) &#123; // 次构造函数逻辑 &#125;&#125;Student(&#x27;张三&#x27;, 86) 继承Kotlin中非抽象类默认都是不可以被继承的，相当于给类加上了final。要声明为可继承类，需要加上open关键字。 同时子类中的构造函数必须调用父类中的构造函数。 1234567891011open class Person(val name) &#123; //TODO&#125;class Student(val name, val grade) : Person(name) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125;&#125;Student(&#x27;张三&#x27;, 86) 接口12345678910interface Rectangle &#123; fun getPerimeter() fun getArea()&#125;// Square类继承Shape类，同时实现Rectangle接口class Square(edge: Double) : Shape(), Rectangle &#123; override fun getPerimeter() = edge * 4 override fun getArea() = edge * edge&#125; 单例Java中实现单例： 12345678910111213141516171819public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; public void singletonTest() &#123; System.out.println(&quot;singletonTest方法被调用&quot;); &#125;&#125;Singleton singleton = Singleton.getInstance();singleton.singletonTest(); Kotlin中实现单例十分简便，只需要将关键字class改为object即可： 1234567object Singleton &#123; fun singletonTest() &#123; println(&quot;singletonTest is called.&quot;) &#125;&#125;Singleton.singletonTest() 拓展函数我们可以为某一个数据类型添加自定义的方法。 举个例子，如对时间进行格式化，一种普通做法是写一个工具类，用伴生对象实现类似静态方法的效果： 12345678910111213141516171819class DateTimeUtil &#123; companion object &#123; private const val DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot; // 格式化时间 fun format(dateTime: LocalDateTime): String &#123; val formatter = DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT) return formatter.format(dateTime) &#125; &#125;&#125;fun main() &#123; val dateTime = LocalDateTime.now() println(&quot;$dateTime&quot;) // 2024-03-24T23:07:39 val formattedDateTime = DateTimeUtil.format(dateTime) println(&quot;$formattedDateTime&quot;) // 2024-03-24 23:07:39&#125; 除此之外还有另一种更为优雅的方法： 1234567891011fun LocalDateTime.format(): String &#123; val formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;) return formatter.format(this)&#125;fun main() &#123; val dateTime = LocalDateTime.now() println(&quot;$dateTime&quot;) // 2024-03-24T23:07:39 println(dateTime.format()) // 2024-03-24 23:07:39&#125; 这里调用的format函数是我们自定义的。 kotlin与dart都有这种特性。 可见性 List、Set、Map1234567891011121314// Listval list = listOf(&quot;春秋左氏传&quot;, &quot;春秋公羊传&quot;, &quot;春秋谷梁传&quot;) // 不可变列表，不可添加元素val mutableList = mutableListOf(&quot;诗经&quot;, &quot;尚书&quot;, &quot;礼记&quot;, &quot;易经&quot;) // 可变列表mutableList.add(&quot;春秋&quot;)// Setval set = setOf(&quot;白起&quot;, &quot;王翦&quot;, &quot;廉颇&quot;, &quot;李牧&quot;)val mutableSet = mutableSetOf(&quot;齐桓公&quot;, &quot;晋文公&quot;, &quot;秦穆公&quot;, &quot;宋襄公&quot;)mutableSet.add(&quot;楚庄王&quot;)// Mapval map = mapOf(&quot;儒&quot; to &quot;孔子&quot;, &quot;法&quot; to &quot;韩非子&quot;, &quot;墨&quot; to &quot;墨子&quot;, &quot;道&quot; to &quot;庄子&quot;)val mutableMap = mutableMapOf(&quot;齐&quot; to &quot;临淄&quot;, &quot;楚&quot; to &quot;郢都&quot;, &quot;燕&quot; to &quot;蓟城&quot;, &quot;韩&quot; to &quot;新郑&quot;, &quot;赵&quot; to &quot;邯郸&quot;, &quot;魏&quot; to &quot;大梁&quot;)mutableList.add(&quot;秦&quot; to &quot;咸阳&quot;) Lambda表达式即可当做参数传递的一段代码。 完整结构：val lambda = &#123; param1: Type, param2: Type -&gt; 函数体 &#125;，最后一行表达式的值作为整个Lambda表达式的返回值。 12345678910button.setOnClickListener(&#123; data -&gt; println(data) &#125;)// 若Lambda表达式是函数的最后一个参数，可以把Lambda表达式提到括号外：button.setOnClickListener() &#123; data -&gt; println(data) &#125;// 若Lambda表达式是唯一的参数可以省略括号：button.setOnClickListener &#123; data -&gt; println(data) &#125;// 若Lambda表达式内只有一个参数，可以用`it`代指：button.setOnClickListener &#123; println(it) &#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://princesaoke.github.io/tags/Kotlin/"}]},{"title":"浏览器事件循环","slug":"浏览器事件循环","date":"2023-10-22T05:47:29.000Z","updated":"2024-03-12T16:46:01.691Z","comments":true,"path":"2023/10/22/浏览器事件循环/","link":"","permalink":"http://princesaoke.github.io/2023/10/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"事件循环又称消息循环。 均以Chrome浏览器为例。 浏览器的进程模型浏览器运行时有很多个进程，我们重点关注三大进程： 浏览器进程 网络进程 渲染进程（不止一个，每一个标签页就是一个渲染进程） 其中浏览器进程是打开浏览器后最先启动的，负责： 浏览器通用界面显示，如浏览器工具栏、浏览器设置等 用户交互，如监听点击、滚动等 子进程管理，浏览器其他进程均由浏览器进程开启 …… 网络进程负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。 渲染进程可以有多个，每一个标签页就是一个渲染进程，该进程包括一个渲染主线程和其他多个子线程。 渲染主线程是如何工作的渲染主线程的任务包括但不限于： 解析HTML 解析CSS 计算样式，如把rem转换为px等 计算布局，如计算元素宽高 处理图层，如根据z-index判断叠层关系 每帧绘制页面 执行JavaSctipt 执行事件处理函数 执行计时器的回调函数 …… 主线程每次执行一个任务，执行完后从消息队列中取出下一个任务。所有线程可以随时向消息队列中添加任务。这整个过程称为事件循环。 若是需要等待的任务，如setTimeout()函数会在等待规定时间后才执行，则不能直接加入消息队列，否则会导致主线程要等待，而后面的任务也无法执行。 主线程执行到js中的setTimeout()，会把要计时等待的任务交给计时线程，由计时线程到时间后将回调函数加入消息队列。 Q：如何理解JS的异步？ A： JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程承担着诸多的工作，渲染页面、执行JS都在其中运行。如果使用同步的方式，就极有可能导致主线程阻塞，从而导致消息队列中的很多其他任务无法得到执行。这一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，最大限度保证了单线程的流畅运行。 任务的优先级实际上消息队列不止一个队列，而是有多个队列：微队列、延时队列、交互队列等。 在W3C标准中，规定微队列是优先级最高的，意味着只有当微队列中所有任务都执行完了才会轮到其他队列。 在Chrome浏览器中，延时队列用于存放计时器到达后的回调函数，优先级为【中】；交互队列用于存放用户操作后产生的事件处理任务，优先级为【高】。 Q：阐释一下JS的事件循环？ A： 事件循环又叫消息循环，是浏览器渲染主线程的工作方式。在Chrome中，它开启一个不会结束的循环，每次循环从消息队列中取出第一个任务执行，而其他线程只要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种方式已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。根据W3C官方的规定，每个任务有不同的类型，同类型的任务必须在同一个队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务优先级最高，必须优先调度。 Q：JS中的计时器能做到精确计时吗？为什么？ A： 不行。受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，回调函数需要时间排队等待调度，因此带来了时间偏差。操作系统的计时函数本身就有少量偏差，而JS的计时器最终调用的是操作系统的计时函数，因此也具有一定偏差。 例题12345678910111213141516171819// Promise.resolve().then(fn) 会将函数fn加入微队列function fn1() &#123; console.log(1) Promise.resolve().then(function fn2() &#123; console.log(2) &#125;)&#125;setTimeout(function fn3() &#123; console.log(3) Promise.resolve().then(fn1)&#125;, 0)Promise.resolve().then(function fn4() &#123; console.log(4)&#125;)console.log(5) Q：浏览器执行以上js代码后输出是什么？ 解析： setTimeout将函数fn3添加到计时线程，0秒后时间到，计时线程将fn3添加到延时队列中排队等待调度； 全局js还未执行完，主线程继续执行，将fn4添加到微队列； 输出5； 全局js执行完毕，从消息队列中取出下一个任务。由于微队列优先级最高，因此取出fn4执行，输出4； fn4执行完毕，取出fn3执行，输出3，然后将fn1加入微队列； fn3执行完毕，取出fn1执行，输出1，然后将fn2加入微队列； fn1执行完毕，取出fn2执行，输出2； A： 1234554312","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Flutter中的一些问题","slug":"Flutter中的一些问题","date":"2023-10-17T09:57:05.000Z","updated":"2024-04-04T10:45:04.424Z","comments":true,"path":"2023/10/17/Flutter中的一些问题/","link":"","permalink":"http://princesaoke.github.io/2023/10/17/Flutter%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"命令行创建 Flutter使用命令行创建项目： 1flutter create --platforms=android,ios D:\\flutter_projects\\project_name 参数 说明 –project-name 项目名，全部小写+下划线 –platforms 支持的平台，可选值为：android、ios、windows、linux、macos、web，此参数仅在“–template”设置为应用程序或插件时有效 –description 项目描述，此字符串最终位于pubspec.yaml文件中，默认为：A new Flutter project. –org 项目的组织，使用反向域名表示法。此字符串用于Java包名称，并作为iOS捆绑包标识符中的前缀，默认为：com.example 有关该命令的更多信息，参见flutter --help create。 Android 未开启网络权限APP开发时正常，build后报错如下： 1[ERROR:flutter/lib/ui/http://ui_dart_state.cc(148)] Unhandled Exception: SocketException: Failed host lookup: &#x27;api.douban.com&#x27; (OS Error: No address associated with hostname, errno = 7) 解决方法： 在android\\app\\src\\main\\AndroidManifest.xml中添加网络权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 如： type ‘(XXX?) &#x3D;&gt; void’ is not a subtype of type ‘((dynamic) &#x3D;&gt; void)?’试图用StatefulWidget封装DropDownButton时发现问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class DebugDropdownButton&lt;T&gt; extends StatefulWidget &#123; const DebugDropdownButton(&#123; super.key, required this.dataMap, this.onChanged, this.initItemKey, &#125;); final Map&lt;String, T&gt; dataMap; final String? initItemKey; final ValueChanged&lt;T?&gt;? onChanged; @override State&lt;DebugDropdownButton&gt; createState() =&gt; _DebugDropdownButtonState();&#125;class _DebugDropdownButtonState&lt;T&gt; extends State&lt;DebugDropdownButton&gt; &#123; ValueNotifier&lt;T?&gt; valueNotifier = ValueNotifier(null); List&lt;DropdownMenuItem&lt;T&gt;&gt; createDropdownItemList() &#123; final List&lt;DropdownMenuItem&lt;T&gt;&gt; list = []; for (var entry in widget.dataMap.entries) &#123; list.add(DropdownMenuItem(value: entry.value, child: Text(entry.key))); &#125; return list; &#125; @override void initState() &#123; super.initState(); if (widget.initItemKey != null) &#123; valueNotifier.value = widget.dataMap[widget.initItemKey!]; &#125; &#125; @override Widget build(BuildContext context) &#123; return ValueListenableBuilder( valueListenable: valueNotifier, builder: (context, value, child) =&gt; SizedBox( width: 300, child: DropdownButtonHideUnderline( child: DropdownButton&lt;T&gt;( value: value, isExpanded: true, items: createDropdownItemList(), onChanged: (T? v) &#123; valueNotifier.value = v; widget.onChanged?.call(v); &#125;, ), ), ), ); &#125;&#125; 使用方法： 12345678910return DebugDropdownButton&lt;String&gt;( initItemKey: &#x27;正式环境&#x27;, dataMap: const &#123; &#x27;正式环境&#x27;: &#x27;正式环境Url&#x27;, &#x27;测试环境&#x27;: &#x27;测试环境Url&#x27;, &#125;, onChanged: (String? value) &#123; // TODO: 修改baseUrl &#125;,); 发现触发onChanged方法时出现异常： type ‘(String?) &#x3D;&gt; void’ is not a subtype of type ‘((dynamic) &#x3D;&gt; void)?’ 解决方法： 有人在Github上提了issue：issue 原先的代码： 12345678910class DebugDropdownButton&lt;T&gt; extends StatefulWidget &#123; // ... @override State&lt;DebugDropdownButton&gt; createState() =&gt; _DebugDropdownButtonState();&#125;class _DebugDropdownButtonState&lt;T&gt; extends State&lt;DebugDropdownButton&gt; &#123; // ...&#125; 修改为： 12345678910class DebugDropdownButton&lt;T&gt; extends StatefulWidget &#123; // ... @override State&lt;DebugDropdownButton&lt;T&gt;&gt; createState() =&gt; _DebugDropdownButtonState();&#125;class _DebugDropdownButtonState&lt;T&gt; extends State&lt;DebugDropdownButton&lt;T&gt;&gt; &#123; // ...&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"远程连接服务器的一些方法","slug":"远程连接服务器的一些方法","date":"2023-10-14T16:07:40.000Z","updated":"2023-10-31T06:38:37.537Z","comments":true,"path":"2023/10/15/远程连接服务器的一些方法/","link":"","permalink":"http://princesaoke.github.io/2023/10/15/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"Windows Server 远程桌面连接如果你的服务器装的操作系统是 Windows Server ，那么可以在自己的 Windows 电脑上直接远程控制图形化界面。 Win+R输入mstsc运行，进入远程桌面连接，在计算机一栏中填写要连接的服务器IP地址或域名，用户名即服务器登录的用户名，输入密码连接，可以将记录保存在本地这样下次就不用再输密码了。 终端SSH远程连接服务器要求本地主机装有SSH客户端，服务器装有SSH服务器。可在 PowerShell 输入以下命令查看是否安装： 1Get-WindowsCapability -Online | Where-Object Name -like &#x27;OpenSSH*&#x27; 若均未安装则输出 12345Name : OpenSSH.Client~~~~0.0.1.0State : NotPresentName : OpenSSH.Server~~~~0.0.1.0State : NotPresent SSH客户端不用特地安装，安装git时自带。 Windows Server 2022 没有SSH服务器，需要自行安装。 用 PowerShell 安装管理员权限运行 PowerShell ，执行： 12345# 安装 OpenSSH 客户端Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# 安装 OpenSSH 服务器Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 安装完成后继续运行： 12345678910111213# 启动 SSH 服务器Start-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;# 确认防火墙规则已配置。它应该由安装程序自动创建。运行以下程序进行验证if (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) &#123; Write-Output &quot;防火墙规则 &#x27;OpenSSH-Server-In-TCP&#x27; 不存在，正在创建...&quot; New-NetFirewallRule -Name &#x27;OpenSSH-Server-In-TCP&#x27; -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22&#125; else &#123; Write-Output &quot;防火墙规则 &#x27;OpenSSH-Server-In-TCP&#x27; 已存在。&quot;&#125; 记得开放端口，默认为22端口。 一切都完成后，在本地计算机终端中运行： 1234ssh 服务器登录用户名@IP地址 -p 连接端口# 举例如下，端口可省略ssh Administrator@123.123.123.123 -p 22 然后输入密码即可连接成功。 Windows 设置中安装 OpenSSH VSCode 中使用 Remote - SSH 远程连接服务器首先确保上一方法是可行的。 VSCode 安装拓展Remote - SSH，左侧菜单会多出一个远程资源管理器图标。如图操作进入.ssh\\config。 .ssh\\config中这样填写： 1234Host my_server HostName 123.123.123.123 User Administrator Port 22 其中my_server是给服务器起的名称，随便填，HostName是服务器IP地址，User是服务器登录用户名，Port是连接端口，可省略，默认为22。 保存后左侧出现对应的服务器，选择在新窗口连接，输入密码，选择服务器操作系统，即可像在本地工作区一样对远程工作区进行操作。","categories":[{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://princesaoke.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Flutter取消ListView过度滑动效果","slug":"Flutter取消ListView过度滑动效果","date":"2023-10-11T07:09:38.000Z","updated":"2023-10-11T13:49:28.185Z","comments":true,"path":"2023/10/11/Flutter取消ListView过度滑动效果/","link":"","permalink":"http://princesaoke.github.io/2023/10/11/Flutter%E5%8F%96%E6%B6%88ListView%E8%BF%87%E5%BA%A6%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/","excerpt":"","text":"不止ListView，GridView、PageView等组件同样适用。 Flutter 3.10.1 方法在ListView外包裹一个ScrollConfiguration，设置behavior参数，child就是ListView： 1234ScrollConfiguration( behavior: ScrollConfiguration.of(context).copyWith(overscroll: false), child: ListView(),) Flutter 3.3.3 方法在早些时候的3.3.3版本我是用下面这个方法的，发现换到3.10.1后失效了。依然会有过度滑动的波纹效果，但变成了白色。 自定义一个类，继承ScrollBehavior，如下： 1234567891011121314151617181920212223242526import &#x27;package:flutter/material.dart&#x27;;// 取消ListView过度滑动的水波纹效果class OverScrollBehavior extends ScrollBehavior &#123; @override Widget buildViewportChrome( BuildContext context, Widget child, AxisDirection axisDirection) &#123; switch (getPlatform(context)) &#123; case TargetPlatform.iOS: return child; case TargetPlatform.android: case TargetPlatform.fuchsia: default: return GlowingOverscrollIndicator( // 不显示头部水波纹 showLeading: false, // 不显示尾部水波纹 showTrailing: false, axisDirection: axisDirection, color: Theme.of(context).colorScheme.secondary, child: child, ); &#125; &#125;&#125; 使用时在ListView外包裹一个ScrollConfiguration，behavior参数里实例化一个OverScrollBehavior即可： 1234ScrollConfiguration( behavior: OverScrollBehavior(), child: ListView(),)","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Android中的ShapeableImageView","slug":"Android中的ShapeableImageView","date":"2023-10-02T08:37:53.000Z","updated":"2023-10-02T11:56:26.099Z","comments":true,"path":"2023/10/02/Android中的ShapeableImageView/","link":"","permalink":"http://princesaoke.github.io/2023/10/02/Android%E4%B8%AD%E7%9A%84ShapeableImageView/","excerpt":"","text":"效果如下： 声明依赖项在 app&#x2F;build.gradle.kts 中的 dependencies 添加： 123dependencies &#123; implementation(&quot;com.google.android.material:material:1.8.0&quot;)&#125; 除了 ShapeableImageView ， Android Material 中还有很多其他有用的东西，以后接触到再慢慢记录。 添加 style在 res&#x2F;values&#x2F;styles.xml 中添加： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;!-- 圆形图片 --&gt; &lt;style name=&quot;circle_image&quot;&gt; &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;50%&lt;/item&gt; &lt;/style&gt; &lt;!-- 圆角图片 --&gt; &lt;style name=&quot;round_image&quot;&gt; &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;10dp&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 使用 ShapeableImageView1234567&lt;com.google.android.material.imageview.ShapeableImageView android:id=&quot;@+id/circle_image&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:contentDescription=&quot;@null&quot; android:scaleType=&quot;centerCrop&quot; app:shapeAppearance=&quot;@style/circle_image&quot; /&gt; 若要描边效果，则加上以下属性： 属性 作用 strokeColor 描边颜色 strokeWidth 描边宽度 padding 为strokeWidth的一半 效果： 参考这篇文章","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的RecyclerView","slug":"Android中的RecyclerView","date":"2023-09-30T07:36:50.000Z","updated":"2024-10-17T10:10:09.106Z","comments":true,"path":"2023/09/30/Android中的RecyclerView/","link":"","permalink":"http://princesaoke.github.io/2023/09/30/Android%E4%B8%AD%E7%9A%84RecyclerView/","excerpt":"","text":"RecyclerView 相当于加强版的 ListView ，比 ListView 更灵活、更高效。 声明依赖项在 app&#x2F;build.gradle.kts 中的 dependencies 添加： 123dependencies &#123; implementation(&quot;androidx.recyclerview:recyclerview:1.2.1&quot;)&#125; 可将 1.2.1 修改为你想要的版本（一般是最新的稳定版），详情见官方文档 点击 Android Studio 右上角的 Sync Project with Gradle Files 同步依赖。 使用方法MainActivity.kt: 12345678// 要显示的数据val data = arrayOf(&quot;秦广王&quot;, &quot;楚江王&quot;, &quot;宋帝王&quot;, &quot;仵官王&quot;, &quot;阎罗王&quot;, &quot;卞城王&quot;, &quot;泰山王&quot;, &quot;都市王&quot;, &quot;平等王&quot;, &quot;转轮王&quot;)val recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recycler_view) // 用 id 找到 RecyclerViewrecyclerView.layoutManager = LinearLayoutManager(this) // 配置子视图的布局，可切换其他布局，如下一行// recyclerView.layoutManager = GridLayoutManager(this, 3) // 3表示一行有几个子视图val recyclerAdapter = MyAdapter(this, description.toMutableList());recyclerView.adapter = recyclerAdapter RecyclerViewAdapter.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// 自定义的 Adapter 类，继承 RecyclerView.Adapter/// 其中的 RecyclerView.Adapter 是个泛型，需要传入 ViewHolder/// 在 MyAdapter 类中实现一个自定义的 ViewHolderpublic class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; private final Context context; public List&lt;String&gt; data; public MyAdapter(Context context, List&lt;String&gt; data) &#123; this.context = context; this.data = data; &#125; /// 拿到 RecyclerView 子视图的布局 /// 其中 R.layout.list_item 是配置子视图布局的 xml 文件 @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = View.inflate(context, R.layout.list_item, null); return new MyViewHolder(view); &#125; /// 将要显示的数据赋值给子视图 @Override public void onBindViewHolder(@NonNull MyViewHolder myViewHolder, int i) &#123; myViewHolder.textView.setText(data.get(i)); &#125; /// 返回 RecyclerView 子视图的数量 @Override public int getItemCount() &#123; return data == null ? 0 : data.size(); &#125; /// 自定义的 ViewHolder ，继承 RecyclerView.ViewHolder public static class MyViewHolder extends RecyclerView.ViewHolder &#123; private final TextView textView; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.list_item); &#125; &#125;&#125; res&#x2F;layout&#x2F;list_item.xml: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingStart=&quot;20dp&quot; android:paddingEnd=&quot;20dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/list_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; android:textStyle=&quot;bold&quot; /&gt;&lt;/LinearLayout&gt; activity_main.xml: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; 在&lt;RecyclerView&gt;中加上app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;可以设置其子视图的布局，与 MainActivity.kt 中的 1recyclerView.layoutManager = LinearLayoutManager(this) 起相同作用。 删除数据并更新 获取要删除的item的位置position 从数据源中删除该item 调用RecyclerView的Adapter的notifyItemRemoved(position)方法通知RecyclerView删除该item 如果需要更新删除item后的位置，可以调用Adapter的notifyItemRangeChanged(position, itemCount)方法更新 如果需要撤销删除操作，可以调用Adapter的notifyItemInserted(position)方法插入该item RecyclerView 与 ListView 的区别 布局不同：ListView只支持垂直方向，而RecyclerView的LayoutManager有横向、竖向、瀑布流、网格等复杂的布局 数据更新：ListView只能刷新全部数据，而RecyclerView支持局部数据刷新 缓存不同：RecyclerView有四级缓存，而ListView只有两级缓存 RecyclerView的四级缓存机制 mChangeScrap与mAttachedScrap用来缓存还在屏幕内的ViewHolder mCachedViews用来缓存移除屏幕之外的ViewHolder，默认上限为2个，即缓存屏幕外2个ViewHolder mViewCacheExtension自定义的扩展缓存，需要程序员自己实现 RecycledViewPool ViewHolder缓存池，默认上限为5","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的ListView","slug":"Android中的ListView","date":"2023-09-24T15:31:27.000Z","updated":"2023-10-02T08:46:56.348Z","comments":true,"path":"2023/09/24/Android中的ListView/","link":"","permalink":"http://princesaoke.github.io/2023/09/24/Android%E4%B8%AD%E7%9A%84ListView/","excerpt":"","text":"ListView kotlin属性 数据类型 说明 adapter Adapter类 适配器，ListView将以该配置为模板显示内容 用法： 123456val data = arrayOf(&quot;角木蛟&quot;, &quot;亢金龙&quot;, &quot;尾火虎&quot;, &quot;箕水豹&quot;)// 构造函数的参数，第一个是上下文对象Context，第二个是适配器Adapter，第三个是要传进ListView展示的数据val adapter = ArrayAdapter(this, android.R.layout.simple_expandable_list_item_1, data)val listView = findViewById&lt;ListView&gt;(R.id.listview)listView.adapter = adapter 这里的android.R.layout.simple_expandable_list_item_1还可以改用其他Adapter适配器。 ArrayAdapter simple_list_item_1 simple_list_item_2 simple_list_item_single_choice simple_list_item_multiple_choice simple_list_item_checked SimpleAdapterSimpleAdapter 允许你写一个布局，然后ListView中的所有行都使用这个布局。基本能实现任意效果。 res&#x2F;layout&#x2F;list_item.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingStart=&quot;20dp&quot; android:paddingEnd=&quot;20dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/list_item_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;TextView android:id=&quot;@+id/list_item_description&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; java&#x2F;MainActivity.kt 123456789101112131415161718// 要显示的数据val title = arrayOf(&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;)val description = arrayOf(&quot;周一周一，奄奄一息&quot;, &quot;周二周二，肚子好饿&quot;, &quot;周三周三，带病上班&quot;, &quot;周四周四，重见天日&quot;, &quot;周五周五，敲锣打鼓&quot;, &quot;周六周六，大鱼大肉&quot;, &quot;周日周日，死期将至&quot;)// Adapter要的数据是一个List，List里每个Map对应一行，Map里一个键值对即一个要显示的数据val datas = mutableListOf&lt;Map&lt;String, String&gt;&gt;()for (i in title.indices) &#123; val map = hashMapOf(&quot;title&quot; to title[i], &quot;description&quot; to description[i]) datas.add(map)&#125;val adapter = SimpleAdapter( this, // 上下文 Context datas, // 数据 R.layout.list_item, // 布局文件，每一行按该布局文件布局 arrayOf&lt;String&gt;(&quot;title&quot;, &quot;description&quot;), // 有哪些数据 intArrayOf(R.id.list_item_title, R.id.list_item_description) // 对应上一行，将数据放到布局文件中的哪里) 效果如下：","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"转发QQ语音","slug":"转发QQ语音","date":"2023-09-22T13:27:26.000Z","updated":"2024-05-29T12:48:53.083Z","comments":true,"path":"2023/09/22/转发QQ语音/","link":"","permalink":"http://princesaoke.github.io/2023/09/22/%E8%BD%AC%E5%8F%91QQ%E8%AF%AD%E9%9F%B3/","excerpt":"","text":"注：本文章介绍的方法在 2024-02-09 仍然有效，不排除未来失效的可能 一、找到要转发的语音在本地的 .amr 文件从电脑端进入用户个人文件夹： 对于电脑端新版的QQ9，打开设置-&gt;存储管理，进入“聊天信息默认保存到”的路径，进入以你的QQ号命名的个人文件夹。 对于旧版的腾讯QQ，打开设置-&gt;文件管理-&gt;打开个人文件夹。 个人文件夹中，Audio里就是所有聊天记录的语音，可以按时间排序找到要转发的.amr目标语音文件；也可以将要转发的语音收藏，在MyCollection&#x2F;Audio中找。找到后copy一份保存。 但是.amr格式是不能直接播放的，并且普通的格式转换工具也不起作用，QQ从某个时间点开始对语音进行了加密。 二、.amr 转 .mp3需要用到特制的工具：silk2mp3 注：该工具似乎只能windows环境下运行 下载解压完后运行 silk2mp3.exe ，点击“导入待转换文件”，选择要转换的.amr语音，输出目录可以自己改，然后点开始转换，即可将 .amr 文件转换为 .mp3 文件。 在此感谢该工具的作者 kn007 三、将 .mp3 文件以语音形式发送这一步最好用数据线把手机连上电脑，选择文件传输模式，在电脑上对文件进行操作。 打开手机QQ进入聊天界面，点击录音，录音的时长就是语音发出去要显示的时长，然后结束录音，但注意不要点发送。 这时候电脑打开“此电脑”，进入手机的存储空间（连数据线的时候要选文件传输才能看到手机），进入Android/data/com.tencent.mobileqq/Tencent/MobileQQ/以你的QQ号命名的文件夹/ptt/以年月命名的文件夹(如202309)/以日期命名的文件夹(如22)，在其中根据时间找到你刚才的录音文件（.slk），复制其文件名及后缀，然后把你要转发的.mp3文件复制到这个目录，文件名改成刚复制的文件名（.mp3后缀也改成.slk），原来那个.slk文件就可以删掉了。 然后回到手机QQ点发送，发送出去的语音就是mp3文件的声音。 这里要注意，发送出去的语音上显示的语音时长和真正播放出来的语音时长是不一样的，显示的时长只取决于你录音录了多久，而播放的时长只取决于你的mp3文件的时长。 所以记得保证录音的时间和mp3文件的时长一样，否则可能会出现你点开两秒钟的语音却播放了一分钟的情况。","categories":[{"name":"其他","slug":"其他","permalink":"http://princesaoke.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Android笔记","slug":"Android笔记","date":"2023-09-20T05:41:09.000Z","updated":"2024-04-09T08:53:33.215Z","comments":true,"path":"2023/09/20/Android笔记/","link":"","permalink":"http://princesaoke.github.io/2023/09/20/Android%E7%AC%94%E8%AE%B0/","excerpt":"","text":"项目结构 java文件夹下：业务逻辑 AndroidManifest.xml：项目配置文件 res&#x2F;layout文件夹下：页面布局 res&#x2F;values文件夹下：全局常量 res&#x2F;drawable文件夹下：图片资源 res&#x2F;mipmap系列：不同分辨率的图片资源，根据屏幕大小使用不同规格的图片，一般放APP图标 单位 单位 说明 dp device independent pixels（设备独立像素），不同设备有不同的显示效果，推荐使用这个 sp scaled pixels（放大像素），字体大小一般用这个 px pixels（像素） pt point，1pt &#x3D; 1&#x2F;72 英寸 View 和 ViewGroup 页面上的一个UI组件就是一个View，如&lt;TextView&gt;、&lt;Button&gt;等 ViewGroup是一组View的布局方式，如&lt;LinearLayout&gt;、&lt;RelativeLayout&gt;等 四大组件 Activity ： Service ： BroadcastReceiver ：允许你的应用接收来自各处的广播消息，比如电话、短信等，当然，你的应用也可以向外发出广播消息 ContentProvider ：为应用程序之间共享数据提供了可能，比如你想要读取系统通讯录中的联系人，就需要通过ContentProvider来实现 六大基本布局 线性布局 LinearLayout ：View按水平或竖直排列 相对布局 RelativeLayout ：使用margin和padding相对父容器布局 表格布局 TableLayout ：&lt;TableLayout&gt;内使用&lt;TableRow&gt;定义一行，&lt;TableRow&gt;中几个元素就是几列 帧布局 FrameLayout ：即叠层布局。帧布局的大小由控件中最大的子控件决定 绝对布局 AbsoluteLayout ：已弃用，建议改用 ConstraintLayout 网格布局 GridLayout ：将视图按格子排列 线性布局 LinearLayout xml参数 取值 说明 layout_width “match_parent”、”wrap_content” 线性布局的宽度 layout_height “match_parent”、”wrap_content” 线性布局的高度 orientation “vertical”、”horizontal” 内部视图排序方向 divider 一个视图View 内部每两个相邻视图之间都有一个View LinearLayout 内视图参数 xml参数 取值 说明 layout_width “match_parent”、”wrap_content” 线性布局的宽度 layout_height “match_parent”、”wrap_content” 线性布局的高度 layout_weight 1、2、3、…… 该视图占整个线性布局大小的权重，使用该参数时注意 layout_width 与 layout_height 要有一个为 “wrap_content” 约束布局 ConstraintLayout xml参数 取值 说明 layout_width “match_parent”、”wrap_content” 约束布局的宽度 layout_height “match_parent”、”wrap_content” 约束布局的高度 ConstraintLayout 内视图参数 xml参数 取值 说明 layout_constraintTop_toTopOf parent、id 子视图的顶部与其他视图的顶部对齐 layout_constraintLeft_toRightOf parent、id 子视图的左部与其他视图的右部对齐 layout_constraintHorizontal_bias [0, 1] 该值越大子视图越往右，0.5时居中，bias = 子视图左部到父视图左部的距离 / 子视图左部到父视图左部的距离 + 子视图右部到父视图右部的距离 网格布局 GridLayout xml参数 取值 说明 rowCount 1、2、3、…… 共有几行 columnCount 1、2、3、…… 共有几列 orientation “horizontal”、”vertical” 内部视图排序方向 GridLayout 内视图参数 xml参数 取值 说明 layout_rowSpan 1、2、3、…… 该视图横跨几列 layout_columnSpan 1、2、3、…… 该视图竖跨几行 layout_gravity “fill”、…… 有使用以上两参数，则该参数为”fill” 表格布局 TableLayout xml参数 取值 说明 stretchColumns 0、1、2、…… 被拉伸的列序号 hint 任意字符串 输入框为空时的提示词，无该参数会报错 LogAndroid中的日志工具类是Log（android.util.Log），这个类中提供了如下5个方法来供我们打印日志（级别从低到高）。 Log.v()。级别verbose，用于打印那些最为琐碎的、意义最小的日志信息 Log.d()。级别debug，用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的 Log.i()。级别info，用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为的数据 Log.w()。级别warn，用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方 Log.e()。级别error，用于打印程序中的错误信息，一般代表你的程序出现严重问题了，必须尽快修复 TextView xml参数 取值 说明 textStyle bold、italic等 字体样式，如加粗、斜体等 shadowRadius 浮点数 阴影模糊程度 singleLine true、false 文本单行显示 ellipsize end等 文本超出范围的省略方式 EditText xml参数 取值 说明 inputType text、number等 指明输入内容的类型以弹出对应键盘 hint 任意字符串 输入框为空时的提示词，无该参数会报错 drawableXXX Vector 在输入框的指定方位添加icon或图片 hint 任意字符串 输入框为空时的提示词，无该参数会报错 kotlin方法 返回值 说明 getText 返回输入框中的内容 Button xml参数 取值 说明 onClick 字符串，为点击后要执行的方法名 点击按钮后会调用对应的方法，与 setOnClickListener 相同 background selector 按钮背景图片 backgroundTint selector 按钮背景图片颜色 textAllCaps 布尔值 当为true时按钮的文字会全部变成大写 ListView详见我的另一篇文章：Android中的ListView RecyclerView详见我的另一篇文章：Android中的ListView ShapeableImageView详见我的另一篇文章：Android中的ShapeableImageView 使用阿里巴巴图标库首先在阿里巴巴图标库下载svg图标，保存位置任意： drawable文件夹右键创建 Vector Asset： 如图选择 Local file，选择svg文件的路径： 报错：No speakable text present程序期望有一些可以被说出来的文本，用于无障碍朗读模式之类的，但是在提供的数据中并没有找到可以被转化为语音的文本。 解决方法：tools:ignore=&quot;SpeakableTextPresentCheck&quot; CLEARTEXT communication to xx.xx.xx.xx not permitted by network security policy参考文章 出于安全性考虑，Android 9.0 后默认只支持HTTPS而不允许使用HTTP，要使用HTTP需要在AndroidManifest.xml中&lt;application&gt;内添加android:usesCleartextTraffic=&quot;true&quot;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Git提交规范","slug":"Git提交规范","date":"2023-09-18T06:27:36.000Z","updated":"2024-05-29T12:48:35.170Z","comments":true,"path":"2023/09/18/Git提交规范/","link":"","permalink":"http://princesaoke.github.io/2023/09/18/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","excerpt":"","text":"VSCode 插件：git-commit-plugingit-emoji大全 该插件可帮助你规范commit描述格式，便于生成易于阅读且美观的提交。 修改上次commit的描述有时候我们提交的描述格式或内容填错了，想要覆盖掉之前的描述，只能重新commit一次，但这样就会多一个提交记录。 其实有一个不需要重新提交就可以修改上次commit描述的方法，详见这篇文章 结合Jira在commit信息前加上Jira的任务编号，Jira会自动跟踪，在任务描述中附上提交链接","categories":[{"name":"其他","slug":"其他","permalink":"http://princesaoke.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://princesaoke.github.io/tags/Git/"}]},{"title":"AndroidStudio的一些问题","slug":"AndroidStudio的一些问题","date":"2023-09-17T07:11:53.000Z","updated":"2024-04-04T09:46:14.675Z","comments":true,"path":"2023/09/17/AndroidStudio的一些问题/","link":"","permalink":"http://princesaoke.github.io/2023/09/17/AndroidStudio%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"Gradle 版本与 Java 版本不匹配Gradle 7.4 最高只支持到 Java17，Java20 要 Gradle8.3 。 之前装了一下Java20，然后出问题了，安卓项目打不开，编译报错，最后改用Java17。 Android Studio 内部 jre 路径缓存换了Java版本，路径也变了。即便我配置好了环境变量，Android Studio 还是默认到之前的路径去找jre，看网上说应该是 Android Studio 内部的缓存路径没变。我干脆直接重装，换了2022的版本，用了新UI，颜值稍微高了那么一点点，不过还是难用。 安卓虚拟机（AVD）的问题创建一台设备，一点启动，直接弹窗说设备已终止什么的，反正就是启动不了。检查一下C盘，如果你和我一样C盘爆红，那应该是空间不足。 按照这篇文章的步骤去做，把.android文件夹移到别的磁盘，然后添加环境变量，完美解决。 启动是可以启动了，但还有别的问题：虚拟机屏幕一闪一闪的，而且动不动就卡死然后直接蓝屏。 终止代码 CLOCK_WATCHDOG_TIMEOUT，暂时还不知道什么原因。 😅 Syntax highlighting has been temporarily turned off in file XXX because of an internal error可能是在更新插件、删除插件的时候直接退出，没有等待索引重新加载，会导致后台内部build一直没有完成。 解决方法：File -&gt; Invalidate Caches","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"FVM切换Flutter版本","slug":"FVM切换Flutter版本","date":"2023-09-14T05:40:25.000Z","updated":"2024-04-04T10:23:15.416Z","comments":true,"path":"2023/09/14/FVM切换Flutter版本/","link":"","permalink":"http://princesaoke.github.io/2023/09/14/FVM%E5%88%87%E6%8D%A2Flutter%E7%89%88%E6%9C%AC/","excerpt":"","text":"使用FVM（推荐）全称 Flutter Version Manager，FVM官方文档 安装FVMcmd中运行指令： 1dart pub global activate fvm 下载完会警告你要将其路径C:\\Users\\用户名\\AppData\\Local\\Pub\\Cache\\bin添加到环境变量。 安装指定版本的Flutter在下载Flutter SDK前，最好先修改SDK的默认存放路径： 1234fvm config --cache-path &lt;CACHE_PATH&gt;# 如我的配置fvm config --cache-path D:\\fvm\\versions 查看配置： 1fvm config 安装FlutterSDK： 1234fvm install &#123;version&#125;# 如：fvm install 3.10.5 查询所有Flutter版本并切换Flutter版本 12345fvm list # 查看所有Flutter版本fvm global &#123;version&#125; # 设置全局Flutter版本fvm doctor # 检查 处理原先的SDK和配置此时fvm目录下文件结构应该是： 其中versions里的是不同版本的Flutter SDK；default是一个链接，指向versions中当前使用的版本；.settings文件中是fvm的设置 所以Flutter SDK的路径就应该是D:\\fvm\\default\\bin，Dart SDK的路径是D:\\fvm\\default\\bin\\cache\\dart-sdk\\bin。将原本环境变量中的sdk路径改为上面的路径。 然后将下载fvm之前使用的Flutter SDK直接挪到versions文件夹里，这样fvm list就能看到所有sdk了。 fvm还支持不同项目的自定义配置，更多指令详见FVM官方文档 直接拉取新版本仓库参考文章：http://www.taodudu.cc/news/show-3618721.html 切换 Flutter SDK 分支进入安装 flutter sdk 的文件夹，终端输入 1git checkout 3.10.1 # 3.10.1 换成要切换到的版本号 将sdk切换到其他版本。 Flutter Doctor 更新 Dart SDK 及工具包终端输入 1flutter doctor 进行flutter检查，会自动帮你装上与flutter版本对应的 dart sdk 及相关的工具包。 最后终端输入 1flutter --version 检查版本是否切换成功。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Java笔记","slug":"Java笔记","date":"2023-09-14T05:34:31.000Z","updated":"2024-10-30T08:19:18.382Z","comments":true,"path":"2023/09/14/Java笔记/","link":"","permalink":"http://princesaoke.github.io/2023/09/14/Java%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Java版本 Java SE 版本 JDK版本 发布时间 开发代号 Oak 1995-05-23 Oak（橡树） Java 1.0 JDK 1.0 1996-01-23 Java 1.1 JDK 1.1 1997-02-18 J2SE 1.2 JDK 1.2 1998-12-04 Playerground（运动场） J2SE 1.3 JDK 1.3 2000-05-08 Kestrel（美洲红隼） J2SE 1.4 JDK 1.4 2002-02-13 Merlin（灰背隼） Java SE 5.0 JDK 1.5 2004-09-29 Tiger（老虎） Java SE 6 JDK 1.6 2006-12-11 Mustang（野马） Java SE 7 JDK 1.7 2011-07-28 Dolphin（海豚） Java SE 8 JDK 1.8 2014-03-18 Spider（蜘蛛） Java SE 9 JDK 1.9 2017-09-21 Java SE 10 JDK 10 2018-03-21 Java SE 11 JDK 11 2018-09-25 Java SE 12 JDK 12 2019-03-20 static详见Java中的static。 面向对象父类中的方法默认可以被子类重写，加上final则只能被继承不能被重写。而加了final的类无法被继承。 父类的构造方法不能被继承，但子类会调用父类的构造方法。Java虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。而Java虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用super()即父类的构造方法。如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。 子类重写父类的方法，作用域不能比父类小。如Son重写Father的output方法，该方法在Father中是protected的，那么Son中重写只能是public或protected，不能是default和private。 只有抽象类中才能有抽象方法，抽象方法不能有函数体，非抽象的子类必须实现其函数体。 基本类型 和 包装类 有时我们需要基本数据类型也有对象的特征，因此出现了包装类，将基本数据类型包装起来使其具有对象的性质，并添加了属性和方法。 基本数据类型与包装类型的区别 默认值不同：基本类型的值是0、false等，包装类默认为null 初始化方式不同：包装类要用new的方式创建，基本类型不需要 存储方式不同：基本类型主要保存在栈上，包装类对象保存在堆上 &#x3D;&#x3D; 和 equals()对于基本数据类型如，==比较的是值，且基本类型没有equals方法。 对于包装类等对象，==比较的是地址，equals方法默认比较的也是地址，但可以重写来自定义比较逻辑。 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; Integer a = 128; Integer b = 128; System.out.println(a == b); // false System.out.println(a.equals(b)); // true // 范围在 -128 ~ 127 内的数，用 == 比较为 true Integer c = 127; Integer d = 127; System.out.println(c == d); // true String e = &quot;你好，世界&quot;; String f = &quot;你好，世界&quot;; System.out.println(e == f); // true System.out.println(e.equals(f)); // true String g = new String(&quot;你好，世界&quot;); String h = new String(&quot;你好，世界&quot;); System.out.println(g == h); // false System.out.println(g.equals(h)); // true String s1 = &quot;你好，世界&quot;; String s2 = new String(&quot;你好，世界&quot;); String s3 = new String(&quot;你好，世界&quot;); System.out.println(s1 == s2); // false System.out.println(s2 == s3); // false&#125; 双引号直接写的字符串是在常量池之中，而new的对象则不在池之中。 包管理 修饰符 当前类 同一包内 同一包内的子类 不同包内的子类 其他包 public √ √ √ √ √ protected √ √ √ 可访问父类的protected，不可访问父类对象的protected × default √ √ √ × × private √ × × × × instanceof：判断一个变量是否是某个类的实例12345// Car 是 Vehicle 的子类Car car = new Car();boolean flag1 = car instanceof Car // flag1 = trueboolean flag2 = car instanceof Vehicle // flag2 = trueboolean flag3 = car instanceof Cat // flag3 = false Math 原始值 floor（向下取整） round（四舍五入） ceil（向上取整） 2.7 2 3 3 2.3 2 2 3 -2.3 -3 -2 -2 -2.7 -3 -3 -2 floor是地板的意思，ceil是天花板，就很好记了 try &amp; catch &amp; finally在try中存在return的情况下，会把try中return的值存到栈帧的局部变量表中，然后去执行finally语句块，最后再从局部变量表中取回return的值返回。 当try和finally里都有return时，会忽略try的return，而使用finally的return。 正常情况下，finally中的代码一定会得到执行。但是如果我们将执行try-catch-finally代码块的线程设置为守护线程，或者在fianlly之前调用System.exit结束当前虚拟机，那么finally则不会得到执行： 123456789101112131415161718// 在fianlly之前调用 System.exit 结束当前虚拟机try &#123; System.exit(0);&#125; catch (Exception e) &#123; // TODO&#125; finally &#123; // TODO&#125;Thread thread = new Thread() &#123; @Override public void run() &#123; // try-catch-finally &#125;&#125;;thread.setDaemon(true); // 将 thread 设为守护线程thread.start(); throw &amp; throwsthrow用于主动抛出异常： 1234567891011public double divide(double x, double y) &#123; try &#123; if (y == 0) &#123; throw new ArithmeticException(); &#125; else &#123; return x / y; &#125; &#125; catch (ArithmeticException exception) &#123; exception.printStackTrace(); &#125;&#125; 加了throws的函数，函数内部抛出的异常要在函数外捕捉到： 12345678910111213141516// 当抛出异常时，不在函数内捕捉，而是抛出到函数外public double divide(double x, double y) throws ArithmeticException &#123; if (y == 0) &#123; throw new ArithmeticException(); &#125; return x / y;&#125;// 捕捉到divide方法内部抛出的异常public static void main(String[] args) &#123; try &#123; divide(5, 0); &#125; catch (ArithmeticException exception) &#123; exception.printStackTrace(); &#125;&#125; ArrayList 与 LinkedList 的区别底层数据结构 ArrayList 使用动态数组来存储元素，这意味着在内存中分配一块连续的内存空间来保存元素 LinkedList 使用双向链表来存储元素，每个元素都包含对前一个和后一个元素的引用 插入和删除操作 ArrayList 的随机访问非常快速，因为可以通过索引直接访问元素。但是，插入和删除元素时，需要移动后续元素，效率较低 LinkedList 的插入和删除操作效率较高，因为只需更改节点的引用。但是，随机访问元素效率较低，因为必须从头或尾部开始遍历链表 内存消耗 ArrayList 在存储大量元素时可能会浪费一些内存，因为它分配一块较大的内存空间。但它在随机访问时效率较高 LinkedList 每个元素都需要额外的内存来存储引用，因此在存储大量元素时可能会消耗更多内存。但它在插入和删除操作时效率较高 适用场景 ArrayList 适用于需要频繁随机访问元素的情况，但不需要频繁执行插入和删除操作的情况 LinkedList 适用于需要频繁执行插入和删除操作的情况，但不需要频繁随机访问元素的情况 String相关详见Java中的String。 泛型泛型的优点： 类型安全：泛型在编译时提供了类型检查，可以在编译阶段捕获类型错误，而不是在运行时抛出异常 更好的性能：泛型的类型检查是在编译时进行的，不需要运行时的类型检查，因此可以提高程序的性能 代码复用：泛型可以编写更通用、可复用的代码，减少代码的冗余 可读性：使用泛型可以在代码中看到操作的数据类型，提高代码的可读性 泛型擦除：泛型信息在编译后会被擦除，在运行时，所有的泛型类型参数都会被视为Object类型 线程 继承 Thread 类自定义一个类继承Thread，重写其run方法，实例化后调用其start方法开启线程： 1234567891011121314151617181920212223/// MyThread.javapublic class MyThread extends Thread &#123; private final String name; MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; super.run(); System.out.println(&quot;我是线程&quot; + name); &#125;&#125;/// mainpublic static void main(String[] args) &#123; MyThread threadA = new MyThread(&quot;A&quot;); MyThread threadB = new MyThread(&quot;B&quot;); threadA.start(); threadB.start(); System.out.println(&quot;主线程结束&quot;);&#125; 运行结果可能是先A后B，也可能是先B后A。 实现 Runnable 接口创建自定义类实现Runnable接口，重写其run方法。创建一个Thread对象，传入的参数即自定义类的一个实例，再调用Thread对象的start方法： 123456789101112131415161718192021222324/// MyRunnable.javapublic class MyRunnable implements Runnable &#123; final private String name; MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(&quot;我是线程&quot; + name); &#125;&#125;/// mainpublic static void main(String[] args) &#123; MyRunnable runnableC = new MyRunnable(&quot;C&quot;); MyRunnable runnableD = new MyRunnable(&quot;D&quot;); Thread threadC = new Thread(runnableC); Thread threadD = new Thread(runnableD); threadC.start(); threadD.start(); System.out.println(&quot;主线程结束&quot;);&#125; Callable创建自定义类实现Callable接口，重写call方法，即子线程要实现的逻辑，且有一个泛型返回值。使用FutureTask类来包装Callable对象并启动线程，主线程将会等待子线程结束后，通过FutureTask对象的get方法获取其返回值，然后才会往下执行。 12345678910111213141516171819202122232425262728293031323334/// MyCallable.javapublic class MyCallable&lt;V&gt; implements Callable&lt;V&gt; &#123; final private V data; MyCallable(V data) &#123; this.data = data; &#125; @Override public V call() &#123; return data; &#125;&#125;/// mainpublic static void main(String[] args) &#123; MyThread threadA = new MyThread(&quot;A&quot;); threadA.start(); System.out.println(&quot;主线程开始实例化Callable&quot;); MyCallable&lt;String&gt; myCallable = new MyCallable&lt;&gt;(&quot;E&quot;); FutureTask&lt;String&gt; myFutureTask = new FutureTask&lt;&gt;(myCallable); Thread threadE = new Thread(myFutureTask); threadE.start(); try &#123; String data = myFutureTask.get(); System.out.println(&quot;我是线程&quot; + data); &#125; catch (InterruptedException | ExecutionException e) &#123; throw new RuntimeException(e); &#125; System.out.println(&quot;主线程结束&quot;);&#125; 输出结果：我是线程E在主线程开始实例化Callable之后，在主线程结束之前。 LocalDateTime &amp; LocalDate &amp; LocalTime参考的是这篇文章 三者区别是，LocalDate只能存日期，LocalTime只能存时间，LocalDateTime既可以存日期又可以存时间。这里只介绍LocalDateTime。 12345678910111213141516171819202122// 实例化var localDateTime1 = LocalDateTime.now();var localDateTime2 = LocalDateTime.of(2023, 9, 11, 22, 23, 00); // 2023-09-11 22:23:00// 字符串转LocalDateTimevar localDateTime3 = LocalDateTime.parse(&quot;2023-09-11T22:23:00&quot;); // 必须要有TDateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);var localDateTime4 = LocalDateTime.parse(&quot;2023-09-11 22:23:00&quot;, formatter); // 将字符串按照formatter中规定的格式转化// 获取星期DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek(); // 假设为星期天System.out.println(dayOfWeek.getValue()); // 7// TextStyle.FULL(星期全称), Locale.CHINA(用中文输出)System.out.println(dayOfWeek.getDisplayName(TextStyle.FULL, Locale.CHINA)); // 星期日// TextStyle.FULL(星期全称), Locale.CHINA(用中文输出)System.out.println(dayOfWeek.getDisplayName(TextStyle.Short, Locale.CHINA)); // 周日// 获取月份同上// 增加日期localDateTime1 = localDateTime1.plus(5, ChronoUnit.DAYS); // 日期+5，下同localDateTime1 = localDateTime1.plusDays(5); Date &amp; Calendar （已弃用）看完一问chatGPT，才知道这俩已经被LocalDateTime取代了，旧教程害人啊……笔记都做完了，就不删了吧 按自定义格式输出时间： 123SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;);System.out.println(format.format(date));// 2023-09-09 19:54:33 周六 其中HH:mm:ss是24小时制，hh:mm:ss是12小时制 或者用printf： 12System.out.printf(&quot;现在是：%tY-%tm-%td，%tp%tH:%tM:%tS，%tA&quot;, date, date, date, date, date, date, date, date);// 现在是：2023-09-09，下午20:07:02，星期六 使用Calendar 12345Calendar calendar = Calendar.getInstance(); // 创建对象，默认为当前时间calendar.set(2002, 11, 30); // 设置年月日calendar.set(Calendar.YEAR, 2077); // 单独设置某个属性System.out.println(calendar.get(Calendar.YEAR));// 2077 有关Date类与Calendar类的更多信息，参考这里","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"}]},{"title":"Github页面美化","slug":"Github页面美化","date":"2023-09-10T12:23:58.000Z","updated":"2024-05-29T12:48:40.297Z","comments":true,"path":"2023/09/10/Github页面美化/","link":"","permalink":"http://princesaoke.github.io/2023/09/10/Github%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/","excerpt":"","text":"本文介绍如何把你的Github首页打扮的花里胡哨。 注：本文章内的icon可能需要vpn才能加载出来 在Github首页展示自定义内容每个项目的根目录下的README.md文件是该项目的说明，我们在接触一个项目时要做的第一件事就是阅读这个README.md文件。 在github，每个仓库的根目录下的README.md文件中的内容会被展示在源代码下方，便于阅读。如果你将仓库名称设为自己的github昵称，系统会提示你这是一个特殊的仓库。它的README.md文件不仅会展示在仓库下方，还会被展示在该用户的github首页，这意味着我们可以在其中添加一些自我介绍，让访客可以在首页直接看到。 添加技术栈icon你是否在他人的github首页看到这样花花绿绿的炫酷图标： 这是用到了 shields.io 上的icon图标。进入其官网，点击 Get Started，第一个 Static Badge 就是我们要用的。看它的默认样式，可能会觉得有点眼熟，因为很多地方都有用到，比如VSCode拓展插件介绍页面常用的icon。 注意，shields.io 的icon可能需要vpn才能正常加载。 简单来说，你可以通过在markdown中输入url来显示icon。 对于默认的样式，在markdown文件中引入 https://img.shields.io/badge/前半部分-后半部分-blue 来显示一个icon： 参数可以修改，其中颜色可以用六位十六进制数表示： https://img.shields.io/badge/Part1-Part2-FF0000 这和我们想要的效果差的有点远，别担心，回到shields.io的页面，在下方的 Query Parameters 中说明了我们可以在url中添加参数来调整icon的样式。 style：默认为flat，改成 flat-square 变成方角 logo：显示在icon左半部分，使用图标slug引用。文档告诉我们可以在 Simple Icons slugs 中找到logo对应的值。 logoColor：logo的颜色。同样可以使用十六进制表示。 综上，我们可以实现这样的icon： https://img.shields.io/badge/-Hexo-0073AA?style=flat-square&amp;logo=hexo&amp;logoColor=ffffff 其中左半部分的文字（label）为空 剩下就是依葫芦画瓢，可以加入其他参数让icon更美观。 Github Stats注意到还有张 Github Stats 的图片，上边显示你github的各项数值，同时打了一个等级，看起来也很炫酷，copy了！ 怎么做呢？这其实是引用了 GitHub Readme Stats ，可以在README.md中获取动态生成的gitHub统计信息。 进入 GitHub Readme Stats 的文档，文档里直接告诉你了将以下代码复制进README.md文件就可以： 1[![GitHub stats](https://github-readme-stats.vercel.app/api?username=你的Github昵称)](https://github.com/你的Github昵称/github-readme-stats) // 替换其中的Github昵称 当然官方也提供了其他参数支持自定义，可以选择隐藏指定信息或修改主题颜色等。具体方法文档里都有，此处省略。 这个项目非常强大，还支持编程语言统计（柱状图、环形图和饼状图），以及将仓库卡片展示到README.md中，最重要的是有中文文档！Star了！ 贪吃蛇动图具体步骤参考这个视频 并且，就在我写这篇博文的时候，突然发现这个up还找到了Github上一个profile巨丰富的用户：https://github.com/BEPb 当然这家伙的首页内容对于一般人来说就过于花里胡哨了，我们没必要整太多华而不实的东西，挑一两个喜欢的效果装扮一下自己的主页就好了。 我的Github首页","categories":[{"name":"其他","slug":"其他","permalink":"http://princesaoke.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://princesaoke.github.io/tags/Github/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2023-09-02T03:40:09.000Z","updated":"2024-05-29T12:48:22.728Z","comments":true,"path":"2023/09/02/Hexo搭建个人博客/","link":"","permalink":"http://princesaoke.github.io/2023/09/02/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"本文介绍如何使用Hexo搭建一个个人博客。 一、安装Node.js关于安装node.js这部分，我参考的是这篇文章。 首先到node.js中文官网下载安装包。 运行安装包，修改安装路径，不勾选 necessary tools，一路next安装完毕。默认的设置是有安装npm的，这个很重要，相当于应用商店，第三方的包都通过它下载，必装。 顺便吐槽一句这个npm明明用了淘宝镜像还是一样下载不动，然后过一会就又好了，玄学网络。而且下载完一个包也无法继续输入命令，只能关掉cmd重新打开，隔壁python的pip都没有这种问题。 win+r输入cmd打开命令提示符，输入 1node -v 或 1node --version 查看node版本，如果提示“不是内部或外部命令”说明没安装成功。 npm也是一样，输入 1npm -v 查看npm版本。 二、安装Hexo成功安装node.js和npm后，继续在cmd中输入以下命令 1npm install -g hexo-cli 安装Hexo。 合理外推卸载命令就是 1npm uninstall -g hexo-cli 注意到有个-g，意思是全局安装，不加-g就是在当前文件夹局部安装，出了当前文件夹就相当于没安装，类比python的虚拟环境。 同时还有 hexo 和 hexo-cli 的区别，之前也疑惑过 vue 和 vue-cli，这个我暂时还不太明白。总之有-cli和没有是两个不同的东西。按我理解，用hexo就是把hexo整个框架都下载下来，而用hexo-cli就是只下载hexo的一些命令，用创建hexo项目的时候用命令远程拉取模板。不知道我理解的对不对。 三、创建Hexo项目cmd输入 1hexo init personal-hexo 新建hexo项目。其中personal-hexo是创建的hexo项目的名称 进入hexo项目的文件夹，一手 1npm install 安装依赖包。 再一手 1hexo server 或 1hexo s 启动hexo服务器。这时会告诉你hexo正在本地运行，打开它给的地址 http://localhost:4000/ ，就可以看到hexo的默认页面了。 四、Hexo使用指南IDE打开hexo项目，先看项目结构。根目录下，scaffolds文件夹里存放模板文件。scaffolds&#x2F;post.md 文件就是文章的模板文件，比如往里面加一条categories，新建的博文就会带上这个字段。 scaffolds&#x2F;_config.yml 文件是整个博客网站的配置文件。title就是HTML中的title，subtitle和description想填什么就填什么，author改成自己，language改成zh-CN，url改成 http:&#x2F;&#x2F;你的Github昵称.github.io ，其他暂时都不用改。 scaffolds&#x2F;source 文件夹下的是网站的主体，其中的文件夹可以通过url访问到，以下划线开头的文件夹除外。 scaffolds&#x2F;source&#x2F;_posts 中存放的即我们的博客。在终端中执行命令 1hexo new Hexo搭建个人博客 其中”Hexo搭建个人博客”是文章名。 发现 scaffolds&#x2F;source&#x2F;_posts 中多了刚才新建的文章，打开浏览器也可以看到博文创建成功了。现在可以用markdown尽情编辑博文了！ 五、更换主题我使用的是 hexo-theme-pure 主题，Github地址在这，Gitee地址在这。建议看Gitee上的，文档是中文。 第三方的主题都放在themes文件夹下。项目根目录下终端执行 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure themes&#x2F;pure&#x2F;_config.yml 是主题的配置文件。按需配置，我的配置如下： menu决定菜单中有哪些栏目。由于我没有豆瓣号，就把豆瓣书单那一栏注释掉了，这样就没有豆瓣书单这个页面。 site决定博客网站的基本配置。 根据logo中的url找到对应的图片，即博客的头像，改成自己的图片。 title就是HTML中的title favicon即浏览器标签上的图标，找到 themes&#x2F;pure&#x2F;source&#x2F;favicon.png，改成自己的图片。 board是公告，可以是HTML中的元素 configskin可以更改主题颜色，除默认的白色外还有 theme-black theme-blue theme-green theme-purple 四种。 donate文章底部请作者喝咖啡的赞赏部分。我不喜欢，enable改成false就不显示了。要保留的话按对应路径找到图片替换成自己的。 share文章底部的分享部分。sites是电脑网页显示的，mobile_sites是手机网页端显示的，可以加的值有 qq,wechat,qzone,weibo,facebook,twitter repositoryplatform有github和gitee两种，username填你对应托管平台的用户名。 pv用于统计你的网站有多少访客。提供了不蒜子和leancloud两种方式，我用的是不蒜子，把busuanzi下的enable设为true。 postCount统计你每一篇文章的字数和阅读时间。要开启哪一个功能就把对应的值设为true，enable为true则这两个功能都失效。 profile一些个人资料。按前面的方法自行配置就好了。 复制_source把 themes&#x2F;pure&#x2F;_source里的所有文件夹（除去你前面menu那里注释掉的界面，比如我不需要豆瓣书单，books文件夹就不需要复制）复制到根目录下的source文件里。_data和404也复制过去。_data里的links.yml文件中是友情链接，每个友情链接按如下格式： 1234MyFriendName: link: https://his_link/ // 改成朋友的链接 avatar: https://his_avatar.png // 改成朋友的头像url desc: &quot;His discription&quot; // 给朋友的描述 _data里的gallery.yml文件是干什么的我暂时还没搞懂。 现在重新访问浏览器，发现你的博客网站已经大变样了，一切操作正确的话不会出现任何问题。 六、将Hexo部署到 Github Pages使用 hexo-deployer-git。参考这篇文章。 先在自己的github上新建一个仓库，仓库名为 你的Github昵称.github.io ，如 PrinceSaoKe.github.io。 在终端输入 1npm install hexo-deployer-git --save 安装 hexo-deployer-git。 打开根目录下的_config.yml文件，滑到最底下找到deploy，改成 1234deploy: type: git repo: https://github.com/你的github昵称/你的github昵称.github.io branch: master // 注意看你仓库的主分支是master还是main，一般是master 最后，依次在终端输入以下命令： 123hexo cl // 清理之前的页面hexo g // 生成新的页面hexo d // 部署网站到创建的仓库 hexo d这一步需要vpn。 刚部署完可能要过一两分钟，然后在任意一个设备的浏览器输入网址 http:&#x2F;&#x2F;你的Github昵称.github.io 就可以访问到你的hexo博客啦！ 写博客好累，后面应该不会写得这么详细了。我的hexo个人博客也上传到了github，欢迎参观","categories":[{"name":"其他","slug":"其他","permalink":"http://princesaoke.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://princesaoke.github.io/tags/Hexo/"}]}],"categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"计网","slug":"计网","permalink":"http://princesaoke.github.io/categories/%E8%AE%A1%E7%BD%91/"},{"name":"算法","slug":"算法","permalink":"http://princesaoke.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"其他","slug":"其他","permalink":"http://princesaoke.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"},{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://princesaoke.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://princesaoke.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://princesaoke.github.io/tags/CSS/"},{"name":"Vue3","slug":"Vue3","permalink":"http://princesaoke.github.io/tags/Vue3/"},{"name":"MySQL","slug":"MySQL","permalink":"http://princesaoke.github.io/tags/MySQL/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://princesaoke.github.io/tags/Kotlin/"},{"name":"服务器","slug":"服务器","permalink":"http://princesaoke.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Git","slug":"Git","permalink":"http://princesaoke.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://princesaoke.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://princesaoke.github.io/tags/Hexo/"}]}