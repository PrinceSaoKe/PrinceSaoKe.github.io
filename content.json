{"meta":{"title":"骚客.的个人博客","subtitle":"记录我的学习过程","description":"使用Hexo搭建，欢迎交流","author":"骚客.","url":"http://PrinceSaoKe.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-09-02T06:14:08.855Z","updated":"2023-09-02T06:14:08.855Z","comments":false,"path":"/404.html","permalink":"http://princesaoke.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-12-20T16:16:19.189Z","updated":"2023-12-20T16:16:19.189Z","comments":false,"path":"about/index.html","permalink":"http://princesaoke.github.io/about/index.html","excerpt":"","text":"参观我的个人网站：http://saoke.fun"},{"title":"Repositories","date":"2023-09-02T06:14:08.862Z","updated":"2023-09-02T06:14:08.862Z","comments":false,"path":"repository/index.html","permalink":"http://princesaoke.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-02T06:14:08.859Z","updated":"2023-09-02T06:14:08.859Z","comments":false,"path":"categories/index.html","permalink":"http://princesaoke.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-09-02T06:14:08.863Z","updated":"2023-09-02T06:14:08.863Z","comments":false,"path":"tags/index.html","permalink":"http://princesaoke.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-02T06:14:08.860Z","updated":"2023-09-02T06:14:08.860Z","comments":true,"path":"links/index.html","permalink":"http://princesaoke.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"智元机器人客户端实习面经","slug":"智元机器人客户端实习面经","date":"2023-12-12T08:01:09.000Z","updated":"2023-12-12T14:59:33.658Z","comments":true,"path":"2023/12/12/智元机器人客户端实习面经/","link":"","permalink":"http://princesaoke.github.io/2023/12/12/%E6%99%BA%E5%85%83%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"面试是一个月以前的事了，已经被录用，有些地方记不清了。总共面了两轮，都是飞书线上面试。每次面试最后都有反问环节，我都事先准备了要反问的问题。 一面一面问的都是Flutter相关的技术问题，完全没有牵扯到其他方面，面试官是负责社招的，实习后也由他来带我。总共面了40分钟左右，问题如下，打钩的是我觉得算回答出来的： √ 自我介绍 √ 学习Flutter多久了？ × 了解Dart中的dynamic和var吗？它们赋值后可以更改数据类型吗？ √ const和final的区别，late的用法？ √ Dart空安全相关，?.和?? × Dart如何实现单例？ × 给一张UI图，说出大致的布局实现方式？ √ 要点击导航栏切换body，如何实现？ × 快速点击导航栏切换页面，多个页面请求完成后在短时间内快速渲染，页面会出现闪烁，如何解决？ × 更改页面的宽度，要icon不变，仅缩小文字的宽度，文字溢出设置成省略号的样式，如何实现？ √ Dart中的可选参数是什么，有什么用，如何设置其默认值？ × 组件前加const起到什么作用？ × 如何实现局部刷新？ √ 如何实现动画？如改变透明度、位移、旋转等 √ 如何用Flutter的Canvas绘制出折线、带填充的矩形？ 问到动画和Canvas是因为简历上有写。 一面个人感觉挺失败的，很多问题都没回答上来。比如给UI图实现布局，我有开发经验按理这不是难事，但面试官给的是PC端的页面，我之前做的都是移动端，导航栏在底部，PC端导航栏在左边，而且一些布局也略微不同，加上面试是直接口述而非敲代码可以修改，一时有点无从下手，气氛明显尴尬了起来。问到局部刷新，我记得似乎曾经在某个帖子有看到过SafeArea与之相关，就半蒙半猜地说了，面试结束后一百度，根本是牛头不对马嘴……面到后面自己都没自信了，只想快点结束。 当时面完就觉得没戏了，没想到过了两天居然收到了hr的电话，约了二面。 二面二面的问题更有开放性，面试官好像是软件部门的主管，有开摄像头，在我回答不出来的时候会引导我思考，所以感觉会轻松一些，总共20多分钟。 √ 自我介绍 √ 为什么想要来实习？ √ 为什么学习Flutter？ × 为什么Flutter选用Dart作语言？Dart优势何在？ √ 问项目，哪些功能是调用第三方接口？项目是否获奖？开发中最大的困难是什么？ × 结合信安专业，如何防止攻击者破解用户账号密码？ √ 除了移动端、Flutter，是否关注了其他技术相关的东西或行业发展？ 和一面相比明显感觉二面的问题更综合考量一个人的能力、行业理解和培养价值。 有点出乎我意料的是，面试官看到我是信安专业的，问了我安全方面的问题。先是问有什么提高账号安全性的方法，我回答数据库密码存储哈希值而非明文、做输入检查防止SQL注入等。又问如果有人尝试用暴力尝试的方法破解密码应该如何防御？我回答加验证码。又问现在AI很强大，可以完成验证，是否有别的方法？面试官提示如果绕过客户端直接给后端发包呢，我回答APP加混淆避免反编译，不要让攻击者知道接口URL。面试官说加混淆可以，但接口总是要暴露在外的，有没有别的办法？我回答后端判断短时间内是否有同一个IP地址多次尝试登录同一个账号，如果是说明有人在暴力破解，就拒绝请求。面试官说如果是在连校园网的环境下，很多设备的IP地址是一样的，可能造成“误伤”，并且后端如何知道设备的登录次数呢？又问如果是固定密码去试账号要如何防御？最后我没有回答出来，面试官说这可能要不止一次网络请求，应该是属于进阶一点的问题了。 最后反问环节我问面试官我有哪些地方有没有表达得不好的地方，面试官回答这不能说。他告诉我大概五个工作日内会有结果，这一等就是半个月，就在我以为凉凉了要准备投下一份简历的时候，又接到了hr的电话，被录用了。","categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"Vue3笔记","slug":"Vue3笔记","date":"2023-11-28T08:55:45.000Z","updated":"2023-12-20T16:23:50.029Z","comments":true,"path":"2023/11/28/Vue3笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/28/Vue3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"创建项目终端运行： 1npm create vue@latest 使用 Vite 创建项目注意：Vite 需要 Node.js 版本 14.18+，16+ 终端执行： 1npm create vite@latest 指令v-html&#123;&#123; button &#125;&#125;中元素不会被解析，需要用&lt;div v-html=&quot;button&quot;&gt; 12345678&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const button = ref(&#x27;&lt;button&gt;Click Me&lt;/button&gt;&#x27;)&lt;/script&gt;&lt;template&gt; &lt;div v-html=&quot;button&quot;&gt;&lt;/div&gt;&lt;/template&gt; 相当于将&lt;div&gt;的innerHTML设为button中的元素 v-bind使用指令v-bind:属性名=&quot;&quot;或其简写:属性名=&quot;&quot;为元素添加单个属性，或者使用v-bind=&quot;&quot;添加多个属性，具体如下： 12345678910111213141516&lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const myId = ref(&#x27;nav&#x27;) const myClass = ref(&#x27;container&#x27;) const isButtonDisabled = ref(true) const myAttr = &#123; id: &#x27;nav&#x27;, class: &#x27;container&#x27; &#125;&lt;/script&gt;&lt;template&gt; &lt;div v-bind:id=&quot;myId&quot; :class=&quot;myClass&quot;&gt;bind&lt;/div&gt; &lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; &lt;span v-bind=&quot;myAttr&quot;&gt;&lt;/span&gt;&lt;/template&gt; v-for12345678910111213141516&lt;script setup&gt; import &#123; reactive &#125; from &#x27;vue&#x27; const stars = reactive([ &#123; name: &#x27;角木蛟&#x27;, part: &#x27;东方苍龙&#x27; &#125;, &#123; name: &#x27;井木犴&#x27;, part: &#x27;南方朱雀&#x27; &#125;, &#123; name: &#x27;奎木狼&#x27;, part: &#x27;西方白虎&#x27; &#125;, &#123; name: &#x27;斗木獬&#x27;, part: &#x27;北方玄武&#x27; &#125;, ])&lt;/script&gt;&lt;template&gt; &lt;ul v-for=&quot;star in stars&quot;&gt; &lt;li&gt;星宿名：&#123;&#123; star.name &#125;&#125;，所属星象：&#123;&#123; star.part &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; v-if 和 v-show 的区别v-show不管初始条件是否为真，元素都会被渲染，只不过是根据条件修改元素的样式来判断是否显示。当v-show=&quot;false&quot;时，给元素加上style=&quot;display: none;&quot;，当v-show=&quot;true&quot;时，移除该样式。因此元素始终是存在的。 v-if=&quot;false&quot;则是将元素直接删除，DOM元素不再存在。 由于v-show始终都会渲染元素，因此有更高的初始渲染消耗，而v-if若为假则初始时不需要渲染，则没有这部分的消耗。但切换时v-show只需要移除display: none，因此相比v-if的切换消耗会更低。 如果需要频繁切换则用v-show，如果在运行时很少改变则用v-if。 响应式数据ref 和 reactive 的区别12345&lt;script setup&gt; import &#123; ref, reactive &#125; from &#x27;vue&#x27; const count = ref(0) const user = reactive(&#123; id: 1, name: &#x27;星日马&#x27; &#125;)&lt;/script&gt; ref可以用于基本数据类型和对象，但reactive只能用于对象 访问ref的值要count.value，而访问reactive的值直接user不需要加value ref适合基本数据类型，reactive适合对象 单独将ref对象中的变量赋值给新变量，新变量也支持响应式；但对reactive进行同样操作则新变量不具备响应式 ref通过外层包裹一个对象来实现，reactive通过proxy实现 toRef将普通变量和响应式对象的成员变量进行双向响应式绑定，不论是改变普通变量的值还是成员变量的值，数据都会更新，解决了reactive无法抽离出响应式变量的问题。 123456789101112131415161718192021222324&lt;script setup&gt; import &#123; ref, reactive, toRef &#125; from &#x27;vue&#x27; const flower = ref(&#123; name: &#x27;梅花&#x27;, price: 48 &#125;) const user = reactive(&#123; id: 1, name: &#x27;房日兔&#x27; &#125;) const flowerPrice = toRef(flower.value, &#x27;price&#x27;) let userId = toRef(user, &#x27;id&#x27;) setInterval(() =&gt; &#123; flower.value.price++ // 改变对象的成员变量的值，普通变量的值也会更新 userId.value++ // 改变普通变量的值，成员变量也会更新 &#125;, 1000);&lt;/script&gt;&lt;template&gt; &lt;h1&gt;flowerPrice: &#123;&#123; flowerPrice &#125;&#125;&lt;/h1&gt; &lt;h1&gt;userId: &#123;&#123; userId &#125;&#125;&lt;/h1&gt;&lt;/template&gt; toRefs与toRef的区别尚不明确。 123456789101112131415161718192021222324&lt;script setup&gt; import &#123; ref, reactive, toRefs &#125; from &#x27;vue&#x27; const flower = ref(&#123; name: &#x27;梅花&#x27;, price: 48 &#125;) const user = reactive(&#123; id: 1, name: &#x27;房日兔&#x27; &#125;) let flowerPrice = toRefs(flower.value)[&#x27;price&#x27;] let userId = toRefs(user).id setInterval(() =&gt; &#123; flower.value.price++ userId.value++ &#125;, 1000);&lt;/script&gt;&lt;template&gt; &lt;h1&gt;flowerPrice: &#123;&#123; flowerPrice &#125;&#125;&lt;/h1&gt; &lt;h1&gt;user.id: &#123;&#123; user.id &#125;&#125;&lt;/h1&gt;&lt;/template&gt; 事件处理可以使用v-on指令来监听DOM事件，也可缩写成@，用法： 123456789101112&lt;script setup&gt;function myFunction() &#123; console.log(&#x27;触发了myFunction方法&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;button v-on:click=&quot;myFunction&quot;&gt;&lt;/button&gt; &lt;button @click=&quot;myFunction&quot;&gt;&lt;/button&gt;&lt;/template&gt; 事件修饰符在原生JS中，我们可以使用even.preventDefault()来阻止默认事件或使用event.stopPropagation()阻止事件冒泡，Vue提供了更优雅的实现方式，即事件修饰符： 1234567891011121314151617181920212223&lt;script setup&gt;function myFunction() &#123; console.log(&#x27;触发了myFunction方法&#x27;)&#125;function clickDiv() &#123; console.log(&#x27;点击了div&#x27;)&#125;function clickP() &#123; console.log(&#x27;点击了p&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;a href=&quot;https://PrinceSaoKe.github.io&quot; @click.prevent=&quot;myFunction&quot;&gt;点了不会跳转的超链接&lt;/a&gt; &lt;div @click=&quot;clickDiv&quot;&gt; &lt;p @click.stop=&quot;clickP&quot;&gt;Hello World!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 输出为： 1点击了p 若不加.stop，则输出为： 12点击了p点击了div 该写法等同于： 1234567891011121314151617181920212223242526&lt;script setup&gt;function myFunction(event) &#123; event.preventDefault() console.log(&#x27;触发了myFunction方法&#x27;)&#125;function clickDiv(event) &#123; event.stopPropagation() console.log(&#x27;点击了div&#x27;)&#125;function clickP(event) &#123; event.stopPropagation() console.log(&#x27;点击了p&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;a href=&quot;http://princesaoke.github.io&quot; @click.prevent=&quot;myFunction&quot;&gt;点了不会跳转的超链接&lt;/a&gt; &lt;div @click=&quot;clickDiv&quot;&gt; &lt;p @click=&quot;clickP&quot;&gt;Hello World!&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; Element PlusElement Plus 官网 参考文章 可能用到的工具 名称 下载方式 描述 NVM NVM下载地址 一个nodejs的版本管理工具，通过它可以安装和切换不同版本的nodejs NRM npm install -g nrm npm的镜像管理工具，可以在npm镜像源间快速切换","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://princesaoke.github.io/tags/Vue3/"}]},{"title":"MySQL笔记","slug":"MySQL笔记","date":"2023-11-22T08:03:48.000Z","updated":"2023-11-23T12:25:55.475Z","comments":true,"path":"2023/11/22/MySQL笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/22/MySQL%E7%AC%94%E8%AE%B0/","excerpt":"","text":"很全的MySQL常用指令 安装MySQL在官方下载地址下载压缩包。 解压到要保存的路径，在 环境变量 -&gt; 系统变量 -&gt; Path 里面添加一行，指向MySQL的bin目录，如D:\\mysql-8.0.33-winx64\\bin。 在MySQL的bin文件夹里新建文件my.ini，文件内容为： 123456789[mysqld]# 设置mysql的安装目录(能看到bin即可)basedir=D:\\mysql-8.0.33-winx64\\# 设置mysql的数据存放目录datadir=D:\\mysql-8.0.33-winx64\\data\\# mysql端口port=3306# 跳过授权skip-grant-tables 记得把其中的路径换成你自己的安装路径。 然后以管理员身份打开cmd，进入MySQL的bin目录，输入： 1234567891011121314151617# 安装 mysql 服务mysqld –install# 初始化 data 文件夹 （你可以初始化多次，但是每次必须清空data文件夹）mysqld --initialize-insecure --user=mysql# 启动 mysql 服务net start mysql# 登录 mysql(让你输密码，直接回车即可)mysql -uroot -p# 修改 root 账户密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH &#x27;mysql_native_password&#x27; BY &#x27;新密码&#x27;;# 刷新权限，使之生效flush privileges; 然后将my.ini里跳过授权给注释掉# skip-grant-tables 输入\\q退出登录MySQL，然后重启MySQL用新设置的密码登录即可： 123net stop mysqlnet start mysqlmysql -uroot -p mysql -uroot -p这句意思是用户名为root，也可以在-p后直接跟密码，这样密码是可见的。 Windows Server 2022 上遇到的问题安装MySQL和初始化data文件夹时报错：找不到MSVCP140.dll文件解决方法：安装 Microsoft Visual C++ Redistributable 客户端库，点击前往下载。 输入net start mysql时报错：服务没有响应控制功能解决方法：下载VCRUNTIME140_1.dll，解压后拷贝到MySQL的bin文件夹下。 远程连接数据库开放MySQL端口首先要确保服务器的MySQL端口是放行的，在my.ini中我们设置了3306端口。 以阿里云服务器为例，在安全组中手动添加访问规则，目的端口3306，源0.0.0.0。 若端口没有放行，则会有以下报错： 1ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;XXX.XXX.XXX.XXX:3306&#x27; (10060) 设置远程登录权限在服务器上登录MySQL，然后输入： 123use mysql;update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; // 开放远程登录权限flush privileges; // 刷新权限 若没开启权限，则报错： 1ERROR 1130 (HY000): Host &#x27;XXX.XXX.XXX.XXX&#x27; is not allowed to connect to this MySQL server 远程登录MySQL在自己的电脑上打开cmd，输入： 1mysql -h主机地址 -u用户名 -p MySQL数据的备份终端进入MySQL安装目录下的bin目录，执行指令： 1234mysqldump -uroot -p 数据库名 &gt; 备份文件路径及文件名# 如：mysqldump -uroot -p flower_shop &gt; flower_shop_backup.sql MySQL备份数据的还原登录MySQL后执行以下指令： 123create database 数据库名称; // 创建一个新的数据库用于承载迁移来的数据use 数据库名称; // 切换到该数据库source 文件路径; // 导入备份数据 存储过程 &#x2F; Procedure相当于编程语言中的方法，定义SQL语句模板，可以传参调用。 创建一个存储过程，用于查询某种花的价格，调用后删除： 12345678910delimiter $$create procedure getFlowerPrice(in name varchar(15))begin select price from flower where flower.name=name;end $$delimiter ;call getFlowerPrice(&#x27;红玫瑰&#x27;);drop procedure getFlowerPrice; # 删除存储过程 其中delimiter作用是修改SQL语句结束符，避免存储过程中的;和语句结束符混淆。 触发器 &#x2F; Trigger在数据插入、修改、删除时自动执行某些操作，可用于数据库日志记录等。 创建一个触发器，当录入一种花但未给出花语时，将花语设为“暂无”： 123456789101112delimiter $$create trigger my_trigger before insert on flower for each rowbegin if new.flower_language is null then set new.flower_language=&#x27;暂无&#x27;; end if;end $$delimiter ;show triggers; # 查看触发器drop trigger flower_shop.my_trigger; # 删除触发器","categories":[{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://princesaoke.github.io/tags/MySQL/"}]},{"title":"Dart笔记","slug":"Dart笔记","date":"2023-11-08T08:34:56.000Z","updated":"2023-11-09T16:33:58.498Z","comments":true,"path":"2023/11/08/Dart笔记/","link":"","permalink":"http://princesaoke.github.io/2023/11/08/Dart%E7%AC%94%E8%AE%B0/","excerpt":"","text":"var 和 dynamicvar未赋初值时，默认值为null，赋值后数据类型可变。 1234var variable;print(variable); // nullvariable = &#x27;我是字符串&#x27;variable = 10.00 dynamic未赋初值时，默认值为null，赋值后数据类型可变，同var。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Kotlin笔记","slug":"Kotlin笔记","date":"2023-10-27T02:52:41.000Z","updated":"2023-10-27T07:21:40.235Z","comments":true,"path":"2023/10/27/Kotlin笔记/","link":"","permalink":"http://princesaoke.github.io/2023/10/27/Kotlin%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Kotlin 与 Java 的关系Java运行过程：Java源代码 -&gt; 编译 -&gt; 生成class文件 -&gt; JVM解释执行 Java虚拟机并不关心class文件是如何生成的，因此也可以使用Kotlin生成class文件，JVM也可以解释执行。 Kotlin可以无缝使用Java第三方的开源库。 val 与 var类比JavaScript中的const和let。 val用于声明常量，相当于加了final，赋值后无法修改；var用于声明变量。 ifKotlin中的if是带有返回值的。 12345val max = if(a &gt; b) &#123; a&#125; else &#123; b&#125; when相当于switch，不过用起来更方便。 1234567fun getScore(name: String) = when (name) &#123; &quot;张三&quot; -&gt; 85 &quot;李四&quot; -&gt; &#123; return 91 &#125; else -&gt; 0&#125; 区间闭区间1val range = 0..10 // [0, 10] 左闭右开区间1val range = 0 until 10 // [0, 10) 降序闭区间1val range = 10 downTo 0 // [10, 0] 循环for - in 循环12345678910// 输出 0~9for (i in 0 until 10) &#123; println(i)&#125;// 每次循环 i+=2for (i in 0..10 step 2) &#123; println(i)&#125;// 输出 0~10 内的偶数 构造函数Kotlin中有主次构造函数之分。 主构造函数没有函数体，直接定义在类名的后面。若想在主构造函数中编写一些逻辑，将代码写在init中： 1234567class Student(val name, val grade) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125;&#125;Student(&#x27;张三&#x27;, 86) 次构造函数有函数体，且必须调用主构造函数。 1234567891011class Student(val name, val grade) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125; constructor(name: String) : this(name, 0) &#123; // 次构造函数逻辑 &#125;&#125;Student(&#x27;张三&#x27;, 86) 继承Kotlin中非抽象类默认都是不可以被继承的，相当于给类加上了final。要声明为可继承类，需要加上open关键字。 同时子类中的构造函数必须调用父类中的构造函数。 1234567891011open class Person(val name) &#123; //TODO&#125;class Student(val name, val grade) : Person(name) &#123; init &#123; // 主构造函数的逻辑写在这里 &#125;&#125;Student(&#x27;张三&#x27;, 86)","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://princesaoke.github.io/tags/Kotlin/"}]},{"title":"前端笔记","slug":"前端笔记","date":"2023-10-22T05:47:29.000Z","updated":"2023-12-20T16:23:11.831Z","comments":true,"path":"2023/10/22/前端笔记/","link":"","permalink":"http://princesaoke.github.io/2023/10/22/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","excerpt":"","text":"均以Chrome浏览器为例。 const、let、var的区别const是常量，定义时必须赋初值，值不可修改。只限制变量绑定的值，不会限制引用数据类型内部的变动。如： 12345678const a = 1a = 2 // 报错const b = &#123; name: &#x27;张三&#x27;&#125;b.name = &#x27;李四&#x27; // 不会报错b = 1 // 报错 let声明的是变量。 const和let只在块内有效，即两个花括号之间，相当于局部的值。 var定义的变量是全局的，但一个函数内var的变量不能在函数外访问。 12345678var a = &#x27;我是a&#x27;function fun() &#123; console.log(a) // 输出&#x27;我是a&#x27; var b = &#x27;我是b&#x27;&#125;console.log(b) // 报错 用var定义两个同名变量，后定义的会覆盖掉先定义的。const和let不允许重复定义。 var存在变量提升的特性。当用var定义了一个变量，即便还未执行到，该变量也已经存在了，且值为undefined。 123456function fun() &#123; if (a == undefined) &#123; var a = 10 &#125; console.log(a) // 输出为10&#125; 造成这种现象的原因是，if中用var定义了a，因变量提升（hoisting）特性，在执行前a被提升到函数作用域顶部，且初始值为undefined，于是if成立，早已存在的a由undefined被赋值为10。 将var改用let就不会有这样的问题。 总结：无特殊情况不要用var，声明变量用let。声明对象类型用const，非对象类型用let。 innerHTML 和 innerText 的区别12345678910111213&lt;html&gt; &lt;head&gt;&lt;title&gt;innerHTML与innerText的区别&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;hello world &lt;/p&gt; &lt;/div&gt; &lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); alert(div1.innerHTML); // &lt;p id=&quot;p1&quot;&gt;hello world &lt;/p&gt; alert(div1.innerText) // hello world &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件循环 &#x2F; 消息循环浏览器的进程模型浏览器运行时有很多个进程，我们重点关注三大进程： 浏览器进程 网络进程 渲染进程（不止一个，每一个标签页就是一个渲染进程） 其中浏览器进程是打开浏览器后最先启动的，负责： 浏览器通用界面显示，如浏览器工具栏、浏览器设置等 用户交互，如监听点击、滚动等 子进程管理，浏览器其他进程均由浏览器进程开启 …… 网络进程负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。 渲染进程可以有多个，每一个标签页就是一个渲染进程，该进程包括一个渲染主线程和其他多个子线程。 渲染主线程是如何工作的渲染主线程的任务包括但不限于： 解析HTML 解析CSS 计算样式，如把rem转换为px等 计算布局，如计算元素宽高 处理图层，如根据z-index判断叠层关系 每帧绘制页面 执行JavaSctipt 执行事件处理函数 执行计时器的回调函数 …… 主线程每次执行一个任务，执行完后从消息队列中取出下一个任务。所有线程可以随时向消息队列中添加任务。这整个过程称为事件循环。 若是需要等待的任务，如setTimeout()函数会在等待规定时间后才执行，则不能直接加入消息队列，否则会导致主线程要等待，而后面的任务也无法执行。 主线程执行到js中的setTimeout()，会把要计时等待的任务交给计时线程，由计时线程到时间后将回调函数加入消息队列。 Q：如何理解JS的异步？ A： JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程承担着诸多的工作，渲染页面、执行JS都在其中运行。如果使用同步的方式，就极有可能导致主线程阻塞，从而导致消息队列中的很多其他任务无法得到执行。这一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，最大限度保证了单线程的流畅运行。 任务的优先级实际上消息队列不止一个队列，而是有多个队列：微队列、延时队列、交互队列等。 在W3C标准中，规定微队列是优先级最高的，意味着只有当微队列中所有任务都执行完了才会轮到其他队列。 在Chrome浏览器中，延时队列用于存放计时器到达后的回调函数，优先级为【中】；交互队列用于存放用户操作后产生的事件处理任务，优先级为【高】。 Q：阐释一下JS的事件循环？ A： 事件循环又叫消息循环，是浏览器渲染主线程的工作方式。在Chrome中，它开启一个不会结束的循环，每次循环从消息队列中取出第一个任务执行，而其他线程只要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种方式已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。根据W3C官方的规定，每个任务有不同的类型，同类型的任务必须在同一个队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务优先级最高，必须优先调度。 Q：JS中的计时器能做到精确计时吗？为什么？ A： 不行。受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，回调函数需要时间排队等待调度，因此带来了时间偏差。操作系统的计时函数本身就有少量偏差，而JS的计时器最终调用的是操作系统的计时函数，因此也具有一定偏差。 例题12345678910111213141516171819// Promise.resolve().then(fn) 会将函数fn加入微队列function fn1() &#123; console.log(1) Promise.resolve().then(function fn2() &#123; console.log(2) &#125;)&#125;setTimeout(function fn3() &#123; console.log(3) Promise.resolve().then(fn1)&#125;, 0)Promise.resolve().then(function fn4() &#123; console.log(4)&#125;)console.log(5) Q：浏览器执行以上js代码后输出是什么？ 解析： setTimeout将函数fn3添加到计时线程，0秒后时间到，计时线程将fn3添加到延时队列中排队等待调度； 全局js还未执行完，主线程继续执行，将fn4添加到微队列； 输出5； 全局js执行完毕，从消息队列中取出下一个任务。由于微队列优先级最高，因此取出fn4执行，输出4； fn4执行完毕，取出fn3执行，输出3，然后将fn1加入微队列； fn3执行完毕，取出fn1执行，输出1，然后将fn2加入微队列； fn1执行完毕，取出fn2执行，输出2； A： 1234554312","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"在HTML中使用阿里巴巴图标库的图标","slug":"在HTML中使用阿里巴巴图标库的图标","date":"2023-10-20T09:45:39.000Z","updated":"2023-11-29T16:12:31.346Z","comments":true,"path":"2023/10/20/在HTML中使用阿里巴巴图标库的图标/","link":"","permalink":"http://princesaoke.github.io/2023/10/20/%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%9B%BE%E6%A0%87%E5%BA%93%E7%9A%84%E5%9B%BE%E6%A0%87/","excerpt":"","text":"这里只介绍通过在线链接的方法。 进入(阿里巴巴图标库)[https://www.iconfont.cn]，选好需要的图标，放入购物车后将其加入项目。 进入资源管理-&gt;我的项目，切换到Font class，点击查看在线链接。 生成一个css链接，如//at.alicdn.com/t/c/font_4287312_tew9cz81kg.css，需要在前面加上http:，然后在HTML中引入： 123456&lt;head&gt; &lt;!-- 引入阿里巴巴图标库的项目 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/c/font_4287312_tew9cz81kg.css&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 用&lt;i&gt;元素使用图表，需要添加两个class：iconfont和对应的图标代码，如： 1234&lt;body&gt; &lt;!-- 假设图标代码为`icon-qq` --&gt; &lt;i class=&quot;iconfont icon-qq&quot;&gt;&lt;/i&gt;&lt;/body&gt; 其中图标代码可以在阿里巴巴图标库中复制 附上参考文章，其中有说明其他的引入图标方式","categories":[{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://princesaoke.github.io/tags/HTML/"}]},{"title":"Flutter中的一些问题","slug":"Flutter中的一些问题","date":"2023-10-17T09:57:05.000Z","updated":"2023-12-04T06:59:10.894Z","comments":true,"path":"2023/10/17/Flutter中的一些问题/","link":"","permalink":"http://princesaoke.github.io/2023/10/17/Flutter%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"命令行创建 Flutter使用命令行创建项目： 1flutter create --platforms=android,ios D:\\flutter_projects\\project_name 参数 说明 –project-name 项目名，全部小写+下划线 –platforms 支持的平台，可选值为：android、ios、windows、linux、macos、web，此参数仅在“–template”设置为应用程序或插件时有效 –description 项目描述，此字符串最终位于pubspec.yaml文件中，默认为：A new Flutter project. –org 项目的组织，使用反向域名表示法。此字符串用于Java包名称，并作为iOS捆绑包标识符中的前缀，默认为：com.example 有关该命令的更多信息，参见flutter --help create。 Android 未开启网络权限APP开发时正常，build后报错如下： 1[ERROR:flutter/lib/ui/http://ui_dart_state.cc(148)] Unhandled Exception: SocketException: Failed host lookup: &#x27;api.douban.com&#x27; (OS Error: No address associated with hostname, errno = 7) 解决方法： 在android\\app\\src\\main\\AndroidManifest.xml中添加网络权限： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 如：","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"远程连接服务器的一些方法","slug":"远程连接服务器的一些方法","date":"2023-10-14T16:07:40.000Z","updated":"2023-10-31T06:38:37.537Z","comments":true,"path":"2023/10/15/远程连接服务器的一些方法/","link":"","permalink":"http://princesaoke.github.io/2023/10/15/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"Windows Server 远程桌面连接如果你的服务器装的操作系统是 Windows Server ，那么可以在自己的 Windows 电脑上直接远程控制图形化界面。 Win+R输入mstsc运行，进入远程桌面连接，在计算机一栏中填写要连接的服务器IP地址或域名，用户名即服务器登录的用户名，输入密码连接，可以将记录保存在本地这样下次就不用再输密码了。 终端SSH远程连接服务器要求本地主机装有SSH客户端，服务器装有SSH服务器。可在 PowerShell 输入以下命令查看是否安装： 1Get-WindowsCapability -Online | Where-Object Name -like &#x27;OpenSSH*&#x27; 若均未安装则输出 12345Name : OpenSSH.Client~~~~0.0.1.0State : NotPresentName : OpenSSH.Server~~~~0.0.1.0State : NotPresent SSH客户端不用特地安装，安装git时自带。 Windows Server 2022 没有SSH服务器，需要自行安装。 用 PowerShell 安装管理员权限运行 PowerShell ，执行： 12345# 安装 OpenSSH 客户端Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# 安装 OpenSSH 服务器Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 安装完成后继续运行： 12345678910111213# 启动 SSH 服务器Start-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;# 确认防火墙规则已配置。它应该由安装程序自动创建。运行以下程序进行验证if (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) &#123; Write-Output &quot;防火墙规则 &#x27;OpenSSH-Server-In-TCP&#x27; 不存在，正在创建...&quot; New-NetFirewallRule -Name &#x27;OpenSSH-Server-In-TCP&#x27; -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22&#125; else &#123; Write-Output &quot;防火墙规则 &#x27;OpenSSH-Server-In-TCP&#x27; 已存在。&quot;&#125; 记得开放端口，默认为22端口。 一切都完成后，在本地计算机终端中运行： 1234ssh 服务器登录用户名@IP地址 -p 连接端口# 举例如下，端口可省略ssh Administrator@123.123.123.123 -p 22 然后输入密码即可连接成功。 Windows 设置中安装 OpenSSH VSCode 中使用 Remote - SSH 远程连接服务器首先确保上一方法是可行的。 VSCode 安装拓展Remote - SSH，左侧菜单会多出一个远程资源管理器图标。如图操作进入.ssh\\config。 .ssh\\config中这样填写： 1234Host my_server HostName 123.123.123.123 User Administrator Port 22 其中my_server是给服务器起的名称，随便填，HostName是服务器IP地址，User是服务器登录用户名，Port是连接端口，可省略，默认为22。 保存后左侧出现对应的服务器，选择在新窗口连接，输入密码，选择服务器操作系统，即可像在本地工作区一样对远程工作区进行操作。","categories":[{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://princesaoke.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Flutter取消ListView过度滑动效果","slug":"Flutter取消ListView过度滑动效果","date":"2023-10-11T07:09:38.000Z","updated":"2023-10-11T13:49:28.185Z","comments":true,"path":"2023/10/11/Flutter取消ListView过度滑动效果/","link":"","permalink":"http://princesaoke.github.io/2023/10/11/Flutter%E5%8F%96%E6%B6%88ListView%E8%BF%87%E5%BA%A6%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/","excerpt":"","text":"不止ListView，GridView、PageView等组件同样适用。 Flutter 3.10.1 方法在ListView外包裹一个ScrollConfiguration，设置behavior参数，child就是ListView： 1234ScrollConfiguration( behavior: ScrollConfiguration.of(context).copyWith(overscroll: false), child: ListView(),) Flutter 3.3.3 方法在早些时候的3.3.3版本我是用下面这个方法的，发现换到3.10.1后失效了。依然会有过度滑动的波纹效果，但变成了白色。 自定义一个类，继承ScrollBehavior，如下： 1234567891011121314151617181920212223242526import &#x27;package:flutter/material.dart&#x27;;// 取消ListView过度滑动的水波纹效果class OverScrollBehavior extends ScrollBehavior &#123; @override Widget buildViewportChrome( BuildContext context, Widget child, AxisDirection axisDirection) &#123; switch (getPlatform(context)) &#123; case TargetPlatform.iOS: return child; case TargetPlatform.android: case TargetPlatform.fuchsia: default: return GlowingOverscrollIndicator( // 不显示头部水波纹 showLeading: false, // 不显示尾部水波纹 showTrailing: false, axisDirection: axisDirection, color: Theme.of(context).colorScheme.secondary, child: child, ); &#125; &#125;&#125; 使用时在ListView外包裹一个ScrollConfiguration，behavior参数里实例化一个OverScrollBehavior即可： 1234ScrollConfiguration( behavior: OverScrollBehavior(), child: ListView(),)","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Android中的ShapeableImageView","slug":"Android中的ShapeableImageView","date":"2023-10-02T08:37:53.000Z","updated":"2023-10-02T11:56:26.099Z","comments":true,"path":"2023/10/02/Android中的ShapeableImageView/","link":"","permalink":"http://princesaoke.github.io/2023/10/02/Android%E4%B8%AD%E7%9A%84ShapeableImageView/","excerpt":"","text":"效果如下： 声明依赖项在 app&#x2F;build.gradle.kts 中的 dependencies 添加： 123dependencies &#123; implementation(&quot;com.google.android.material:material:1.8.0&quot;)&#125; 除了 ShapeableImageView ， Android Material 中还有很多其他有用的东西，以后接触到再慢慢记录。 添加 style在 res&#x2F;values&#x2F;styles.xml 中添加： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;!-- 圆形图片 --&gt; &lt;style name=&quot;circle_image&quot;&gt; &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;50%&lt;/item&gt; &lt;/style&gt; &lt;!-- 圆角图片 --&gt; &lt;style name=&quot;round_image&quot;&gt; &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;10dp&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 使用 ShapeableImageView1234567&lt;com.google.android.material.imageview.ShapeableImageView android:id=&quot;@+id/circle_image&quot; android:layout_width=&quot;64dp&quot; android:layout_height=&quot;64dp&quot; android:contentDescription=&quot;@null&quot; android:scaleType=&quot;centerCrop&quot; app:shapeAppearance=&quot;@style/circle_image&quot; /&gt; 若要描边效果，则加上以下属性： 属性 作用 strokeColor 描边颜色 strokeWidth 描边宽度 padding 为strokeWidth的一半 效果： 参考这篇文章","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的RecyclerView","slug":"Android中的RecyclerView","date":"2023-09-30T07:36:50.000Z","updated":"2023-12-20T15:59:45.356Z","comments":true,"path":"2023/09/30/Android中的RecyclerView/","link":"","permalink":"http://princesaoke.github.io/2023/09/30/Android%E4%B8%AD%E7%9A%84RecyclerView/","excerpt":"","text":"RecyclerView 相当于加强版的 ListView ，比 ListView 更灵活、更高效。 声明依赖项在 app&#x2F;build.gradle.kts 中的 dependencies 添加： 123dependencies &#123; implementation(&quot;androidx.recyclerview:recyclerview:1.2.1&quot;)&#125; 可将 1.2.1 修改为你想要的版本（一般是最新的稳定版），详情见官方文档 点击 Android Studio 右上角的 Sync Project with Gradle Files 同步依赖。 使用方法MainActivity.kt: 12345678// 要显示的数据val data = arrayOf(&quot;秦广王&quot;, &quot;楚江王&quot;, &quot;宋帝王&quot;, &quot;仵官王&quot;, &quot;阎罗王&quot;, &quot;卞城王&quot;, &quot;泰山王&quot;, &quot;都市王&quot;, &quot;平等王&quot;, &quot;转轮王&quot;)val recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recycler_view) // 用 id 找到 RecyclerViewrecyclerView.layoutManager = LinearLayoutManager(this) // 配置子视图的布局，可切换其他布局，如下一行// recyclerView.layoutManager = GridLayoutManager(this, 3) // 3表示一行有几个子视图val recyclerAdapter = MyAdapter(this, description.toMutableList());recyclerView.adapter = recyclerAdapter RecyclerViewAdapter.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// 自定义的 Adapter 类，继承 RecyclerView.Adapter/// 其中的 RecyclerView.Adapter 是个泛型，需要传入 ViewHolder/// 在 MyAdapter 类中实现一个自定义的 ViewHolderpublic class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; private final Context context; public List&lt;String&gt; data; public MyAdapter(Context context, List&lt;String&gt; data) &#123; this.context = context; this.data = data; &#125; /// 拿到 RecyclerView 子视图的布局 /// 其中 R.layout.list_item 是配置子视图布局的 xml 文件 @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; View view = View.inflate(context, R.layout.list_item, null); return new MyViewHolder(view); &#125; /// 将要显示的数据赋值给子视图 @Override public void onBindViewHolder(@NonNull MyViewHolder myViewHolder, int i) &#123; myViewHolder.textView.setText(data.get(i)); &#125; /// 返回 RecyclerView 子视图的数量 @Override public int getItemCount() &#123; return data == null ? 0 : data.size(); &#125; /// 自定义的 ViewHolder ，继承 RecyclerView.ViewHolder public static class MyViewHolder extends RecyclerView.ViewHolder &#123; private final TextView textView; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.list_item); &#125; &#125;&#125; res&#x2F;layout&#x2F;list_item.xml: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingStart=&quot;20dp&quot; android:paddingEnd=&quot;20dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/list_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; android:textStyle=&quot;bold&quot; /&gt;&lt;/LinearLayout&gt; activity_main.xml: 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; 在&lt;RecyclerView&gt;中加上app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;可以设置其子视图的布局，与 MainActivity.kt 中的 1recyclerView.layoutManager = LinearLayoutManager(this) 起相同作用。 删除数据并更新 获取要删除的item的位置position 从数据源中删除该item 调用RecyclerView的Adapter的notifyItemRemoved(position)方法通知RecyclerView删除该item 如果需要更新删除item后的位置，可以调用Adapter的notifyItemRangeChanged(position, itemCount)方法更新 如果需要撤销删除操作，可以调用Adapter的notifyItemInserted(position)方法插入该item","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Android中的ListView","slug":"Android中的ListView","date":"2023-09-24T15:31:27.000Z","updated":"2023-10-02T08:46:56.348Z","comments":true,"path":"2023/09/24/Android中的ListView/","link":"","permalink":"http://princesaoke.github.io/2023/09/24/Android%E4%B8%AD%E7%9A%84ListView/","excerpt":"","text":"ListView kotlin属性 数据类型 说明 adapter Adapter类 适配器，ListView将以该配置为模板显示内容 用法： 123456val data = arrayOf(&quot;角木蛟&quot;, &quot;亢金龙&quot;, &quot;尾火虎&quot;, &quot;箕水豹&quot;)// 构造函数的参数，第一个是上下文对象Context，第二个是适配器Adapter，第三个是要传进ListView展示的数据val adapter = ArrayAdapter(this, android.R.layout.simple_expandable_list_item_1, data)val listView = findViewById&lt;ListView&gt;(R.id.listview)listView.adapter = adapter 这里的android.R.layout.simple_expandable_list_item_1还可以改用其他Adapter适配器。 ArrayAdapter simple_list_item_1 simple_list_item_2 simple_list_item_single_choice simple_list_item_multiple_choice simple_list_item_checked SimpleAdapterSimpleAdapter 允许你写一个布局，然后ListView中的所有行都使用这个布局。基本能实现任意效果。 res&#x2F;layout&#x2F;list_item.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:paddingStart=&quot;20dp&quot; android:paddingEnd=&quot;20dp&quot; android:paddingTop=&quot;10dp&quot; android:paddingBottom=&quot;10dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/list_item_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;TextView android:id=&quot;@+id/list_item_description&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; java&#x2F;MainActivity.kt 123456789101112131415161718// 要显示的数据val title = arrayOf(&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;)val description = arrayOf(&quot;周一周一，奄奄一息&quot;, &quot;周二周二，肚子好饿&quot;, &quot;周三周三，带病上班&quot;, &quot;周四周四，重见天日&quot;, &quot;周五周五，敲锣打鼓&quot;, &quot;周六周六，大鱼大肉&quot;, &quot;周日周日，死期将至&quot;)// Adapter要的数据是一个List，List里每个Map对应一行，Map里一个键值对即一个要显示的数据val datas = mutableListOf&lt;Map&lt;String, String&gt;&gt;()for (i in title.indices) &#123; val map = hashMapOf(&quot;title&quot; to title[i], &quot;description&quot; to description[i]) datas.add(map)&#125;val adapter = SimpleAdapter( this, // 上下文 Context datas, // 数据 R.layout.list_item, // 布局文件，每一行按该布局文件布局 arrayOf&lt;String&gt;(&quot;title&quot;, &quot;description&quot;), // 有哪些数据 intArrayOf(R.id.list_item_title, R.id.list_item_description) // 对应上一行，将数据放到布局文件中的哪里) 效果如下：","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"转发QQ语音","slug":"转发QQ语音","date":"2023-09-22T13:27:26.000Z","updated":"2023-09-22T14:43:08.155Z","comments":true,"path":"2023/09/22/转发QQ语音/","link":"","permalink":"http://princesaoke.github.io/2023/09/22/%E8%BD%AC%E5%8F%91QQ%E8%AF%AD%E9%9F%B3/","excerpt":"","text":"本文介绍如何原封不动地转发他人的语音。 注：本文章介绍的方法在本文发布时间 2023-09-22 仍然有效，不排除未来失效的可能 一、找到语音在本地的.amr文件手机QQ暂时没有找到办法，需要用电脑端QQ。 首先登录电脑端QQ，确定目标语音的发送时间以便于在大量本地文件中搜索。 在QQ中打开设置-&gt;文件管理-&gt;打开个人文件夹，在个人文件夹中打开Audio，按时间排序找到.amr目标语音文件。copy一份保存。 但是.amr格式是不能直接播放的，并且普通的格式转换工具也不起作用，QQ从某个时间点开始对语音进行了加密。 二、.amr 转 .mp3需要用到特制的工具：silk2mp3 注：该工具似乎只能windows环境下运行 下载解压完后运行 silk2mp3.exe ，点击“导入待转换文件”，选择要转换的.amr语音，输出目录可以自己改，然后点开始转换，即可将 .amr 文件转换为 .mp3 文件。 在此感谢该工具的作者 kn007 三、将 .mp3 文件以语音形式发送这一步最好用数据线把手机连上电脑，选择文件传输模式，在电脑上对文件进行操作。 打开手机QQ进入聊天界面，点击录音，录音的时长就是语音发出去要显示的时长，然后结束录音，但注意不要点发送。 这时候电脑打开“此电脑”，进入手机的存储空间（连数据线的时候要选文件传输才能看到手机），进入 Android&#x2F;data&#x2F;com.tencent.mobileqq&#x2F;Tencent&#x2F;MobileQQ&#x2F;以你的QQ号命名的文件夹&#x2F;ptt&#x2F;以年月命名的文件夹（如202309）&#x2F;以日期命名的文件夹（如22），在其中根据时间找到你刚才的录音文件（.slk），复制其文件名及后缀，然后把你要转发的.mp3文件复制到这个目录，文件名改成刚复制的文件名（.mp3后缀也改成.slk），原来那个.slk文件就可以删掉了。 然后回到手机QQ点发送，发送出去的语音就是mp3文件的声音。 这里要注意，发送出去的语音上显示的语音时长和真正播放出来的语音时长是不一样的，显示的时长只取决于你录音录了多久，而播放的时长只取决于你的mp3文件的时长。 所以记得保证录音的时间和mp3文件的时长一样，否则可能会出现你点开两秒钟的语音却播放了一分钟的情况。","categories":[{"name":"整点花活","slug":"整点花活","permalink":"http://princesaoke.github.io/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/"}],"tags":[{"name":"QQ","slug":"QQ","permalink":"http://princesaoke.github.io/tags/QQ/"}]},{"title":"Android笔记","slug":"Android笔记","date":"2023-09-20T05:41:09.000Z","updated":"2023-10-27T03:50:07.762Z","comments":true,"path":"2023/09/20/Android笔记/","link":"","permalink":"http://princesaoke.github.io/2023/09/20/Android%E7%AC%94%E8%AE%B0/","excerpt":"","text":"项目结构 java文件夹下：业务逻辑 AndroidManifest.xml：项目配置文件 res&#x2F;layout文件夹下：页面布局 res&#x2F;values文件夹下：全局常量 res&#x2F;drawable文件夹下：图片资源 res&#x2F;mipmap系列：不同分辨率的图片资源，根据屏幕大小使用不同规格的图片，一般放APP图标 单位 单位 说明 dp device independent pixels（设备独立像素），不同设备有不同的显示效果，推荐使用这个 px pixels（像素） pt point，1pt &#x3D; 1&#x2F;72 英寸 sp scaled pixels（放大像素），字体大小一般用这个 View 和 ViewGroup 页面上的一个UI组件就是一个View，如&lt;TextView&gt;、&lt;Button&gt;等 ViewGroup是一组View的布局方式，如&lt;LinearLayout&gt;、&lt;RelativeLayout&gt;等 四大组件 Activity ： Service ： BroadcastReceiver ：允许你的应用接收来自各处的广播消息，比如电话、短信等，当然，你的应用也可以向外发出广播消息 ContentProvider ：为应用程序之间共享数据提供了可能，比如你想要读取系统通讯录中的联系人，就需要通过ContentProvider来实现 六大基本布局 线性布局 LinearLayout ：View按水平或竖直排列 相对布局 RelativeLayout ：使用margin和padding相对父容器布局 表格布局 TableLayout ：&lt;TableLayout&gt;内使用&lt;TableRow&gt;定义一行，&lt;TableRow&gt;中几个元素就是几列 帧布局 FrameLayout ：即叠层布局。帧布局的大小由控件中最大的子控件决定 绝对布局 AbsoluteLayout ：已弃用，建议改用 ConstraintLayout 网格布局 GridLayout ：将视图按格子排列 线性布局 LinearLayout xml参数 取值 说明 layout_width “match_parent”、”wrap_content” 线性布局的宽度 layout_height “match_parent”、”wrap_content” 线性布局的高度 orientation “vertical”、”horizontal” 内部视图排序方向 divider 一个视图View 内部每两个相邻视图之间都有一个View GridLayout 内视图参数 xml参数 取值 说明 layout_width “match_parent”、”wrap_content” 线性布局的宽度 layout_height “match_parent”、”wrap_content” 线性布局的高度 layout_weight 1、2、3、…… 该视图占整个线性布局大小的权重，使用该参数时注意 layout_width 与 layout_height 要有一个为 “wrap_content” 网格布局 GridLayout xml参数 取值 说明 rowCount 1、2、3、…… 共有几行 columnCount 1、2、3、…… 共有几列 orientation “horizontal”、”vertical” 内部视图排序方向 GridLayout 内视图参数 xml参数 取值 说明 layout_rowSpan 1、2、3、…… 该视图横跨几列 layout_columnSpan 1、2、3、…… 该视图竖跨几行 layout_gravity “fill”、…… 有使用以上两参数，则该参数为”fill” 表格布局 TableLayout xml参数 取值 说明 stretchColumns 0、1、2、…… 被拉伸的列序号 hint 任意字符串 输入框为空时的提示词，无该参数会报错 LogAndroid中的日志工具类是Log（android.util.Log），这个类中提供了如下5个方法来供我们打印日志（级别从低到高）。 Log.v()。级别verbose，用于打印那些最为琐碎的、意义最小的日志信息 Log.d()。级别debug，用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的 Log.i()。级别info，用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为的数据 Log.w()。级别warn，用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方 Log.e()。级别error，用于打印程序中的错误信息，一般代表你的程序出现严重问题了，必须尽快修复 TextView xml参数 取值 说明 textStyle bold、italic等 字体样式，如加粗、斜体等 shadowRadius 浮点数 阴影模糊程度 singleLine true、false 文本单行显示 ellipsize end等 文本超出范围的省略方式 EditText xml参数 取值 说明 inputType text、number等 指明输入内容的类型以弹出对应键盘 hint 任意字符串 输入框为空时的提示词，无该参数会报错 drawableXXX Vector 在输入框的指定方位添加icon或图片 hint 任意字符串 输入框为空时的提示词，无该参数会报错 kotlin方法 返回值 说明 getText 返回输入框中的内容 Button xml参数 取值 说明 onClick 字符串，为点击后要执行的方法名 点击按钮后会调用对应的方法，与 setOnClickListener 相同 background selector 按钮背景图片 backgroundTint selector 按钮背景图片颜色 ListView详见我的另一篇文章：Android中的ListView RecyclerView详见我的另一篇文章：Android中的ListView ShapeableImageView详见我的另一篇文章：Android中的ShapeableImageView","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Git提交规范","slug":"Git提交规范","date":"2023-09-18T06:27:36.000Z","updated":"2023-09-18T07:11:40.077Z","comments":true,"path":"2023/09/18/Git提交规范/","link":"","permalink":"http://princesaoke.github.io/2023/09/18/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","excerpt":"","text":"VSCode 插件：git-commit-plugin 该插件可帮助你规范commit描述格式，便于生成易于阅读且美观的提交。 修改上次commit的描述有时候我们提交的描述格式或内容填错了，想要覆盖掉之前的描述，只能重新commit一次，但这样就会多一个提交记录。 其实有一个不需要重新提交就可以修改上次commit描述的方法，详见这篇文章","categories":[{"name":"整点花活","slug":"整点花活","permalink":"http://princesaoke.github.io/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://princesaoke.github.io/tags/Git/"}]},{"title":"关于AndroidStudio的一些问题","slug":"关于AndroidStudio的一些问题","date":"2023-09-17T07:11:53.000Z","updated":"2023-10-17T10:06:30.864Z","comments":true,"path":"2023/09/17/关于AndroidStudio的一些问题/","link":"","permalink":"http://princesaoke.github.io/2023/09/17/%E5%85%B3%E4%BA%8EAndroidStudio%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"","text":"Gradle 版本与 Java 版本不匹配Gradle 7.4 最高只支持到 Java17，Java20 要 Gradle8.3 。 之前装了一下Java20，然后出问题了，安卓项目打不开，编译报错，最后改用Java17。 Android Studio 内部 jre 路径缓存换了Java版本，路径也变了。即便我配置好了环境变量，Android Studio 还是默认到之前的路径去找jre，看网上说应该是 Android Studio 内部的缓存路径没变。我干脆直接重装，换了2022的版本，用了新UI，颜值稍微高了那么一点点，不过还是难用。 安卓虚拟机（AVD）的问题创建一台设备，一点启动，直接弹窗说设备已终止什么的，反正就是启动不了。检查一下C盘，如果你和我一样C盘爆红，那应该是空间不足。 按照这篇文章的步骤去做，把.android文件夹移到别的磁盘，然后添加环境变量，完美解决。 启动是可以启动了，但还有别的问题：虚拟机屏幕一闪一闪的，而且动不动就卡死然后直接蓝屏。 终止代码 CLOCK_WATCHDOG_TIMEOUT，暂时还不知道什么原因。 😅","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"}]},{"title":"Flutter版本切换","slug":"Flutter版本切换","date":"2023-09-14T05:40:25.000Z","updated":"2023-09-17T07:06:26.020Z","comments":true,"path":"2023/09/14/Flutter版本切换/","link":"","permalink":"http://princesaoke.github.io/2023/09/14/Flutter%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/","excerpt":"","text":"本文记录如何切换Flutter到指定版本。使用该方法一步到位，无需再修改Dart版本。 参考文章：http://www.taodudu.cc/news/show-3618721.html 一、切换 Flutter SDK 分支进入安装 flutter sdk 的文件夹，终端输入 1git checkout 3.10.1 // 3.10.1 换成要切换到的版本号 将sdk切换到其他版本。 二、Flutter Doctor 更新 Dart SDK 及工具包终端输入 1flutter doctor 进行flutter检查，会自动帮你装上与flutter版本对应的 dart sdk 及相关的工具包。 最后终端输入 1flutter --version 检查版本是否切换成功。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"}]},{"title":"Java笔记","slug":"Java笔记","date":"2023-09-14T05:34:31.000Z","updated":"2023-09-17T08:03:22.603Z","comments":true,"path":"2023/09/14/Java笔记/","link":"","permalink":"http://princesaoke.github.io/2023/09/14/Java%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简单记一下 包管理 修饰符 当前类 同一包内 同一包内的子类 不同包内的子类 其他包 public √ √ √ √ √ protected √ √ √ 可访问父类的protected，不可访问父类对象的protected × default √ √ √ × × private √ × × × × instanceof：判断一个变量是否是某个类的实例12345// Car 是 Vehicle 的子类Car car = new Car();boolean flag1 = car instanceof Car // flag1 = trueboolean flag2 = car instanceof Vehicle // flag2 = trueboolean flag3 = car instanceof Cat // flag1 = false Math 原始值 floor（向下取整） round（四舍五入） ceil（向上取整） 2.7 2 3 3 2.3 2 2 3 -2.3 -3 -2 -2 -2.7 -3 -3 -2 floor是地板的意思，ceil是天花板，就很好记了 throw &amp; throwsthrow用于主动抛出异常： 1234567891011public double divide(double x, double y) &#123; try &#123; if (y == 0) &#123; throw new ArithmeticException(); &#125; else &#123; return x / y; &#125; &#125; catch (ArithmeticException exception) &#123; exception.printStackTrace(); &#125;&#125; 加了throws的函数，函数内部抛出的异常要在函数外捕捉到： 12345678910111213141516// 当抛出异常时，不在函数内捕捉，而是抛出到函数外public double divide(double x, double y) throws ArithmeticException &#123; if (y == 0) &#123; throw new ArithmeticException(); &#125; return x / y;&#125;// 捕捉到divide方法内部抛出的异常public static void main(String[] args) &#123; try &#123; divide(5, 0); &#125; catch (ArithmeticException exception) &#123; exception.printStackTrace(); &#125;&#125; ArrayList 与 LinkedList 的区别底层数据结构 ArrayList 使用动态数组来存储元素，这意味着在内存中分配一块连续的内存空间来保存元素 LinkedList 使用双向链表来存储元素，每个元素都包含对前一个和后一个元素的引用 插入和删除操作 ArrayList 的随机访问非常快速，因为可以通过索引直接访问元素。但是，插入和删除元素时，需要移动后续元素，效率较低 LinkedList 的插入和删除操作效率较高，因为只需更改节点的引用。但是，随机访问元素效率较低，因为必须从头或尾部开始遍历链表 内存消耗 ArrayList 在存储大量元素时可能会浪费一些内存，因为它分配一块较大的内存空间。但它在随机访问时效率较高 LinkedList 每个元素都需要额外的内存来存储引用，因此在存储大量元素时可能会消耗更多内存。但它在插入和删除操作时效率较高 适用场景 ArrayList 适用于需要频繁随机访问元素的情况，但不需要频繁执行插入和删除操作的情况 LinkedList 适用于需要频繁执行插入和删除操作的情况，但不需要频繁随机访问元素的情况 chatGPT原话 : ) LocalDateTime &amp; LocalDate &amp; LocalTime参考的是这篇文章 三者区别是，LocalDate只能存日期，LocalTime只能存时间，LocalDateTime既可以存日期又可以存时间。这里只介绍LocalDateTime。 12345678910111213141516171819202122// 实例化var localDateTime1 = LocalDateTime.now();var localDateTime2 = LocalDateTime.of(2023, 9, 11, 22, 23, 00); // 2023-09-11 22:23:00// 字符串转LocalDateTimevar localDateTime3 = LocalDateTime.parse(&quot;2023-09-11T22:23:00&quot;); // 必须要有TDateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);var localDateTime4 = LocalDateTime.parse(&quot;2023-09-11 22:23:00&quot;, formatter); // 将字符串按照formatter中规定的格式转化// 获取星期DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek(); // 假设为星期天System.out.println(dayOfWeek.getValue()); // 7// TextStyle.FULL(星期全称), Locale.CHINA(用中文输出)System.out.println(dayOfWeek.getDisplayName(TextStyle.FULL, Locale.CHINA)); // 星期日// TextStyle.FULL(星期全称), Locale.CHINA(用中文输出)System.out.println(dayOfWeek.getDisplayName(TextStyle.Short, Locale.CHINA)); // 周日// 获取月份同上// 增加日期localDateTime1 = localDateTime1.plus(5, ChronoUnit.DAYS); // 日期+5，下同localDateTime1 = localDateTime1.plusDays(5); Date &amp; Calendar （已弃用）注：Date类与Calendar类已弃用！ 看完一问chatGPT，才知道这俩已经被LocalDateTime取代了，旧教程害人啊……笔记都做完了，就不删了吧 按自定义格式输出时间： 123SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;);System.out.println(format.format(date));// 2023-09-09 19:54:33 周六 其中HH:mm:ss是24小时制，hh:mm:ss是12小时制 或者用printf： 12System.out.printf(&quot;现在是：%tY-%tm-%td，%tp%tH:%tM:%tS，%tA&quot;, date, date, date, date, date, date, date, date);// 现在是：2023-09-09，下午20:07:02，星期六 使用Calendar 12345Calendar calendar = Calendar.getInstance(); // 创建对象，默认为当前时间calendar.set(2002, 11, 30); // 设置年月日calendar.set(Calendar.YEAR, 2077); // 单独设置某个属性System.out.println(calendar.get(Calendar.YEAR));// 2077 有关Date类与Calendar类的更多信息，参考这里","categories":[{"name":"Java相关","slug":"Java相关","permalink":"http://princesaoke.github.io/categories/Java%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"}]},{"title":"Github页面美化","slug":"Github页面美化","date":"2023-09-10T12:23:58.000Z","updated":"2023-09-17T07:08:46.428Z","comments":true,"path":"2023/09/10/Github页面美化/","link":"","permalink":"http://princesaoke.github.io/2023/09/10/Github%E9%A1%B5%E9%9D%A2%E7%BE%8E%E5%8C%96/","excerpt":"","text":"本文介绍如何把你的Github首页打扮的花里胡哨。 注：本文章内的icon可能需要vpn才能加载出来 在Github首页展示自定义内容每个项目的根目录下的README.md文件是该项目的说明，我们在接触一个项目时要做的第一件事就是阅读这个README.md文件。 在github，每个仓库的根目录下的README.md文件中的内容会被展示在源代码下方，便于阅读。如果你将仓库名称设为自己的github昵称，系统会提示你这是一个特殊的仓库。它的README.md文件不仅会展示在仓库下方，还会被展示在该用户的github首页，这意味着我们可以在其中添加一些自我介绍，让访客可以在首页直接看到。 添加技术栈icon你是否在他人的github首页看到这样花花绿绿的炫酷图标： 这是用到了 shields.io 上的icon图标。进入其官网，点击 Get Started，第一个 Static Badge 就是我们要用的。看它的默认样式，可能会觉得有点眼熟，因为很多地方都有用到，比如VSCode拓展插件介绍页面常用的icon。 注意，shields.io 的icon可能需要vpn才能正常加载。 简单来说，你可以通过在markdown中输入url来显示icon。 对于默认的样式，在markdown文件中引入 https://img.shields.io/badge/前半部分-后半部分-blue 来显示一个icon： 参数可以修改，其中颜色可以用六位十六进制数表示： https://img.shields.io/badge/Part1-Part2-FF0000 这和我们想要的效果差的有点远，别担心，回到shields.io的页面，在下方的 Query Parameters 中说明了我们可以在url中添加参数来调整icon的样式。 style：默认为flat，改成 flat-square 变成方角 logo：显示在icon左半部分，使用图标slug引用。文档告诉我们可以在 Simple Icons slugs 中找到logo对应的值。 logoColor：logo的颜色。同样可以使用十六进制表示。 综上，我们可以实现这样的icon： https://img.shields.io/badge/-Hexo-0073AA?style=flat-square&amp;logo=hexo&amp;logoColor=ffffff 其中左半部分的文字（label）为空 剩下就是依葫芦画瓢，可以加入其他参数让icon更美观。 Github Stats注意到还有张 Github Stats 的图片，上边显示你github的各项数值，同时打了一个等级，看起来也很炫酷，copy了！ 怎么做呢？这其实是引用了 GitHub Readme Stats ，可以在README.md中获取动态生成的gitHub统计信息。 进入 GitHub Readme Stats 的文档，文档里直接告诉你了将以下代码复制进README.md文件就可以： 1[![GitHub stats](https://github-readme-stats.vercel.app/api?username=你的Github昵称)](https://github.com/你的Github昵称/github-readme-stats) // 替换其中的Github昵称 当然官方也提供了其他参数支持自定义，可以选择隐藏指定信息或修改主题颜色等。具体方法文档里都有，此处省略。 这个项目非常强大，还支持编程语言统计（柱状图、环形图和饼状图），以及将仓库卡片展示到README.md中，最重要的是有中文文档！Star了！ 贪吃蛇动图具体步骤参考这个视频 并且，就在我写这篇博文的时候，突然发现这个up还找到了Github上一个profile巨丰富的用户：https://github.com/BEPb 当然这家伙的首页内容对于一般人来说就过于花里胡哨了，我们没必要整太多华而不实的东西，挑一两个喜欢的效果装扮一下自己的主页就好了。 我的Github首页","categories":[{"name":"整点花活","slug":"整点花活","permalink":"http://princesaoke.github.io/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://princesaoke.github.io/tags/Github/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2023-09-02T03:40:09.000Z","updated":"2023-10-22T11:12:10.644Z","comments":true,"path":"2023/09/02/Hexo搭建个人博客/","link":"","permalink":"http://princesaoke.github.io/2023/09/02/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"本文介绍如何使用Hexo搭建一个个人博客。 一、安装Node.js关于安装node.js这部分，我参考的是这篇文章。 首先到node.js中文官网下载安装包。 运行安装包，修改安装路径，不勾选 necessary tools，一路next安装完毕。默认的设置是有安装npm的，这个很重要，相当于应用商店，第三方的包都通过它下载，必装。 顺便吐槽一句这个npm明明用了淘宝镜像还是一样下载不动，然后过一会就又好了，玄学网络。而且下载完一个包也无法继续输入命令，只能关掉cmd重新打开，隔壁python的pip都没有这种问题。 win+r输入cmd打开命令提示符，输入 1node -v 或 1node --version 查看node版本，如果提示“不是内部或外部命令”说明没安装成功。 npm也是一样，输入 1npm -v 查看npm版本。 二、安装Hexo成功安装node.js和npm后，继续在cmd中输入以下命令 1npm install -g hexo-cli 安装Hexo。 合理外推卸载命令就是 1npm uninstall -g hexo-cli 注意到有个-g，意思是全局安装，不加-g就是在当前文件夹局部安装，出了当前文件夹就相当于没安装，类比python的虚拟环境。 同时还有 hexo 和 hexo-cli 的区别，之前也疑惑过 vue 和 vue-cli，这个我暂时还不太明白。总之有-cli和没有是两个不同的东西。按我理解，用hexo就是把hexo整个框架都下载下来，而用hexo-cli就是只下载hexo的一些命令，用创建hexo项目的时候用命令远程拉取模板。不知道我理解的对不对。 三、创建Hexo项目cmd输入 1hexo init personal-hexo 新建hexo项目。其中personal-hexo是创建的hexo项目的名称 进入hexo项目的文件夹，一手 1npm install 安装依赖包。 再一手 1hexo server 或 1hexo s 启动hexo服务器。这时会告诉你hexo正在本地运行，打开它给的地址 http://localhost:4000/ ，就可以看到hexo的默认页面了。 四、Hexo使用指南IDE打开hexo项目，先看项目结构。根目录下，scaffolds文件夹里存放模板文件。scaffolds&#x2F;post.md 文件就是文章的模板文件，比如往里面加一条categories，新建的博文就会带上这个字段。 scaffolds&#x2F;_config.yml 文件是整个博客网站的配置文件。title就是HTML中的title，subtitle和description想填什么就填什么，author改成自己，language改成zh-CN，url改成 http:&#x2F;&#x2F;你的Github昵称.github.io ，其他暂时都不用改。 scaffolds&#x2F;source 文件夹下的是网站的主体，其中的文件夹可以通过url访问到，以下划线开头的文件夹除外。 scaffolds&#x2F;source&#x2F;_posts 中存放的即我们的博客。在终端中执行命令 1hexo new Hexo搭建个人博客 其中”Hexo搭建个人博客”是文章名。 发现 scaffolds&#x2F;source&#x2F;_posts 中多了刚才新建的文章，打开浏览器也可以看到博文创建成功了。现在可以用markdown尽情编辑博文了！ 五、更换主题我使用的是 hexo-theme-pure 主题，Github地址在这，Gitee地址在这。建议看Gitee上的，文档是中文。 第三方的主题都放在themes文件夹下。项目根目录下终端执行 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure themes&#x2F;pure&#x2F;_config.yml 是主题的配置文件。按需配置，我的配置如下： menu决定菜单中有哪些栏目。由于我没有豆瓣号，就把豆瓣书单那一栏注释掉了，这样就没有豆瓣书单这个页面。 site决定博客网站的基本配置。 根据logo中的url找到对应的图片，即博客的头像，改成自己的图片。 title就是HTML中的title favicon即浏览器标签上的图标，找到 themes&#x2F;pure&#x2F;source&#x2F;favicon.png，改成自己的图片。 board是公告，可以是HTML中的元素 configskin可以更改主题颜色，除默认的白色外还有 theme-black theme-blue theme-green theme-purple 四种。 donate文章底部请作者喝咖啡的赞赏部分。我不喜欢，enable改成false就不显示了。要保留的话按对应路径找到图片替换成自己的。 share文章底部的分享部分。sites是电脑网页显示的，mobile_sites是手机网页端显示的，可以加的值有 qq,wechat,qzone,weibo,facebook,twitter repositoryplatform有github和gitee两种，username填你对应托管平台的用户名。 pv用于统计你的网站有多少访客。提供了不蒜子和leancloud两种方式，我用的是不蒜子，把busuanzi下的enable设为true。 postCount统计你每一篇文章的字数和阅读时间。要开启哪一个功能就把对应的值设为true，enable为true则这两个功能都失效。 profile一些个人资料。按前面的方法自行配置就好了。 复制_source把 themes&#x2F;pure&#x2F;_source里的所有文件夹（除去你前面menu那里注释掉的界面，比如我不需要豆瓣书单，books文件夹就不需要复制）复制到根目录下的source文件里。_data和404也复制过去。_data里的links.yml文件中是友情链接，每个友情链接按如下格式： 1234MyFriendName: link: https://his_link/ // 改成朋友的链接 avatar: https://his_avatar.png // 改成朋友的头像url desc: &quot;His discription&quot; // 给朋友的描述 _data里的gallery.yml文件是干什么的我暂时还没搞懂。 现在重新访问浏览器，发现你的博客网站已经大变样了，一切操作正确的话不会出现任何问题。 六、将Hexo部署到 Github Pages使用 hexo-deployer-git。参考这篇文章。 先在自己的github上新建一个仓库，仓库名为 你的Github昵称.github.io ，如 PrinceSaoKe.github.io。 在终端输入 1npm install hexo-deployer-git --save 安装 hexo-deployer-git。 打开根目录下的_config.yml文件，滑到最底下找到deploy，改成 1234deploy: type: git repo: https://github.com/你的github昵称/你的github昵称.github.io branch: master // 注意看你仓库的主分支是master还是main，一般是master 最后，依次在终端输入以下命令： 123hexo cl // 清理之前的页面hexo g // 生成新的页面hexo d // 部署网站到创建的仓库 hexo d这一步需要vpn。 刚部署完可能要过一两分钟，然后在任意一个设备的浏览器输入网址 http:&#x2F;&#x2F;你的Github昵称.github.io 就可以访问到你的hexo博客啦！ 写博客好累，后面应该不会写得这么详细了。我的hexo个人博客也上传到了github，欢迎参观","categories":[{"name":"整点花活","slug":"整点花活","permalink":"http://princesaoke.github.io/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://princesaoke.github.io/tags/Hexo/"}]}],"categories":[{"name":"面经","slug":"面经","permalink":"http://princesaoke.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"http://princesaoke.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://princesaoke.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"移动端","slug":"移动端","permalink":"http://princesaoke.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"整点花活","slug":"整点花活","permalink":"http://princesaoke.github.io/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/"},{"name":"Java相关","slug":"Java相关","permalink":"http://princesaoke.github.io/categories/Java%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://princesaoke.github.io/tags/Vue3/"},{"name":"MySQL","slug":"MySQL","permalink":"http://princesaoke.github.io/tags/MySQL/"},{"name":"Flutter","slug":"Flutter","permalink":"http://princesaoke.github.io/tags/Flutter/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://princesaoke.github.io/tags/Kotlin/"},{"name":"HTML","slug":"HTML","permalink":"http://princesaoke.github.io/tags/HTML/"},{"name":"服务器","slug":"服务器","permalink":"http://princesaoke.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Android","slug":"Android","permalink":"http://princesaoke.github.io/tags/Android/"},{"name":"QQ","slug":"QQ","permalink":"http://princesaoke.github.io/tags/QQ/"},{"name":"Git","slug":"Git","permalink":"http://princesaoke.github.io/tags/Git/"},{"name":"Java","slug":"Java","permalink":"http://princesaoke.github.io/tags/Java/"},{"name":"Github","slug":"Github","permalink":"http://princesaoke.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://princesaoke.github.io/tags/Hexo/"}]}